; alist.froth - Association list (key-value dictionary)
;
; An alist is a cons list of [key value] pairs: . [k1 v1] , [k2 v2] , ...
; Keys can be any value type; lookup uses = for equality.
; Insert is O(1), lookup/update/delete are O(n).

; alist-find: (alist key -- pair 0 | 1)
; Find the pair with the given key.
; Returns (pair 0) if found, (1) if not found.
['lfoldl 'dup 'swap 'drop] {
  /key /alist
  . 1  ; initial: nil result, not-found
  alist {
    /pair /found /result
    found {
      ; already found - pass through
      result 0
    } {
      ; not found yet - check this pair
      pair 0 @ key = { pair 0 } { result 1 } ?!
    } ?!
  } lfoldl!
  ; stack: result found
  dup! { } { swap! drop! } ?!  ; if not found, drop nil and keep 1
} def-fn! /alist-find

; alist-get: (alist key -- value 0 | 1)
; Get value for key. Returns (value 0) if found, (1) if not found.
['alist-find] {
  /key /alist
  alist key alist-find!
  { 1 @ 0 } { 1 } ?!
} def-fn! /alist-get

; alist-has: (alist key -- 0 | 1)
; Check if key exists. Returns 0 if present, 1 if absent.
['alist-find 'drop] {
  /key /alist
  alist key alist-find!
  { drop! 0 } { 1 } ?!
} def-fn! /alist-has

; alist-set: (alist key value -- alist')
; Set or update key to value. Returns new alist.
['alist-has 'lmap] {
  /value /key /alist
  alist key alist-has!
  {
    ; key exists, update via lmap
    alist { /pair pair 0 @ key = { [ key value ] } { pair } ?! } lmap!
  } {
    ; key doesn't exist, cons new pair - O(1)
    alist [ key value ] ,
  } ?!
} def-fn! /alist-set

; alist-delete: (alist key -- alist')
; Remove key from alist. Returns new alist.
['lfoldr] {
  /key /alist
  .  ; start with empty list
  alist {
    /pair /acc
    pair 0 @ key = { acc } { acc pair , } ?!
  } lfoldr!
} def-fn! /alist-delete

; alist-keys: (alist -- array)
; Get all keys as an array.
['lfoldl] {
  /alist
  [ alist { 0 @ } lfoldl! ]
} def-fn! /alist-keys

; alist-values: (alist -- array)
; Get all values as an array.
['lfoldl] {
  /alist
  [ alist { 1 @ } lfoldl! ]
} def-fn! /alist-values

; alist-size: (alist -- n)
; Get number of entries.
['lfoldl 'drop] {
  /alist
  0 alist { drop! 1 + } lfoldl!
} def-fn! /alist-size

; alist-empty: (alist -- 0 | 1)
; Check if alist is empty. Returns 0 if empty, 1 if not.
[] { isNil } def-fn! /alist-empty
