; alist.froth - Association list (key-value dictionary)
;
; An alist is an array of [key value] pairs: [ [k1 v1] [k2 v2] ... ]
; Keys can be any value type; lookup uses = for equality.
; Operations are O(n) but simple and sufficient for small dictionaries.

; alist-find: ( alist key -- pair 0 | 1 )
; Find the pair with the given key.
; Returns (pair 0) if found, (1) if not found.
['foldl 'dup 'swap 'drop] {
  /key /alist
  . 1  ; initial: nil result, not-found (1 = false = not found yet)
  alist {
    /pair /found /result
    found {
      ; found = 0 (true), already found - pass through
      result 0
    } {
      ; found = 1 (false), not found yet - check this pair
      pair 0 @ key = { pair 0 } { result 1 } ?!
    } ?!
  } foldl!
  ; stack: result found
  dup! { } { swap! drop! } ?!  ; if not found, drop nil and keep 1
} def-fn! /alist-find

; alist-get: ( alist key -- value 0 | 1 )
; Get value for key. Returns (value 0) if found, (1) if not found.
['alist-find] {
  /key /alist
  alist key alist-find!
  { 1 @ 0 } { 1 } ?!
} def-fn! /alist-get

; alist-has: ( alist key -- 0 | 1 )
; Check if key exists. Returns 0 if present, 1 if absent.
['alist-find 'drop] {
  /key /alist
  alist key alist-find!
  { drop! 0 } { 1 } ?!
} def-fn! /alist-has

; alist-set: ( alist key value -- alist' )
; Set or update key to value. Returns new alist.
['alist-has 'map 'concat] {
  /value /key /alist
  alist key alist-has!
  {
    ; key exists, update in place
    alist { /pair pair 0 @ key = { [ key value ] } { pair } ?! } map!
  } {
    ; key doesn't exist, append
    alist [ [ key value ] ] concat!
  } ?!
} def-fn! /alist-set

; alist-delete: ( alist key -- alist' )
; Remove key from alist. Returns new alist.
['filter 'not] {
  /key /alist
  alist { /pair pair 0 @ key = not! } filter!
} def-fn! /alist-delete

; alist-keys: ( alist -- array )
; Get all keys as an array.
['foldl] {
  /alist
  [ alist { 0 @ } foldl! ]
} def-fn! /alist-keys

; alist-values: ( alist -- array )
; Get all values as an array.
['foldl] {
  /alist
  [ alist { 1 @ } foldl! ]
} def-fn! /alist-values

; alist-size: ( alist -- n )
; Get number of entries.
{ # } /alist-size

; alist-empty: ( alist -- 0 | 1 )
; Check if alist is empty. Returns 0 if empty, 1 if not.
{ # 0 = } /alist-empty
