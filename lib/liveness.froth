; lib/liveness.froth
; Liveness analysis for Froth compiler

; liveness-term-impl: (term bnd-map seen seq-fn term-fn -- result-map new-seen)
; Analyze a single term for liveness (last reference).
; Takes boundness map, returns map with liveness info added.
; seen: set of variables still live after this point
; Traverses right-to-left using boundness info.
['delete-keys 'add-keys 'restrict 'not 'and 'filter] { /term-fn /seq-fn /seen /bnd-map /term
  ; Check if this is an identifier reference (has 'is-bound key)
  term isIdent bnd-map 'is-bound in 0 = and! {
    ; Identifier: check if still live (already in seen-set)
    seen term in {
      bnd-map 0 'is-live : seen                   ; already seen -> still live
    } {
      bnd-map 1 'is-live : seen . term :          ; first occurrence (right-to-left) -> last ref
    } ?!
  } {
  term isBinder {
    ; Binder: check if used (in seen-set), then remove from seen
    ; in returns 0 if exists (used), 1 if not (dead)
    term intern idToIdent /ident
    seen ident in /is-used
    bnd-map is-used 'is-used : seen ident delete
  } {
  term isFunc {
    ; Closure: fresh seen-set, compute dead-at-capture set
    bnd-map 'free-vars @ /inner-free-set
    bnd-map 'children @ /inner-children
    term # 1 - /inner-last-idx
    term inner-children $ inner-last-idx seq-fn term-fn seq-fn! /inner-seen /new-children
    ; Compute dead-set: free vars NOT in seen (last use is this capture)
    inner-free-set keys { /v seen v in not! } filter! /dead-vars
    $ dead-vars add-keys! /dead-set
    ; Add all free vars to seen (binders to left need to see them as used)
    seen inner-free-set keys add-keys! /new-seen
    ; Return map with updated children and dead-set
    bnd-map new-children 'children : dead-set 'dead-set : new-seen
  } {
  term isGen {
    ; Generator: shares scope for free vars, but binders are local
    bnd-map 'bound-set @ /inner-bound-set
    bnd-map 'children @ /inner-children
    inner-bound-set keys /bound-vars
    ; Save vars that will be shadowed (to restore after)
    seen bound-vars restrict! /save
    ; Remove bound vars from seen (entering their scope)
    seen bound-vars delete-keys! /gen-seen
    ; Process generator with modified seen
    term # 1 - /inner-last-idx
    term inner-children gen-seen inner-last-idx seq-fn term-fn seq-fn! /after-seen /new-children
    ; Restore shadowed vars
    after-seen save keys add-keys! /new-seen
    bnd-map new-children 'children : new-seen
  } {
  term isQuote {
    ; Quoted term: no liveness info
    bnd-map seen
  } {
    ; Literal, apply, operator, value: no liveness info
    bnd-map seen
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /liveness-term-impl

; liveness-seq-impl: (body children-arr seen idx seq-fn term-fn -- new-children-arr new-seen)
; Process terms from idx down to 0 (right-to-left)
['concat 'liveness-term-impl] { /term-fn /seq-fn /idx /seen /children-arr /body
  idx 0 < {
    ; Done: return empty array and current seen
    [] seen
  } {
    ; Process current term (rightmost remaining)
    body idx @ children-arr idx @ seen seq-fn term-fn term-fn! /after-term-seen /term-map
    ; Recurse for rest (to the left)
    body children-arr after-term-seen idx 1 - seq-fn term-fn seq-fn! /rest-seen /rest-children
    ; Append (we're going right-to-left, so rest is to the left)
    rest-children [term-map] concat! rest-seen
  } ?!
} def-fn! /liveness-seq-impl

; liveness: (func boundness-map -- func liveness-map)
; Analyze a function for liveness of each identifier reference.
; Takes boundness-map and adds liveness info:
;   'is-live: 0 (still live) or 1 (last reference) for identifiers
;   'is-used: 0 (used) or 1 (dead) for binders
;   'dead-set: set of vars whose last use is capture (for closures)
['liveness-seq-impl 'liveness-term-impl] { /bnd-map /func
  bnd-map 'children @ /children
  func # 1 - /last-idx
  func children $ last-idx liveness-seq-impl liveness-term-impl liveness-seq-impl!
  /final-seen /new-children
  func bnd-map new-children 'children :
} def-fn! /liveness

; Remove impl functions from the environment
env 'liveness-term-impl delete 'liveness-seq-impl delete restore
