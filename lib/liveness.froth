; lib/liveness.froth
; Liveness analysis for Froth compiler

; liveness-term-impl: (term boundness-term seen seq-fn term-fn -- result new-seen)
; Analyze a single term for liveness (last reference).
; result: 0 (still live), 1 (last ref), . (non-ref), or nested liveness array
; seen: set of variables still live after this point
; Traverses right-to-left using boundness info.
['delete-keys 'reduce 'not 'and] { /term-fn /seq-fn /seen /bnd /term
  ; Check if this is an identifier reference (boundness is 0 or 1, not .)
  term isIdent bnd isNil not! and! {
    ; Identifier: check if still live (already in seen-set)
    seen term in {
      0 seen                           ; already seen -> still live
    } {
      1 seen . term :                  ; first occurrence (right-to-left) -> last ref
    } ?!
  } {
  term isBinder {
    ; Binder: remove from seen-set (scope ends here going right-to-left)
    term intern idToIdent /ident
    . seen ident delete
  } {
  term isFunc {
    ; Closure: fresh seen-set, then add free vars to outer
    ; bnd is [free-set bound-set boundness-array]
    bnd 0 @ /inner-free-set
    bnd 2 @ /inner-boundness
    term # 1 - /inner-last-idx
    term inner-boundness $ inner-last-idx seq-fn term-fn seq-fn! /inner-seen /inner-liveness
    ; Add closure's free vars to outer seen (closure captures them)
    inner-free-set keys /free-vars
    inner-liveness free-vars seen { /k /acc acc . k : } reduce!
  } {
  term isGen {
    ; Generator: shares scope for free vars, but binders are local
    ; bnd is [free-set bound-set boundness-array]
    bnd 0 @ /inner-free-set
    bnd 1 @ /inner-bound-set
    bnd 2 @ /inner-boundness
    inner-bound-set keys /bound-vars
    ; Save vars that will be shadowed (to restore after)
    bound-vars $ { /v /acc seen v in { acc . v : } { acc } ?! } reduce! /save
    ; Remove bound vars from seen (entering their scope)
    seen bound-vars delete-keys! /gen-seen
    ; Process generator with modified seen
    term # 1 - /inner-last-idx
    term inner-boundness gen-seen inner-last-idx seq-fn term-fn seq-fn! /after-seen /inner-liveness
    ; Restore shadowed vars
    save keys after-seen { /k /acc acc . k : } reduce! /new-seen
    inner-liveness new-seen
  } {
  term isQuote {
    ; Quoted term: not a reference
    . seen
  } {
    ; Literal, apply, value: not a reference
    . seen
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /liveness-term-impl

; liveness-seq-impl: (body boundness-arr seen idx seq-fn term-fn -- liveness-array new-seen)
; Process terms from idx down to 0 (right-to-left)
['concat 'liveness-term-impl] { /term-fn /seq-fn /idx /seen /bnd-arr /body
  idx 0 < {
    ; Done: return empty array and current seen
    [] seen
  } {
    ; Process current term (rightmost remaining)
    body idx @ bnd-arr idx @ seen seq-fn term-fn term-fn! /after-term-seen /term-result
    ; Recurse for rest (to the left)
    body bnd-arr after-term-seen idx 1 - seq-fn term-fn seq-fn! /rest-seen /rest-liveness
    ; Append (we're going right-to-left, so rest is to the left)
    rest-liveness [term-result] concat! rest-seen
  } ?!
} def-fn! /liveness-seq-impl

; liveness: (func free-set bound-set boundness-array -- liveness-array)
; Analyze a function for liveness of each identifier reference.
; Returns liveness array parallel to function body with:
;   0 = still live (not the last reference)
;   1 = last reference
;   . = not an identifier reference (binder, apply, literal, quoted)
;   [liveness] = nested array for closures/generators
['liveness-seq-impl 'liveness-term-impl] { /bnd-arr /bound-set /free-set /func
  func # 1 - /last-idx
  func bnd-arr $ last-idx liveness-seq-impl liveness-term-impl liveness-seq-impl!
  /final-seen /result
  result
} def-fn! /liveness

; Remove impl functions from the environment
env 'liveness-term-impl delete 'liveness-seq-impl delete restore
