; lib/liveness.froth
; Liveness analysis for Froth compiler

; liveness-term-impl: (term boundness-term seen seq-fn term-fn -- result new-seen)
; Analyze a single term for liveness (last reference).
; result: 0 (still live / binder used), 1 (last ref / binder dead), . (non-var), or nested array
; seen: set of variables still live after this point
; Traverses right-to-left using boundness info.
['delete-keys 'add-keys 'restrict 'not 'and 'filter] { /term-fn /seq-fn /seen /bnd /term
  ; Check if this is an identifier reference (boundness is 0 or 1, not .)
  term isIdent bnd isNil not! and! {
    ; Identifier: check if still live (already in seen-set)
    seen term in {
      0 seen                           ; already seen -> still live
    } {
      1 seen . term :                  ; first occurrence (right-to-left) -> last ref
    } ?!
  } {
  term isBinder {
    ; Binder: check if used (in seen-set), then remove from seen
    ; in returns 0 if exists (used), 1 if not (dead)
    term intern idToIdent /ident
    seen ident in seen ident delete
  } {
  term isFunc {
    ; Closure: fresh seen-set, compute dead-at-capture set
    ; bnd is [free-set bound-set boundness-array]
    bnd 0 @ /inner-free-set
    bnd 2 @ /inner-boundness
    term # 1 - /inner-last-idx
    term inner-boundness $ inner-last-idx seq-fn term-fn seq-fn! /inner-seen /inner-liveness
    ; Compute dead-set: free vars NOT in seen (last use is this capture)
    inner-free-set keys { /v seen v in not! } filter! /dead-vars
    $ dead-vars add-keys! /dead-set
    ; Add all free vars to seen (binders to left need to see them as used)
    seen inner-free-set keys add-keys! /new-seen
    ; Return [inner-liveness dead-set]
    [inner-liveness dead-set] new-seen
  } {
  term isGen {
    ; Generator: shares scope for free vars, but binders are local
    ; bnd is [free-set bound-set boundness-array]
    bnd 1 @ /inner-bound-set
    bnd 2 @ /inner-boundness
    inner-bound-set keys /bound-vars
    ; Save vars that will be shadowed (to restore after)
    seen bound-vars restrict! /save
    ; Remove bound vars from seen (entering their scope)
    seen bound-vars delete-keys! /gen-seen
    ; Process generator with modified seen
    term # 1 - /inner-last-idx
    term inner-boundness gen-seen inner-last-idx seq-fn term-fn seq-fn! /after-seen /inner-liveness
    ; Restore shadowed vars
    after-seen save keys add-keys! /new-seen
    inner-liveness new-seen
  } {
  term isQuote {
    ; Quoted term: not a reference
    . seen
  } {
    ; Literal, apply, value: not a reference
    . seen
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /liveness-term-impl

; liveness-seq-impl: (body boundness-arr seen idx seq-fn term-fn -- liveness-array new-seen)
; Process terms from idx down to 0 (right-to-left)
['concat 'liveness-term-impl] { /term-fn /seq-fn /idx /seen /bnd-arr /body
  idx 0 < {
    ; Done: return empty array and current seen
    [] seen
  } {
    ; Process current term (rightmost remaining)
    body idx @ bnd-arr idx @ seen seq-fn term-fn term-fn! /after-term-seen /term-result
    ; Recurse for rest (to the left)
    body bnd-arr after-term-seen idx 1 - seq-fn term-fn seq-fn! /rest-seen /rest-liveness
    ; Append (we're going right-to-left, so rest is to the left)
    rest-liveness [term-result] concat! rest-seen
  } ?!
} def-fn! /liveness-seq-impl

; liveness: (func free-set bound-set boundness-array -- liveness-array)
; Analyze a function for liveness of each identifier reference.
; Returns liveness array parallel to function body with:
;   0 = still live (not the last reference), or binder is used
;   1 = last reference, or binder is unused (dead)
;   . = not a variable (apply, literal, quoted)
;   [[liveness] dead-set] = closure (dead-set = vars whose last use is capture)
;   [liveness] = generator
['liveness-seq-impl 'liveness-term-impl] { /bnd-arr /bound-set /free-set /func
  func # 1 - /last-idx
  func bnd-arr $ last-idx liveness-seq-impl liveness-term-impl liveness-seq-impl!
  /final-seen /result
  result
} def-fn! /liveness

; Remove impl functions from the environment
env 'liveness-term-impl delete 'liveness-seq-impl delete restore
