; Compile library functions in-place

cache-empty! tree-empty! 0 env

  ; defs.froth
  'def-fn compile!

  ; io.froth
  'nl compile!
  'println compile!
  'writeln compile!

  ; control.froth
  'while compile!
  'while-loop compile!
  'until compile!
  'until-loop compile!
  'times compile!
  'times-loop compile!

  ; stack.froth
  'swap compile!
  'dup compile!
  'over compile!
  'drop compile!
  'nip compile!

  ; array.froth
  'foldl compile!
  'foldr compile!
  'reverse compile!
  'map compile!
  'filter compile!
  'reduce compile!
  'concat compile!
  'flatten compile!
  'scanl compile!
  'scanr compile!
  'contains compile!

  ; list.froth
  'lfoldl compile!
  'lfoldr compile!
  'lreverse compile!
  'lconcat compile!
  'lmap compile!

  ; map.froth
  'restrict compile!
  'transform-values compile!
  'merge compile!
  'delete-keys compile!
  'add-keys compile!

  ; bool.froth
  'not compile!
  'and compile!
  'or compile!

  ; math.froth
  'fib compile!
  'fact compile!

  ; data.froth
  'transform compile!

  ; alist.froth
  'alist-find compile!
  'alist-get compile!
  'alist-has compile!
  'alist-set compile!
  'alist-delete compile!
  'alist-keys compile!
  'alist-values compile!
  'alist-size compile!
  'alist-empty compile!

  ; tree23.froth
  'tree-empty compile!
  'tree-is-empty compile!
  'tree-get compile!
  'tree-has compile!
  'tree-set compile!
  'tree-size compile!
  'tree-keys compile!
  'tree-values compile!
  'tree-fold compile!

  ; bench.froth
  'bench compile!

  ; eval.froth - not compiled (meta-interpreter assumes closurevals)

  ; bytecode.froth
  'emit-at compile!
  'emit-all-at compile!

  ; disasm.froth
  'disasm-one compile!
  'disasm compile!

restore /froth-bytecode-top /froth-code-map /froth-cache

{ froth-cache froth-code-map froth-bytecode-top } /compiler-start
