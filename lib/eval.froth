; lib/eval.froth
; Meta-interpreter for Froth

; eval-binary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles binary operators (2 args)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /b  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /a  s1 snd /s2
      s2 [ a b op! ] {,} foldl! sim-env 0
    } ?!
  } ?!
} /eval-binary-op

; eval-unary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles unary operators (1 arg)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /a  stack snd /s1
    s1 [ a op! ] {,} foldl! sim-env 0
  } ?!
} /eval-unary-op

; eval-nullary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles nullary operators (0 args)
{ /op /sim-env /stack
  stack [ op! ] {,} foldl! sim-env 0
} /eval-nullary-op

; eval-ternary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles ternary operators (3 args)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /c  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /b  s1 snd /s2
      s2 isNil { "stack underflow" 1 } {
        s2 fst /a  s2 snd /s3
        s3 [ a b c op! ] {,} foldl! sim-env 0
      } ?!
    } ?!
  } ?!
} /eval-ternary-op

; eval-operator: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Dispatches to the appropriate handler based on operator arity
{ /op /sim-env /stack
  op arity /ar
  ar 0 = { stack sim-env op eval-nullary-op! } {
  ar 1 = { stack sim-env op eval-unary-op! } {
  ar 2 = { stack sim-env op eval-binary-op! } {
  stack sim-env op eval-ternary-op!
  } ?! } ?! } ?!
} /eval-operator

; eval-binder: (stack sim-env term -- new-stack new-env 0 | error-message 1)
{ /term /sim-env /stack
  stack isNil {
    "stack underflow in binder" 1
  } {
    stack fst /val
    stack snd /new-stack
    term intern idToIdent /ident
    sim-env val ident : /new-env
    new-stack new-env 0
  } ?!
} /eval-binder

; eval-apply: (stack sim-env op-table recurse -- new-stack new-env 0 | error-message 1)
{ /recurse /op-table /sim-env /stack
  stack isNil {
    "stack underflow in !" 1
  } {
    stack fst /val
    stack snd /new-stack
    val isCons {
      ; Get closure's env and body
      val fst /cenv
      val snd /cbody
      cbody isFunc {
        ; Evaluate body with closure's env
        new-stack cenv op-table cbody 0 recurse recurse!
        /status
        status {
          ; Restore original sim-env (lexical scoping)
          sim-env 0
        } {
          1
        } ?!
      } {
        "type error: expected closure" 1
      } ?!
    } {
      ; Not a closure - check if it's a quoted operator
      val isIdent {
        op-table val in {
          ; Custom operator from op-table - apply closure inline
          op-table val @ /op-closure
          op-closure fst /cenv
          op-closure snd /cbody
          cbody isFunc {
            new-stack cenv op-table cbody 0 recurse recurse!
            /status
            status {
              sim-env 0
            } {
              1
            } ?!
          } {
            "type error: expected closure in op-table" 1
          } ?!
        } {
          val isOperator {
            new-stack sim-env val eval-operator!
          } {
            "undefined operator" 1
          } ?!
        } ?!
      } {
        "type error: expected closure or operator" 1
      } ?!
    } ?!
  } ?!
} /eval-apply

; eval-ident: (stack sim-env op-table term recurse -- new-stack new-env 0 | error-message 1)
; Lookup order: sim-env, op-table, special cases, built-in operators
{ /recurse /term /op-table /sim-env /stack
  sim-env term in {
    sim-env term @ /val
    stack val , sim-env 0
  } {
    op-table term in {
      ; Custom operator - apply the closure
      op-table term @ /op-closure
      stack op-closure , sim-env op-table recurse eval-apply!
    } {
    term 'env = {
      ; Special case: env returns simulated environment
      stack sim-env , sim-env 0
    } {
    term 'restore = {
      ; Special case: restore replaces simulated environment
      stack isNil { "stack underflow" 1 } {
        stack fst /new-env
        stack snd /new-stack
        new-env isMap {
          new-stack new-env 0
        } {
          "type error: expected map" 1
        } ?!
      } ?!
    } {
    term 'stack = {
      ; Special case: stack returns simulated stack as array
      [ stack {} lfoldr! ] /arr
      stack arr , sim-env 0
    } {
    term 'isOperator = {
      ; Special case: isOperator checks op-table first
      stack isNil { "stack underflow" 1 } {
        stack fst /arg  stack snd /s1
        op-table arg in {
          s1 0 , sim-env 0
        } {
          s1 [ arg isOperator ] {,} foldl! sim-env 0
        } ?!
      } ?!
    } {
    term isOperator {
      stack sim-env term eval-operator!
    } {
      "undefined name" 1
    } ?! } ?! } ?! } ?! } ?! } ?!
  } ?!
} /eval-ident

; eval-term: (stack sim-env op-table term recurse -- new-stack new-env 0 | error-message 1)
{ /recurse /term /op-table /sim-env /stack
  term isIdent {
    stack sim-env op-table term recurse eval-ident!
  } {
  term isBinder {
    stack sim-env term eval-binder!
  } {
  term isFunc {
    ; Create closure as (env, body) - same as native Froth
    term sim-env , /new-closure
    stack new-closure , sim-env 0
  } {
  term isGen {
    ; Generator - evaluate with empty stack, collect results into array
    . sim-env op-table term 0 recurse recurse!
    /status
    status {
      ; Success - convert result stack to array (lfoldr for correct order)
      /gen-stack
      [ gen-stack {} lfoldr! ] /arr
      stack arr , sim-env 0
    } {
      ; Error - propagate
      1
    } ?!
  } {
  term isApply {
    stack sim-env op-table recurse eval-apply!
  } {
  term isQuote {
    ; Quoted term - push the inner term without evaluating
    stack term unwrap , sim-env 0
  } {
  term isValue {
    ; Value term - unwrap and push the inner value
    stack term unwrap , sim-env 0
  } {
    ; Unknown term type - push as-is
    stack term , sim-env 0
  } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} /eval-term

; eval-terms-impl: (stack sim-env op-table body idx self -- result-stack 0 | error-message 1)
; self is passed for recursion
{ /self /idx /body /op-table /sim-env /stack
  idx body # = {
    ; Done - return stack with success
    stack 0
  } {
    ; Evaluate one term
    body idx @ /term
    stack sim-env op-table term self eval-term!
    ; Check result - stack now has (status, maybe-env, maybe-stack)
    /status
    status {
      ; Success - get new-env and new-stack, then recurse
      /result-env /result-stack
      result-stack result-env op-table body idx 1 + self self!
    } {
      ; Error - just push 1 (error message already on stack)
      1
    } ?!
  } ?!
} /eval-terms-impl

; eval-terms: (stack sim-env op-table body idx -- result-stack 0 | error-message 1)
{ /idx /body /op-table /sim-env /stack
  stack sim-env op-table body idx eval-terms-impl eval-terms-impl!
} /eval-terms

; eval: (init-stack op-table closure -- result-stack 0 | error-message 1)
{ /closure /op-table /stack
  closure fst /sim-env
  closure snd /body
  body isFunc {
    stack sim-env op-table body 0 eval-terms!
  } {
    "eval: expected closure" 1
  } ?!
} /eval
