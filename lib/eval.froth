; lib/eval.froth
; Meta-interpreter for Froth

; eval-binary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles binary operators (2 args)
['foldl] { /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /b  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /a  s1 snd /s2
      s2 [ a b op applyOperator ] {,} foldl! sim-env 0
    } ?!
  } ?!
} def-fn! /eval-binary-op

; eval-unary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles unary operators (1 arg)
['foldl] { /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /a  stack snd /s1
    s1 [ a op applyOperator ] {,} foldl! sim-env 0
  } ?!
} def-fn! /eval-unary-op

; eval-nullary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles nullary operators (0 args)
['foldl] { /op /sim-env /stack
  stack [ op applyOperator ] {,} foldl! sim-env 0
} def-fn! /eval-nullary-op

; eval-ternary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles ternary operators (3 args)
['foldl] { /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /c  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /b  s1 snd /s2
      s2 isNil { "stack underflow" 1 } {
        s2 fst /a  s2 snd /s3
        s3 [ a b c op applyOperator ] {,} foldl! sim-env 0
      } ?!
    } ?!
  } ?!
} def-fn! /eval-ternary-op

; eval-operator: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Dispatches to the appropriate handler based on operator arity
['eval-nullary-op 'eval-unary-op 'eval-binary-op 'eval-ternary-op] { /op /sim-env /stack
  op arity /ar
  ar 0 = { stack sim-env op eval-nullary-op! } {
  ar 1 = { stack sim-env op eval-unary-op! } {
  ar 2 = { stack sim-env op eval-binary-op! } {
  stack sim-env op eval-ternary-op!
  } ?! } ?! } ?!
} def-fn! /eval-operator

; eval-binder: (stack sim-env term -- new-stack new-env 0 | error-message 1)
[] { /term /sim-env /stack
  stack isNil {
    "stack underflow in binder" 1
  } {
    stack fst /val
    stack snd /new-stack
    term intern idToIdent /ident
    sim-env val ident : /new-env
    new-stack new-env 0
  } ?!
} def-fn! /eval-binder

; eval-apply: (stack sim-env op-table recurse -- new-stack new-env 0 | error-message 1)
; Note: ! only applies closures. Use applyOperator for quoted operators.
[] { /recurse /op-table /sim-env /stack
  stack isNil {
    "stack underflow in !" 1
  } {
    stack fst /val
    stack snd /new-stack
    val isClosure {
      ; Get closure's env and body
      val closureEnv /cenv
      val closureBody /cbody
      cbody isFunc {
        ; Evaluate body with closure's env
        new-stack cenv op-table cbody 0 recurse recurse!
        /status
        status {
          ; Restore original sim-env (lexical scoping)
          sim-env 0
        } {
          1
        } ?!
      } {
        "type error: expected closure" 1
      } ?!
    } {
      "type error: expected closure" 1
    } ?!
  } ?!
} def-fn! /eval-apply

; eval-ident: (stack sim-env op-table term recurse -- new-stack new-env 0 | error-message 1)
; Lookup order: sim-env, op-table, special cases, built-in operators
['lfoldr 'foldl 'eval-operator 'eval-apply] { /recurse /term /op-table /sim-env /stack
  sim-env term in {
    sim-env term @ /val
    stack val , sim-env 0
  } {
    op-table term in {
      ; Custom operator - apply the closure
      op-table term @ /op-closure
      stack op-closure , sim-env op-table recurse eval-apply!
    } {
    term 'env = {
      ; Special case: env returns simulated environment
      stack sim-env , sim-env 0
    } {
    term 'restore = {
      ; Special case: restore replaces simulated environment
      stack isNil { "stack underflow" 1 } {
        stack fst /new-env
        stack snd /new-stack
        new-env isMap {
          new-stack new-env 0
        } {
          "type error: expected map" 1
        } ?!
      } ?!
    } {
    term 'stack = {
      ; Special case: stack returns simulated stack as array
      [ stack {} lfoldr! ] /arr
      stack arr , sim-env 0
    } {
    term 'isOperator = {
      ; Special case: isOperator checks op-table first
      stack isNil { "stack underflow" 1 } {
        stack fst /arg  stack snd /s1
        op-table arg in {
          s1 0 , sim-env 0
        } {
          s1 [ arg isOperator ] {,} foldl! sim-env 0
        } ?!
      } ?!
    } {
    term 'applyOperator = {
      ; Special case: applyOperator applies a quoted operator
      stack isNil { "stack underflow in applyOperator" 1 } {
        stack fst /op-term  stack snd /s1
        op-term isIdent {
          op-table op-term in {
            ; Custom operator from op-table - apply the closure
            op-table op-term @ /op-closure
            s1 op-closure , sim-env op-table recurse eval-apply!
          } {
            op-term isOperator {
              s1 sim-env op-term eval-operator!
            } {
              "undefined operator" 1
            } ?!
          } ?!
        } {
          "type error: expected quoted operator" 1
        } ?!
      } ?!
    } {
    term isOperator {
      stack sim-env term eval-operator!
    } {
      "undefined name" 1
    } ?! } ?! } ?! } ?! } ?! } ?! } ?!
  } ?!
} def-fn! /eval-ident

; eval-term: (stack sim-env op-table term recurse -- new-stack new-env 0 | error-message 1)
['lfoldr 'eval-ident 'eval-binder 'eval-apply] { /recurse /term /op-table /sim-env /stack
  term isIdent {
    stack sim-env op-table term recurse eval-ident!
  } {
  term isBinder {
    stack sim-env term eval-binder!
  } {
  term isFunc {
    ; Create closure with close operator - same as native Froth
    sim-env term close /new-closure
    stack new-closure , sim-env 0
  } {
  term isGen {
    ; Generator - evaluate with empty stack, collect results into array
    . sim-env op-table term 0 recurse recurse!
    /status
    status {
      ; Success - convert result stack to array (lfoldr for correct order)
      /gen-stack
      [ gen-stack {} lfoldr! ] /arr
      stack arr , sim-env 0
    } {
      ; Error - propagate
      1
    } ?!
  } {
  term isApply {
    stack sim-env op-table recurse eval-apply!
  } {
  term isQuote {
    ; Quoted term - push the inner term without evaluating
    stack term unwrap , sim-env 0
  } {
  term isValue {
    ; Value term - unwrap and push the inner value
    stack term unwrap , sim-env 0
  } {
    ; Unknown term type - push as-is
    stack term , sim-env 0
  } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /eval-term

; eval-terms-impl: (stack sim-env op-table body idx self -- result-stack 0 | error-message 1)
; self is passed for recursion
['eval-term] { /self /idx /body /op-table /sim-env /stack
  idx body # = {
    ; Done - return stack with success
    stack 0
  } {
    ; Evaluate one term
    body idx @ /term
    stack sim-env op-table term self eval-term!
    ; Check result - stack now has (status, maybe-env, maybe-stack)
    /status
    status {
      ; Success - get new-env and new-stack, then recurse
      /result-env /result-stack
      result-stack result-env op-table body idx 1 + self self!
    } {
      ; Error - just push 1 (error message already on stack)
      1
    } ?!
  } ?!
} def-fn! /eval-terms-impl

; eval-terms: (stack sim-env op-table body idx -- result-stack 0 | error-message 1)
['eval-terms-impl] { /idx /body /op-table /sim-env /stack
  stack sim-env op-table body idx eval-terms-impl eval-terms-impl!
} def-fn! /eval-terms

; eval: (init-stack op-table closure -- result-stack 0 | error-message 1)
['eval-terms] { /closure /op-table /stack
  closure isClosure {
    closure closureEnv /sim-env
    closure closureBody /body
    stack sim-env op-table body 0 eval-terms!
  } {
    "eval: expected closure" 1
  } ?!
} def-fn! /eval

; Remove impl functions from the environment
env 'eval-binary-op delete 'eval-unary-op delete 'eval-nullary-op delete
    'eval-ternary-op delete 'eval-operator delete 'eval-binder delete
    'eval-apply delete 'eval-ident delete 'eval-term delete
    'eval-terms-impl delete restore
