; lib/eval.froth
; Meta-interpreter for Froth

; eval-binary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles binary operators (2 args)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /b  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /a  s1 snd /s2
      s2 [ a b op! ] {,} foldl! sim-env 0
    } ?!
  } ?!
} /eval-binary-op

; eval-unary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles unary operators (1 arg)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /a  stack snd /s1
    s1 [ a op! ] {,} foldl! sim-env 0
  } ?!
} /eval-unary-op

; eval-nullary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles nullary operators (0 args)
{ /op /sim-env /stack
  stack [ op! ] {,} foldl! sim-env 0
} /eval-nullary-op

; eval-ternary-op: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Handles ternary operators (3 args)
{ /op /sim-env /stack
  stack isNil { "stack underflow" 1 } {
    stack fst /c  stack snd /s1
    s1 isNil { "stack underflow" 1 } {
      s1 fst /b  s1 snd /s2
      s2 isNil { "stack underflow" 1 } {
        s2 fst /a  s2 snd /s3
        s3 [ a b c op! ] {,} foldl! sim-env 0
      } ?!
    } ?!
  } ?!
} /eval-ternary-op

; eval-operator: (stack sim-env op -- new-stack new-env 0 | error-message 1)
; Dispatches to the appropriate handler based on operator arity
{ /op /sim-env /stack
  op arity /ar
  ar 0 = { stack sim-env op eval-nullary-op! } {
  ar 1 = { stack sim-env op eval-unary-op! } {
  ar 2 = { stack sim-env op eval-binary-op! } {
  stack sim-env op eval-ternary-op!
  } ?! } ?! } ?!
} /eval-operator

; eval-binder: (stack sim-env term -- new-stack new-env 0 | error-message 1)
{ /term /sim-env /stack
  stack isNil {
    "stack underflow in binder" 1
  } {
    stack fst /val
    stack snd /new-stack
    term intern idToIdent /ident
    sim-env val ident : /new-env
    new-stack new-env 0
  } ?!
} /eval-binder

; eval-ident: (stack sim-env term -- new-stack new-env 0 | error-message 1)
; Environment shadows operators
{ /term /sim-env /stack
  sim-env term in {
    sim-env term @ /val
    stack val , sim-env 0
  } {
    term isOperator {
      stack sim-env term eval-operator!
    } {
      "undefined name" 1
    } ?!
  } ?!
} /eval-ident

; eval-apply: (stack sim-env recurse -- new-stack new-env 0 | error-message 1)
{ /recurse /sim-env /stack
  stack isNil {
    "stack underflow in !" 1
  } {
    stack fst /closure
    stack snd /new-stack
    closure isCons {
      ; Get closure's env and body
      closure fst /cenv
      closure snd /cbody
      cbody isFunc {
        ; Evaluate body with closure's env
        new-stack cenv cbody 0 recurse recurse!
        /status
        status {
          ; Restore original sim-env (lexical scoping)
          sim-env 0
        } {
          1
        } ?!
      } {
        "type error: expected closure" 1
      } ?!
    } {
      "type error: expected closure" 1
    } ?!
  } ?!
} /eval-apply

; eval-term: (stack sim-env term recurse -- new-stack new-env 0 | error-message 1)
{ /recurse /term /sim-env /stack
  term isIdent {
    stack sim-env term eval-ident!
  } {
  term isBinder {
    stack sim-env term eval-binder!
  } {
  term isFunc {
    ; Create closure as (env, body) - same as native Froth
    term sim-env , /new-closure
    stack new-closure , sim-env 0
  } {
  term isApply {
    stack sim-env recurse eval-apply!
  } {
  term isValue {
    ; Value term - unwrap and push the inner value
    stack term unwrap , sim-env 0
  } {
    ; Unknown term type - push as-is
    stack term , sim-env 0
  } ?! } ?! } ?! } ?! } ?!
} /eval-term

; eval-terms-impl: (stack sim-env body idx self -- result-stack 0 | error-message 1)
; self is passed for recursion
{ /self /idx /body /sim-env /stack
  idx body # = {
    ; Done - return stack with success
    stack 0
  } {
    ; Evaluate one term
    body idx @ /term
    stack sim-env term self eval-term!
    ; Check result - stack now has (status, maybe-env, maybe-stack)
    /status
    status {
      ; Success - get new-env and new-stack, then recurse
      /result-env /result-stack
      result-stack result-env body idx 1 + self self!
    } {
      ; Error - just push 1 (error message already on stack)
      1
    } ?!
  } ?!
} /eval-terms-impl

; eval-terms: (stack sim-env body idx -- result-stack 0 | error-message 1)
{ /idx /body /sim-env /stack
  stack sim-env body idx eval-terms-impl eval-terms-impl!
} /eval-terms

; eval: (init-stack closure -- result-stack 0 | error-message 1)
{ /closure /stack
  closure fst /sim-env
  closure snd /body
  body isFunc {
    stack sim-env body 0 eval-terms!
  } {
    "eval: expected closure" 1
  } ?!
} /eval
