; boundness.froth - Boundness analysis for compiler

; boundness-term-impl: (node bound acc-free-map acc-free-list seq-fn term-fn -- result-node term-bound-set updated-bound new-acc-free-map new-acc-free-list)
; Analyze a single node for boundness.
; result-node: input node with boundness info added
; term-bound-set: map (set) of bound identifiers (binders) found in this term
; For closures: don't recurse (already analyzed by compile-func), just propagate free vars
; For generators: recurse with current bound set (bindings don't escape)
; acc-free-map accumulates free variables with context slot numbers (slot = map size)
; acc-free-list accumulates free variable identifiers in reverse slot order
['foldl] { /term-fn /seq-fn /acc-free-list /acc-free-map /bound /node
  node 'term @ /term
  term isIdent {
    ; Identifier: check if bound
    bound term in {
      ; Bound identifier: is-bound=0 (default from make-node)
      node $ bound acc-free-map acc-free-list
    } {
      ; Not bound - check if it's an operator (no slot needed)
      term isOperator {
        ; Operator: mark as operator, looked up in operator-table at runtime
        node 0 'is-operator : $ bound acc-free-map acc-free-list
      } {
        ; Free identifier - check if already seen
        acc-free-map term in {
          ; Already seen free var
          node 1 'is-bound : acc-free-map term @ 'slot :
          $ bound acc-free-map acc-free-list
        } {
          ; New free var: assign slot (slot number = current map size)
          acc-free-map # /slot
          node 1 'is-bound : slot 'slot :
          $ bound acc-free-map slot term : acc-free-list term ,
        } ?!
      } ?!
    } ?!
  } {
  term isBinder {
    ; Binder: add to bound set with nil value
    term intern idToIdent /ident
    bound . ident : /new-bound
    node $ . ident : new-bound acc-free-map acc-free-list
  } {
  term isFunc {
    ; Closure: already analyzed by compile-func, just propagate free vars
    ; Node already has 'body, 'free-vars-map, 'free-vars-array, 'bound-set
    node 'free-vars-map @ /inner-free-set
    ; Update outer's acc-free-map/list with inner's free variables that aren't bound in outer
    acc-free-map acc-free-list inner-free-set keys { /v /lst /acc
      bound v in {
        acc lst  ; v is bound in outer scope
      } {
        acc v in {
          acc lst  ; already in outer's free-set
        } {
          acc acc # v : lst v ,  ; new free var for outer (slot = map size)
        } ?!
      } ?!
    } foldl! /new-acc-free-list /new-acc-free-map
    node $ bound new-acc-free-map new-acc-free-list
  } {
  term isGen {
    ; Generator: shares outer scope's free variable tracking
    ; Recurse into node's body (array of child nodes)
    node 'body @ bound 0 acc-free-map acc-free-list seq-fn term-fn seq-fn! /new-acc-free-list /inner-body /inner-bound-set /new-acc-free-map
    ; Update node with new body and bound-set
    node inner-body 'body : inner-bound-set 'bound-set :
    $ bound new-acc-free-map new-acc-free-list
  } {
  term isQuote {
    ; Quoted term
    node $ bound acc-free-map acc-free-list
  } {
    ; Literal, apply, value
    node $ bound acc-free-map acc-free-list
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /boundness-term-impl

; boundness-seq-impl: (body-nodes bound idx acc-free-map acc-free-list seq-fn term-fn -- free-set bound-set body-list free-list)
; Analyze a sequence of nodes for boundness.
; Returns free-set (map with slots), bound-set (map with nil), body list of node maps, and free-list.
; Converts body list to array at idx=0.
['foldl 'lfoldl] { /term-fn /seq-fn /acc-free-list /acc-free-map /idx /bound /body-nodes
  idx body-nodes # = {
    ; Done: return accumulated free-set, empty bound-set, empty body list, free-list
    acc-free-map $ . acc-free-list
  } {
    ; Process current node
    body-nodes idx @ /node
    node bound acc-free-map acc-free-list seq-fn term-fn term-fn! /new-acc-free-list /new-acc-free-map /new-bound /term-bound-set /result-node
    ; Recurse for rest of sequence (with updated state)
    body-nodes new-bound idx 1 + new-acc-free-map new-acc-free-list seq-fn term-fn seq-fn! /rest-free-list /rest-body /rest-bound-set /rest-free-set
    ; Combine results: free-set is already accumulated, merge bound-sets with nil
    rest-free-set
    rest-bound-set term-bound-set keys { /k . k : } foldl!
    rest-body result-node ,  ; cons node onto rest (building list)
    rest-free-list
  } ?!
  ; Convert body list to array at top level (idx=0)
  idx 0 = {
    /free-list /body-list
    [ body-list { } lfoldl! ]
    free-list
  } { } ?!
} def-fn! /boundness-seq-impl

; boundness: (func-node -- func-node)
; Analyze a function node for boundness of each term.
; Takes a func-node from compile-func (with 'term and 'body).
; Returns updated func-node with:
;   'term: the original function
;   'body: array of node maps parallel to function body (updated with boundness info)
;   'free-vars-map: map from identifiers to context slot numbers
;   'free-vars-array: array of identifiers indexed by context slot
;   'bound-set: map from identifiers to nil (marking presence)
; Each node map contains keys appropriate to the term type (see node.froth).
['boundness-seq-impl 'boundness-term-impl 'lreverse 'lfoldl] { /func-node
  func-node 'body @ $ 0 $ . boundness-seq-impl boundness-term-impl boundness-seq-impl!
  /free-list /body /bound-set /free-set
  ; Convert free-list to array (reverse to get slot order, then collect into array)
  [ free-list lreverse! { } lfoldl! ] /free-array
  func-node body 'body : free-set 'free-vars-map : free-array 'free-vars-array : bound-set 'bound-set :
} def-fn! /boundness

; Remove impl functions from the environment
env 'boundness-term-impl delete 'boundness-seq-impl delete restore
