; node.froth - Compiler node constructors
;
; Compiler passes (boundness, liveness, slots) produce a parallel structure
; of maps corresponding to each term in the input function. This module
; provides constructors for each node type.
;
; VALUE CONVENTIONS
; -----------------
; - Keys use 0 for "yes/true" and 1 for "no/false" (Froth! convention)
; - Defaults are set to the common case; passes only write when different
; - Absent keys (nil) indicate the property doesn't apply or isn't set
; - Maps used as sets have nil (.) as values
; - 'body arrays are parallel to the function body terms

; new-node: (term -- node)
; Base constructor storing the term.
[] { /term $ term 'term : } def-fn! /new-node

; new-literal-node: (term -- literal-node)
; Create a literal node (numbers, strings).
; No additional keys needed.
['new-node] { /term term new-node! } def-fn! /new-literal-node

; new-quote-node: (term -- quote-node)
; Create a quote node ('symbol, 'expr).
; No additional keys needed.
['new-node] { /term term new-node! } def-fn! /new-quote-node

; new-identifier-node: (term -- identifier-node)
; Create an identifier node with default values.
;
; Keys:
;   'is-operator (boundness) 0 = operator (not tracked), 1 = variable
;   'is-bound    (boundness) 0 = bound variable, 1 = free variable
;   'is-live     (liveness)  0 = still live after this point, 1 = last reference
;   'slot        (boundness) context slot number if free variable
;                (slots)     frame slot number if bound variable
;   'leave-frame (liveness) 0 = last term using the frame
['new-node] { /term term new-node!
  1 'is-operator :
  0 'is-bound :
  0 'is-live :
  . 'slot :
  1 'leave-frame :
} def-fn! /new-identifier-node

; new-binder-node: (term -- binder-node)
; Create a binder node with default values.
;
; Keys:
;   'is-used  (liveness) 0 = used somewhere, 1 = dead (never referenced)
;   'slot     (slots)    frame slot number (only set if used)
['new-node] { /term term new-node!
  0 'is-used :
  . 'slot :
} def-fn! /new-binder-node

; new-apply-node: (term -- apply-node)
; Create an apply node with default values.
;
; Keys:
;   'is-tail-call    (liveness) 0 = tail call, 1 = non-tail call
;   'restore-context (liveness) 0 = non-tail call needing context restore after
;   'restore-return  (liveness) 0 = last non-tail call (needs return restore)
;   'leave-frame     (liveness) 0 = last term using the frame
;   'save-context    (slots)    0 = save context pointer before this call
;   'save-return     (slots)    0 = save return pointer before this call
;   'ctx-save-slot   (slots)    frame slot for saving context pointer
;   'rp-save-slot    (slots)    frame slot for saving return pointer
['new-node] { /term term new-node!
  1 'is-tail-call :
  1 'restore-context :
  1 'restore-return :
  1 'leave-frame :
  1 'save-context :
  1 'save-return :
  . 'ctx-save-slot :
  . 'rp-save-slot :
} def-fn! /new-apply-node

; new-function-node: (term -- function-node)
; Create a function node with default values.
;
; Keys:
;   'body            (boundness) array of node maps (parallel to body terms)
;   'free-vars-map       (boundness) map: identifier -> context slot number
;   'free-vars-array (boundness) array: slot index -> identifier
;   'bound-set       (boundness) map: identifier -> nil (set of bound vars)
;   'dead-set        (liveness)  map: identifier -> nil (vars whose last use is capture)
;   'max-slots       (slots)     maximum frame slots needed
;   'needs-frame     (liveness)  0 = function needs a frame
['new-node] { /term term new-node!
  [] 'body :
  $ 'free-vars-map :
  [] 'free-vars-array :
  $ 'bound-set :
  $ 'dead-set :
  0 'max-slots :
  1 'needs-frame :
} def-fn! /new-function-node

; new-generator-node: (term -- generator-node)
; Create a generator node with default values.
; Generators share the containing function's frame and context.
;
; Keys:
;   'body            (boundness) array of node maps (parallel to body terms)
;   'bound-set       (boundness) map: identifier -> nil (set of bound vars)
['new-node] { /term term new-node!
  [] 'body :
  $ 'bound-set :
} def-fn! /new-generator-node

; make-node: (term -- node)
; Create the appropriate node type based on the term.
['new-literal-node 'new-identifier-node 'new-binder-node
 'new-function-node 'new-generator-node 'new-quote-node 'new-apply-node] {
  /term
  term isIdent { term new-identifier-node! } {
  term isBinder { term new-binder-node! } {
  term isFunc { term new-function-node! } {
  term isGen { term new-generator-node! } {
  term isQuote { term new-quote-node! } {
  term isApply { term new-apply-node! } {
    ; Literal (int, string) or quoted value
    term new-literal-node!
  } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /make-node
