; node.froth - Compiler node constructors
; Compiler node constructors
;
; Compiler passes (boundness, liveness, slots) produce a parallel structure
; of maps corresponding to each term in the input function. This module
; provides constructors for each node type.
;
; VALUE CONVENTIONS
; -----------------
; - Keys use 0 for "yes/true" and 1 for "no/false" (Froth convention)
; - Defaults are set to the common case; passes only write when different
; - Absent keys (nil) indicate the property doesn't apply or isn't set
; - Maps used as sets have nil (.) as values
; - 'body arrays are parallel to the function body terms

; new-node: ( -- node )
; Base constructor returning an empty map.
{ $ } /new-node

; new-literal-node: ( -- literal-node )
; Create a literal node (numbers, strings).
; No additional keys needed.
{ new-node! } /new-literal-node

; new-quote-node: ( -- quote-node )
; Create a quote node ('symbol, 'expr).
; No additional keys needed.
{ new-node! } /new-quote-node

; new-identifier-node: ( -- identifier-node )
; Create an identifier node with default values.
;
; Keys:
;   'is-bound  (boundness) 0 = bound variable, 1 = free variable
;   'is-live   (liveness)  0 = still live after this point, 1 = last reference
;   'slot      (boundness) context slot number if free variable
;              (slots)     frame slot number if bound variable
;   'leave-frame (liveness) 0 = last term using the frame
{ new-node!
  0 'is-bound :
  0 'is-live :
  . 'slot :
  1 'leave-frame :
} /new-identifier-node

; new-binder-node: ( -- binder-node )
; Create a binder node with default values.
;
; Keys:
;   'is-used  (liveness) 0 = used somewhere, 1 = dead (never referenced)
;   'slot     (slots)    frame slot number (only set if used)
{ new-node!
  0 'is-used :
  . 'slot :
} /new-binder-node

; new-apply-node: ( -- apply-node )
; Create an apply node with default values.
;
; Keys:
;   'is-tail-call    (liveness) 0 = tail call, 1 = non-tail call
;   'restore-context (liveness) 0 = non-tail call needing context restore after
;   'restore-return  (liveness) 0 = last non-tail call (needs return restore)
;   'leave-frame     (liveness) 0 = last term using the frame
;   'ctx-save-slot   (slots)    frame slot for saving context pointer
;   'rp-save-slot    (slots)    frame slot for saving return pointer
{ new-node!
  1 'is-tail-call :
  1 'restore-context :
  1 'restore-return :
  1 'leave-frame :
  . 'ctx-save-slot :
  . 'rp-save-slot :
} /new-apply-node

; new-function-node: (-- function-node)
; Create a function node with default values.
;
; Keys:
;   'body       (boundness) array of node maps (parallel to body terms)
;   'free-vars  (boundness) map: identifier -> context slot number
;   'bound-set  (boundness) map: identifier -> nil (set of bound vars)
;   'dead-set   (liveness)  map: identifier -> nil (vars whose last use is capture)
;   'max-slots  (slots)     maximum frame slots needed
;   'needs-frame (liveness) 0 = function needs a frame
{ new-node!
  [] 'body :
  $ 'free-vars :
  $ 'bound-set :
  $ 'dead-set :
  0 'max-slots :
  1 'needs-frame :
} /new-function-node

; new-generator-node: ( -- generator-node )
; Create a generator node with default values.
; Generators share the containing function's frame.
;
; Keys:
;   'body       (boundness) array of node maps (parallel to body terms)
;   'free-vars  (boundness) map: identifier -> context slot number
;   'bound-set  (boundness) map: identifier -> nil (set of bound vars)
{ new-node!
  [] 'body :
  $ 'free-vars :
  $ 'bound-set :
} /new-generator-node
