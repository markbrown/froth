; lib/analysis.froth
; Code analysis utilities for Froth

; free-vars-term-impl: (term bound seq-fn term-fn -- fvs flag updated-bound)
; Analyze a single term for free variables.
; bound: map of locally bound identifiers
; seq-fn: function for analyzing sequences (for mutual recursion)
; term-fn: this function itself (for self-recursion)
; Returns: fvs (array), flag (0=safe, 1=uses env/import), updated-bound
[] { /term-fn /seq-fn /bound /term
  term isIdent {
    ; Check for env/import first (they break free-vars optimization)
    term 'env = { [] 1 bound } {
    term 'import = { [] 1 bound } {
      bound term in {
        ; Locally bound - not free
        [] 0 bound
      } {
        term isOperator {
          ; Operator - not a variable
          [] 0 bound
        } {
          ; Regular free variable
          [term] 0 bound
        } ?!
      } ?!
    } ?! } ?!
  } {
  term isBinder {
    ; Add to bound set
    term intern idToIdent /ident
    bound 0 ident : /new-bound
    [] 0 new-bound
  } {
  term isFunc {
    ; Analyze nested function, passing outer bound set
    term bound 0 seq-fn term-fn seq-fn! /flag
    flag bound
  } {
  term isGen {
    ; Same as function
    term bound 0 seq-fn term-fn seq-fn! /flag
    flag bound
  } {
  term isQuote {
    ; Quoted terms are data, not references - no free vars
    [] 0 bound
  } {
    ; Literal, apply, value - no free vars
    [] 0 bound
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /free-vars-term-impl

; free-vars-seq-impl: (body bound idx seq-fn term-fn -- fvs flag)
; Analyze a sequence of terms (function/generator body).
; Processes terms left-to-right, accumulating bindings.
['concat 'and] { /term-fn /seq-fn /idx /bound /body
  idx body # = {
    ; Done
    [] 0
  } {
    ; Process current term
    body idx @ /term
    term bound seq-fn term-fn term-fn! /new-bound /term-flag /term-fvs
    ; Recurse for rest of sequence
    body new-bound idx 1 + seq-fn term-fn seq-fn! /rest-flag /rest-fvs
    ; Combine results
    term-fvs rest-fvs concat!
    term-flag rest-flag and!
  } ?!
} def-fn! /free-vars-seq-impl

; free-vars: (term -- array 0 | 1)
; Get free identifiers in a term.
; Returns (array 0) if analysis succeeded, or 1 if env/import was found.
['free-vars-seq-impl 'free-vars-term-impl] { /term
  term isFunc {
    term $ 0 free-vars-seq-impl free-vars-term-impl free-vars-seq-impl!
    /flag /fvs
    flag { fvs 0 } { 1 } ?!
  } {
  term isGen {
    term $ 0 free-vars-seq-impl free-vars-term-impl free-vars-seq-impl!
    /flag /fvs
    flag { fvs 0 } { 1 } ?!
  } {
    ; Single term - analyze it directly
    term $ free-vars-seq-impl free-vars-term-impl free-vars-term-impl!
    /ignored /flag /fvs
    flag { fvs 0 } { 1 } ?!
  } ?! } ?!
} def-fn! /free-vars

; Remove impl functions from the environment
env 'free-vars-term-impl delete 'free-vars-seq-impl delete restore

; count-bindings-impl: (self data -- count)
; Implementation helper for counting bindings in closure environments.
; Only counts immediate environment sizes, not recursing into nested closures.
['foldl] { /self /data
  data isClosure {
    ; Just count this closure's env size (shallow)
    data closureEnv #
  } {
  data isMap {
    ; Sum counts for all values in map
    0 data keys { /key
      data key @ self self! +
    } foldl!
  } {
  data isArray {
    ; Sum counts for all elements
    0 data { self self! + } foldl!
  } {
  data isCons {
    ; Sum counts for head and tail
    data fst self self!
    data snd self self! +
  } {
    ; Leaf value - no bindings
    0
  } ?! } ?! } ?! } ?!
} def-fn! /count-bindings-impl

; count-bindings: (data -- count)
; Count total bindings in closure environments within a data structure.
; For each closure found, counts the size of its environment (shallow).
['count-bindings-impl] { /data
  data count-bindings-impl count-bindings-impl!
} def-fn! /count-bindings

; Remove count-bindings-impl from the environment
env 'count-bindings-impl delete restore
