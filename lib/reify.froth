; reify.froth - Pool reification for image serialization
;
; See FROTH_BYTECODE.md for design documentation.
;
; Generates bytecode that reconstructs the constant pool when executed.

; Cache instruction codes
instruction-table 'push-int @ /ocPushInt
instruction-table 'op @ /ocOp
instruction-table 'push-string @ /ocPushString
instruction-table 'start-array @ /ocStartArray
instruction-table 'end-array @ /ocEndArray
instruction-table 'push-quoted-apply @ /ocPushQuotedApply
instruction-table 'pop-unused @ /ocPopUnused

; Cache operator codes
operator-table '. @ /opNil
operator-table ', @ /opCons
operator-table '$ @ /opEmpty
operator-table ': @ /opStore
operator-table 'ref @ /opRef
operator-table 'deref @ /opDeref
operator-table 'idToIdent @ /opIdToIdent
operator-table 'idToBinder @ /opIdToBinder
operator-table 'mkFunc @ /opMkFunc
operator-table 'mkGen @ /opMkGen
operator-table 'wrap @ /opWrap
operator-table 'close @ /opClose

; emit-op: ( opcode addr -- next-addr )
; Emit an operator instruction
['emit-all-at 'ocOp]
{ /addr /opcode [ ocOp opcode ] addr emit-all-at! }
def-fn! /emit-op

; emit-push-int: ( n addr -- next-addr )
; Emit push-int instruction
['emit-all-at 'ocPushInt]
{ /addr /n [ ocPushInt n ] addr emit-all-at! }
def-fn! /emit-push-int

; emit-push-string: ( id addr -- next-addr )
; Emit push-string instruction (id is intern ID)
['emit-all-at 'ocPushString]
{ /addr /id [ ocPushString id ] addr emit-all-at! }
def-fn! /emit-push-string

;-----------------------------------------------------------------------
; reify-value: ( value addr -- next-addr )
; Emit code to push a value onto the stack.
; If value is in pool (ref >= 0), emit deref.
; If primitive (ref = -1), emit inline.

['emit-push-int 'emit-push-string 'emit-op 'opDeref 'opNil]
{ /self /addr /v
  v ref /idx
  idx 0 >= {
    ; Pooled value: emit push-int idx, op deref
    idx addr emit-push-int! /addr
    opDeref addr emit-op!
  } {
    ; Primitive: emit inline
    v isInt 0 = {
      v addr emit-push-int!
    } {
    v isString 0 = {
      v intern addr emit-push-string!
    } {
    v isNil 0 = {
      opNil addr emit-op!
    } {
      ; Should not happen - only primitives return -1
      "reify-value: unexpected value type\n" print
      addr
    } ?! } ?! } ?!
  } ?!
} def-fn! /reify-value-impl

['reify-value-impl] { /addr /v v addr reify-value-impl reify-value-impl! } def-fn! /reify-value

;-----------------------------------------------------------------------
; reify-cons: ( cons addr -- next-addr )
; Emit code to construct a cons cell.

['reify-value 'emit-op 'opCons]
{ /self /addr /c
  ; Tail first (bottom of stack)
  c snd addr reify-value! /addr
  ; Then head
  c fst addr reify-value! /addr
  ; Emit comma operator
  opCons addr emit-op!
} def-fn! /reify-cons-impl

['reify-cons-impl]
{ /addr /c c addr reify-cons-impl reify-cons-impl! }
def-fn! /reify-cons

;-----------------------------------------------------------------------
; reify-array: ( array addr -- next-addr )
; Emit code to construct an array.

['reify-value 'emit-all-at 'ocStartArray 'ocEndArray 'times-loop]
{ /self /addr /arr
  ; Emit start-array
  [ ocStartArray ] addr emit-all-at! /addr
  ; Emit each element (state is [i addr])
  [ 0 addr ]
  arr # { /state
    state 0 @ /i
    state 1 @ /addr
    arr i @ addr reify-value! /addr
    [ i 1 + addr ]
  } times-loop!
  1 @ /addr  ; extract final addr from state
  ; Emit end-array
  [ ocEndArray ] addr emit-all-at!
} def-fn! /reify-array-impl

['reify-array-impl]
{ /addr /arr arr addr reify-array-impl reify-array-impl! }
def-fn! /reify-array

;-----------------------------------------------------------------------
; reify-map: ( map addr -- next-addr )
; Emit code to construct a map.

['reify-value 'emit-op 'emit-push-int 'opEmpty 'opIdToIdent 'opStore 'reduce]
{ /self /addr /m
  ; Emit empty map operator
  opEmpty addr emit-op! /addr
  ; For each key-value pair (state is addr)
  ; reduce puts (acc elem) on stack, so bind in reverse: /k /addr
  m keys addr { /k /addr
    ; Emit value
    m k @ addr reify-value! /addr
    ; Emit push-int key-id, op idToIdent
    k intern addr emit-push-int! /addr
    opIdToIdent addr emit-op! /addr
    ; Emit store operator
    opStore addr emit-op!
  } reduce!
} def-fn! /reify-map-impl

['reify-map-impl]
{ /addr /m m addr reify-map-impl reify-map-impl! }
def-fn! /reify-map

;-----------------------------------------------------------------------
; reify-closure: ( bytecodeval addr -- next-addr )
; Emit code to construct a bytecodeval.

['emit-push-int 'emit-op 'opDeref 'opClose]
{ /self /addr /bv
  bv open /code-addr /ctx
  ; Context array is already pooled - get its index
  ctx ref /ctx-idx
  ; Emit: push-int ctx-idx, op deref
  ctx-idx addr emit-push-int! /addr
  opDeref addr emit-op! /addr
  ; Emit: push-int code-addr, op close
  code-addr addr emit-push-int! /addr
  opClose addr emit-op!
} def-fn! /reify-closure-impl

['reify-closure-impl]
{ /addr /bv bv addr reify-closure-impl reify-closure-impl! }
def-fn! /reify-closure

;-----------------------------------------------------------------------
; reify-term: ( term addr -- next-addr )
; Emit code to construct a term value.

['emit-push-int 'emit-push-string 'emit-all-at 'emit-op 'times-loop
 'opIdToIdent 'opIdToBinder 'opMkFunc 'opMkGen 'opWrap
 'ocStartArray 'ocEndArray 'ocPushQuotedApply]
{ /self /addr /t
  ; Dispatch by term type
  t isIdent 0 = {
    ; identifier: push-int id, op idToIdent
    t intern addr emit-push-int! /addr
    opIdToIdent addr emit-op!
  } {
  t isBinder 0 = {
    ; binder: push-int id, op idToBinder
    t intern addr emit-push-int! /addr
    opIdToBinder addr emit-op!
  } {
  t isApply 0 = {
    ; apply: push-quoted-apply
    [ ocPushQuotedApply ] addr emit-all-at!
  } {
  t isFunc 0 = {
    ; function: start-array, reify-term each, end-array, op mkFunc
    [ ocStartArray ] addr emit-all-at! /addr
    [ 0 addr ]
    t # { /state
      state 0 @ /i
      state 1 @ /addr
      t i @ addr self self! /addr
      [ i 1 + addr ]
    } times-loop!
    1 @ /addr
    [ ocEndArray ] addr emit-all-at! /addr
    opMkFunc addr emit-op!
  } {
  t isGen 0 = {
    ; generator: start-array, reify-term each, end-array, op mkGen
    [ ocStartArray ] addr emit-all-at! /addr
    [ 0 addr ]
    t # { /state
      state 0 @ /i
      state 1 @ /addr
      t i @ addr self self! /addr
      [ i 1 + addr ]
    } times-loop!
    1 @ /addr
    [ ocEndArray ] addr emit-all-at! /addr
    opMkGen addr emit-op!
  } {
  t isQuote 0 = {
    ; quoted: reify-term inner, op wrap
    t unwrap addr self self! /addr
    opWrap addr emit-op!
  } {
  t isValue 0 = {
    ; value: depends on inner type
    t unwrap /inner
    inner isInt 0 = {
      ; value(int): push-int n, op wrap
      inner addr emit-push-int! /addr
      opWrap addr emit-op!
    } {
      ; value(string): push-string id, op wrap
      inner intern addr emit-push-string! /addr
      opWrap addr emit-op!
    } ?!
  } {
    ; Unknown term type
    "reify-term: unknown term type\n" print
    addr
  } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /reify-term-impl

['reify-term-impl]
{ /addr /t t addr reify-term-impl reify-term-impl! }
def-fn! /reify-term

;-----------------------------------------------------------------------
; reify-pool: ( addr idx -- next-addr )
; Generate bytecode to reconstruct the constant pool from index idx.
; Iterates through pool entries until deref returns nil.

['reify-cons 'reify-array 'reify-map 'reify-closure 'reify-term
 'emit-op 'emit-all-at 'opRef 'ocPopUnused]
{ /self /idx /addr
  idx deref /v
  v isNil 0 = {
    ; End of pool
    addr
  } {
    ; Dispatch by value type
    v isCons 0 = { v addr reify-cons! } {
    v isArray 0 = { v addr reify-array! } {
    v isMap 0 = { v addr reify-map! } {
    v isClosure 0 = { v addr reify-closure! } {
      ; Must be termval
      v addr reify-term!
    } ?! } ?! } ?! } ?! /addr
    ; Emit ref, pop-unused (store in pool and discard)
    opRef addr emit-op! /addr
    [ ocPopUnused ] addr emit-all-at! /addr
    ; Recurse with next index
    addr idx 1 + self self!
  } ?!
} def-fn! /reify-pool-impl

['reify-pool-impl]
{ /idx /addr addr idx reify-pool-impl reify-pool-impl! }
def-fn! /reify-pool

