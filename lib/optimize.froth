; lib/optimize.froth
; Closure optimization utilities

; restrict-closure-env: (closure -- closure 0 | 1)
; Restrict a closure's environment to only the free variables in its body.
; Returns (optimized-closure 0) on success, or 1 if preflight failed.
['preflight 'boundness 'restrict] { /closure
  closure open /body /env        ; get env and body
  body preflight! {
    ; Safe - get free variables from boundness
    body boundness! /bnd-map /func
    bnd-map 'free-vars @ /fvs
    env fvs keys restrict! body close  ; rebuild closure with close
    0                             ; success
  } {
    ; Preflight failed (env or import found)
    1
  } ?!
} def-fn! /restrict-closure-env

; optimize-impl: (self data -- optimized-data)
; Implementation helper that takes self for recursion.
['transform 'restrict-closure-env] { /self /data
  data { /val
    val isClosure {
      val restrict-closure-env! {
        ; Success (0 = truthy) - got restricted closure
        /opt-closure
        ; Recursively optimize the environment
        opt-closure open /opt-body /opt-env
        opt-env self self! opt-body close
      } {
        ; Failed (1 = falsy) - return original
        val
      } ?!
    } {
      ; Not a closure - return unchanged
      val
    } ?!
  } transform!
} def-fn! /optimize-impl

; optimize: (data -- optimized-data)
; Recursively optimizes all closures in a data structure by:
; 1. Restricting each closure's environment to only free variables
; 2. Recursively optimizing the environment
['optimize-impl] { /data
  data optimize-impl optimize-impl!
} def-fn! /optimize

; Remove optimize-impl from the environment
env 'optimize-impl delete restore

; count-bindings-impl: (self data -- count)
; Implementation helper for counting bindings in closure environments.
; Only counts immediate environment sizes, not recursing into nested closures.
['foldl] { /self /data
  data isClosure {
    ; Just count this closure's env size (shallow)
    data open drop #
  } {
  data isMap {
    ; Sum counts for all values in map
    0 data keys { /key
      data key @ self self! +
    } foldl!
  } {
  data isArray {
    ; Sum counts for all elements
    0 data { self self! + } foldl!
  } {
  data isCons {
    ; Sum counts for head and tail
    data fst self self!
    data snd self self! +
  } {
    ; Leaf value - no bindings
    0
  } ?! } ?! } ?! } ?!
} def-fn! /count-bindings-impl

; count-bindings: (data -- count)
; Count total bindings in closure environments within a data structure.
; For each closure found, counts the size of its environment (shallow).
['count-bindings-impl] { /data
  data count-bindings-impl count-bindings-impl!
} def-fn! /count-bindings

; Remove count-bindings-impl from the environment
env 'count-bindings-impl delete restore
