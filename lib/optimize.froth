; lib/optimize.froth
; Closure optimization utilities

; restrict-closure-env: (closure -- closure 0 | 1)
; Restrict a closure's environment to only the free variables in its body.
; Returns (optimized-closure 0) on success, or 1 if free-vars failed.
['free-vars 'restrict] { /closure
  closure closureBody /body      ; get the function term
  body free-vars!                 ; get free variables
  { /fvs
    closure closureEnv /env      ; get the environment
    env fvs restrict! body close  ; rebuild closure with close
    0                             ; success
  } { 1 } ?!
} def-fn! /restrict-closure-env

; optimize-impl: (self data -- optimized-data)
; Implementation helper that takes self for recursion.
['transform 'restrict-closure-env] { /self /data
  data { /val
    val isClosure {
      val restrict-closure-env! {
        ; Success (0 = truthy) - got restricted closure
        /opt-closure
        ; Recursively optimize the environment
        opt-closure closureEnv self self! /opt-env
        ; Rebuild closure with optimized env
        opt-env opt-closure closureBody close
      } {
        ; Failed (1 = falsy) - return original
        val
      } ?!
    } {
      ; Not a closure - return unchanged
      val
    } ?!
  } transform!
} def-fn! /optimize-impl

; optimize: (data -- optimized-data)
; Recursively optimizes all closures in a data structure by:
; 1. Restricting each closure's environment to only free variables
; 2. Recursively optimizing the environment
['optimize-impl] { /data
  data optimize-impl optimize-impl!
} def-fn! /optimize

; Remove optimize-impl from the environment
env 'optimize-impl delete restore

