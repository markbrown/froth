; codegen.froth - Bytecode code generation

; Get instruction codes
instruction-table 'push-int @ /ocPushInt
instruction-table 'push-string @ /ocPushString
instruction-table 'op @ /ocOp
instruction-table 'return @ /ocReturn
instruction-table 'push-quoted-apply @ /ocPushQuotedApply

; Get operator codes for quoted term construction
operator-table 'idToIdent @ /opIdToIdent
operator-table 'idToBinder @ /opIdToBinder
operator-table 'wrap @ /opWrap

; codegen-term: (code term -- code')
; Generate bytecode for a single term, append to code array.
['concat 'ocPushInt 'ocPushString 'ocOp 'operator-table
 'ocPushQuotedApply 'opIdToIdent 'opIdToBinder 'opWrap] { /term /code
  term isValue {
    ; Quoted literal value - unwrap and check type
    term unwrap /val
    val isInt {
      code [ocPushInt val] concat!
    } {
    val isString {
      code [ocPushString val intern] concat!
    } {
      ; Unsupported value type
      code
    } ?! } ?!
  } {
  term isIdent {
    term isOperator {
      ; Operator - emit op instruction with opcode
      operator-table term @ /opcode
      code [ocOp opcode] concat!
    } {
      ; Regular identifier (bound or free) - skip for now
      code
    } ?!
  } {
  term isQuote {
    ; Quote term - unwrap and check inner type
    term unwrap /inner
    inner isIdent {
      ; 'identifier -> push-int id, op idToIdent
      inner intern /id
      code [ocPushInt id ocOp opIdToIdent] concat!
    } {
    inner isBinder {
      ; '/binder -> push-int id, op idToBinder
      inner intern /id
      code [ocPushInt id ocOp opIdToBinder] concat!
    } {
    inner isApply {
      ; '! -> push-quoted-apply
      code [ocPushQuotedApply] concat!
    } {
    inner isValue {
      ; 'value -> push value, op wrap
      inner unwrap /val
      val isInt {
        code [ocPushInt val ocOp opWrap] concat!
      } {
      val isString {
        code [ocPushString val intern ocOp opWrap] concat!
      } {
        ; Unsupported quoted value type
        code
      } ?! } ?!
    } {
      ; Quoted function, generator, or nested quote - skip for now
      code
    } ?! } ?! } ?! } ?!
  } {
    ; Other term type - skip for now
    code
  } ?! } ?! } ?!
} def-fn! /codegen-term

; codegen-seq: (code func idx -- code')
; Process terms from idx to end of func.
{ /self /idx /func /code
  idx func # = {
    ; Done
    code
  } {
    ; Process current term, recurse
    code func idx @ codegen-term!
    func idx 1 + self self!
  } ?!
} /codegen-seq-impl

['codegen-seq-impl 'codegen-term] { /idx /func /code
  code func idx codegen-seq-impl codegen-seq-impl!
} def-fn! /codegen-seq

; codegen: (addr code-map func func-node -- next-addr new-code-map func-addr)
; Generate bytecode for a function.
; Walks body left-to-right, collects bytecode, emits at addr.
['codegen-seq 'concat 'emit-all-at 'ocReturn] { /func-node /func /code-map /addr
  ; Collect bytecode for each term in function body
  [] func 0 codegen-seq! /body-code

  ; Add return instruction
  body-code [ocReturn] concat! /final-code

  ; Emit at addr
  final-code addr emit-all-at! /next-addr

  ; Return (next-addr new-code-map func-addr)
  ; code-map unchanged since we don't handle nested functions yet
  next-addr code-map addr
} def-fn! /codegen

; Clean up impl
env 'codegen-seq-impl delete restore
