; codegen.froth - Bytecode code generation

; Get instruction codes
instruction-table 'push-int @ /ocPushInt
instruction-table 'push-string @ /ocPushString
instruction-table 'op @ /ocOp
instruction-table 'return @ /ocReturn
instruction-table 'push-quoted-apply @ /ocPushQuotedApply
instruction-table 'push-context @ /ocPushContext
instruction-table 'push-local @ /ocPushLocal
instruction-table 'pop-local @ /ocPopLocal
instruction-table 'pop-unused @ /ocPopUnused
instruction-table 'enter-frame @ /ocEnterFrame
instruction-table 'leave-frame @ /ocLeaveFrame
instruction-table 'start-array @ /ocStartArray
instruction-table 'end-array @ /ocEndArray
instruction-table 'tail-call @ /ocTailCall
instruction-table 'call @ /ocCall
instruction-table 'save-context-ptr @ /ocSaveContextPtr
instruction-table 'restore-context-ptr @ /ocRestoreContextPtr
instruction-table 'save-return-ptr @ /ocSaveReturnPtr
instruction-table 'restore-return-ptr @ /ocRestoreReturnPtr

; Get operator codes for quoted term construction and closure creation
operator-table 'idToIdent @ /opIdToIdent
operator-table 'idToBinder @ /opIdToBinder
operator-table 'wrap @ /opWrap
operator-table 'close @ /opClose
operator-table 'deref @ /opDeref

; codegen-term: (codegen-fn seq-fn addr code-map code need-enter node outer-free-vars outer-bound-slots max-slots -- addr' code-map' code' need-enter')
; Generate bytecode for a single term, append to code array.
; codegen-fn is passed for recursive compilation of nested functions
; seq-fn is passed for processing generator bodies (calls codegen-term for each term)
; node is the analysis node for this term (from boundness/liveness/slots), contains 'term
; outer-free-vars maps identifiers to context slot numbers in the current function
; outer-bound-slots maps identifiers to frame slot numbers in the current function
; max-slots is the number of frame slots needed (for enter-frame/leave-frame)
; need-enter is 0 if we still need to emit enter-frame, 1 if already emitted
; Returns updated addr, code-map, code, and need-enter flag
['concat 'ocPushInt 'ocPushString 'ocOp 'operator-table
 'ocPushQuotedApply 'opIdToIdent 'opIdToBinder 'opWrap
 'ocPushContext 'ocPushLocal 'ocPopLocal 'ocPopUnused
 'ocEnterFrame 'ocLeaveFrame
 'ocStartArray 'ocEndArray 'opClose 'opDeref 'ocTailCall 'ocCall
 'ocSaveContextPtr 'ocRestoreContextPtr 'ocSaveReturnPtr 'ocRestoreReturnPtr
 'foldl 'reduce 'drop 'or 'and] {
  /max-slots /outer-bound-slots /outer-free-vars /node /need-enter /code /code-map /addr /seq-fn /codegen-fn
  node 'term @ /term
  term isValue {
    ; Quoted literal value - unwrap and check type
    term unwrap /val
    val isInt {
      addr code-map code [ocPushInt val] concat! need-enter
    } {
    val isString {
      addr code-map code [ocPushString val intern] concat! need-enter
    } {
      ; Unsupported value type
      addr code-map code need-enter
    } ?! } ?!
  } {
  term isBinder {
    ; Binder - check if used or dead
    node 'is-used in {
      node 'is-used @ {
        ; Used binder (is-used=0) - maybe emit enter-frame, then pop-local
        need-enter {
          ; First binder (need-enter=0) - enter frame first
          code [ocEnterFrame max-slots] concat!
        } {
          ; Already in frame
          code
        } ?!
        node 'slot @ /slot
        [ocPopLocal slot] concat! /new-code
        addr code-map new-code 1  ; now in frame (need-enter=1)
      } {
        ; Dead binder (is-used=1) - just discard
        addr code-map code [ocPopUnused] concat! need-enter
      } ?!
    } {
      ; No 'is-used key - assume dead
      addr code-map code [ocPopUnused] concat! need-enter
    } ?!
  } {
  term isIdent {
    term isOperator {
      ; Operator - emit op instruction with opcode
      operator-table term @ /opcode
      addr code-map code [ocOp opcode] concat! need-enter
    } {
      ; Regular identifier - check if bound or free
      node 'is-bound in {
        node 'is-bound @ {
          ; Bound variable (is-bound=0) - emit push-local
          node 'slot @ /slot
          code [ocPushLocal slot] concat!
          ; Check if this is the last frame access
          node 'leave-frame in {
            node 'leave-frame @ {
              ; Last frame access (leave-frame=0) - exit frame
              [ocLeaveFrame max-slots] concat!
            } { } ?!
          } { } ?!
          /new-code
          addr code-map new-code need-enter
        } {
          ; Free variable (is-bound=1) - look up context slot
          outer-free-vars term @ /slot
          addr code-map code [ocPushContext slot] concat! need-enter
        } ?!
      } {
        ; No analysis data - skip
        addr code-map code need-enter
      } ?!
    } ?!
  } {
  term isQuote {
    ; Quote term - unwrap and check inner type
    term unwrap /inner
    inner isIdent {
      ; 'identifier -> push-int id, op idToIdent
      inner intern /id
      addr code-map code [ocPushInt id ocOp opIdToIdent] concat! need-enter
    } {
    inner isBinder {
      ; '/binder -> push-int id, op idToBinder
      inner intern /id
      addr code-map code [ocPushInt id ocOp opIdToBinder] concat! need-enter
    } {
    inner isApply {
      ; '! -> push-quoted-apply
      addr code-map code [ocPushQuotedApply] concat! need-enter
    } {
    inner isValue {
      ; 'value -> push value, op wrap
      inner unwrap /val
      val isInt {
        addr code-map code [ocPushInt val ocOp opWrap] concat! need-enter
      } {
      val isString {
        addr code-map code [ocPushString val intern ocOp opWrap] concat! need-enter
      } {
        ; Unsupported quoted value type
        addr code-map code need-enter
      } ?! } ?!
    } {
      ; Quoted function, generator, or nested quote - store in constant pool
      term ref /idx
      addr code-map code [ocPushInt idx ocOp opDeref] concat! need-enter
    } ?! } ?! } ?! } ?!
  } {
  term isFunc {
    ; Nested function - compile it and emit code to build closure at runtime
    ; node is the function-node for this nested function (contains 'term)

    ; First, recursively compile the nested function using codegen-fn
    codegen-fn addr code-map node codegen-fn! /nested-addr /new-code-map /new-addr

    ; Build context array at runtime: [start-array, push each captured var, end-array]
    ; The nested function's free-vars tells us what to capture
    ; For each captured var, check if it's bound or free in OUTER scope
    node 'free-vars in { node 'free-vars @ } { $ } ?! /nested-free-vars

    ; Get the number of context slots needed
    nested-free-vars keys # /num-captures

    num-captures 0 = {
      ; No captures - just push empty array and address
      code [ocStartArray ocEndArray ocPushInt nested-addr ocOp opClose] concat!
    } {
      ; Build array of (slot, ident) pairs, then sort by slot to emit in order
      ; First collect all free vars with their context slots
      nested-free-vars keys /the-keys
      [ the-keys { /ident nested-free-vars ident @ /slot [slot ident] } foldl! ] /pairs

      ; Sort pairs by slot (simple insertion sort for small arrays)
      ; For now, assume they're already in order (slots assigned 0, 1, 2, ...)
      ; TODO: proper sort if needed

      ; Start building the context array
      code [ocStartArray] concat! /ctx-code

      ; For each captured variable, emit push instruction
      ; Use reduce to accumulate the bytecode
      pairs ctx-code {
        /pair /acc
        pair 1 @ /ident
        ; Check if this var is bound or free in outer scope
        outer-bound-slots ident in {
          ; Bound in outer - push from frame
          outer-bound-slots ident @ /outer-slot
          acc [ocPushLocal outer-slot] concat!
        } {
          ; Free in outer - push from context
          outer-free-vars ident @ /outer-slot
          acc [ocPushContext outer-slot] concat!
        } ?!
      } reduce! /ctx-code2

      ; End array, push address, close
      ctx-code2 [ocEndArray ocPushInt nested-addr ocOp opClose] concat!
    } ?! /new-code

    new-addr new-code-map new-code need-enter
  } {
  term isGen {
    ; Generator - wrap body in start-array/end-array, share outer frame
    node 'body in { node 'body @ } { [ term { drop! $ } foldl! ] } ?! /gen-body-nodes

    ; Build combined bound-slots including generator's binders
    ; Scan gen-body-nodes for binder nodes with 'slot set
    outer-bound-slots 0  ; start with outer's bound-slots, idx=0
    gen-body-nodes {
      /gnode /idx /gmap
      gnode 'term @ /gterm
      gterm isBinder {
        gnode 'slot in {
          gnode 'slot @ /slot
          gterm intern idToIdent /ident
          gmap slot ident : idx 1 +
        } { gmap idx 1 + } ?!
      } { gmap idx 1 + } ?!
    } foldl!
    drop!  ; discard final idx
    /gen-bound-slots

    ; Process: start-array, generator body, end-array
    ; Use seq-fn to process terms (shares outer's frame)
    codegen-fn seq-fn addr code-map code [ocStartArray] concat! need-enter gen-body-nodes outer-free-vars gen-bound-slots max-slots 0 seq-fn!
    /gen-code /gen-code-map /gen-addr

    gen-addr gen-code-map gen-code [ocEndArray] concat! need-enter
  } {
  term isApply {
    ; Apply - check node for tail call flag
    node 'is-tail-call in { node 'is-tail-call @ } { 1 } ?! {
      ; Tail call (is-tail-call=0) - emit tail-call
      addr code-map code [ocTailCall] concat! need-enter
    } {
      ; Non-tail call - handle register saves/restores
      ; Check if we need to save context or return pointer
      node 'save-context in { node 'save-context @ 0 = } { 1 } ?! /needs-save-ctx
      node 'save-return in { node 'save-return @ 0 = } { 1 } ?! /needs-save-rp

      ; Step 1: Enter frame if needed (haven't entered yet AND need to save registers)
      need-enter needs-save-ctx needs-save-rp 0 = or! 0 = and! {
        ; need-enter=0 AND (needs-save-ctx OR needs-save-rp) - enter frame first
        code [ocEnterFrame max-slots] concat! 1
      } {
        code need-enter
      } ?! /new-need-enter /code1

      ; Step 2: Save context if this is the first call needing it
      needs-save-ctx {
        node 'ctx-save-slot @ /ctx-slot
        code1 [ocSaveContextPtr ocPopLocal ctx-slot] concat!
      } { code1 } ?! /code2

      ; Step 3: Save return pointer if this is the first non-tail call
      needs-save-rp {
        node 'rp-save-slot @ /rp-slot
        code2 [ocSaveReturnPtr ocPopLocal rp-slot] concat!
      } { code2 } ?! /code3

      ; Step 4: Emit call
      code3 [ocCall] concat! /code4

      ; Step 5: Restore context if needed
      node 'restore-context in { node 'restore-context @ 0 = } { 1 } ?! {
        node 'ctx-save-slot @ /ctx-slot
        code4 [ocPushLocal ctx-slot ocRestoreContextPtr] concat!
      } { code4 } ?! /code5

      ; Step 6: Restore return pointer if this is the last non-tail call
      node 'restore-return in { node 'restore-return @ 0 = } { 1 } ?! {
        node 'rp-save-slot @ /rp-slot
        code5 [ocPushLocal rp-slot ocRestoreReturnPtr] concat!
      } { code5 } ?! /code6

      ; Step 7: Leave frame if this is the last term using the frame
      node 'leave-frame in { node 'leave-frame @ 0 = } { 1 } ?! {
        code6 [ocLeaveFrame max-slots] concat!
      } { code6 } ?! /code7

      addr code-map code7 new-need-enter
    } ?!
  } {
    ; Other term type - skip
    addr code-map code need-enter
  } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /codegen-term

; codegen-seq: (codegen-fn seq-fn addr code-map code need-enter body-nodes outer-free-vars outer-bound-slots max-slots idx -- addr' code-map' code')
; Process terms from idx to end of body-nodes.
; codegen-fn is passed for recursive compilation of nested functions
; seq-fn is this function, passed for generator body processing
; body-nodes is an array of analysis nodes (each contains 'term)
; outer-free-vars maps identifiers to context slot numbers
; outer-bound-slots maps identifiers to frame slot numbers
; max-slots is the number of frame slots needed
; need-enter tracks whether enter-frame has been emitted (0=need, 1=done)
{ /self /idx /max-slots /outer-bound-slots /outer-free-vars /body-nodes /need-enter /code /code-map /addr /seq-fn /codegen-fn
  idx body-nodes # = {
    ; Done - discard need-enter, return (addr code-map code)
    addr code-map code
  } {
    ; Get node for current term
    body-nodes idx @ /node
    ; Process current term, get back (addr' code-map' code' need-enter')
    ; Pass seq-fn (wrapped self) for generator body processing
    codegen-fn seq-fn addr code-map code need-enter node outer-free-vars outer-bound-slots max-slots codegen-term!
    /new-need-enter /new-code /new-code-map /new-addr
    ; Recurse with updated state
    codegen-fn seq-fn new-addr new-code-map new-code new-need-enter body-nodes outer-free-vars outer-bound-slots max-slots idx 1 + self self!
  } ?!
} /codegen-seq-impl

['codegen-seq-impl 'codegen-term] { /idx /max-slots /outer-bound-slots /outer-free-vars /body-nodes /need-enter /code /code-map /addr /seq-fn /codegen-fn
  codegen-fn seq-fn addr code-map code need-enter body-nodes outer-free-vars outer-bound-slots max-slots idx codegen-seq-impl codegen-seq-impl!
} def-fn! /codegen-seq

; codegen-impl: (self addr code-map func-node -- next-addr new-code-map func-addr)
; Implementation of codegen with Y-combinator pattern for recursion.
; self is this function, passed for recursive calls to nested functions.
; func-node contains 'term (the function) and analysis data.
['codegen-seq 'concat 'emit-all-at 'ocReturn 'foldl 'drop 'make-node] { /func-node /code-map /addr /self
  ; Extract the function term from the node
  func-node 'term @ /func

  ; Extract analysis info from func-node (or create empty defaults)
  ; 'in' returns 0 if found, 1 if not found
  ; Check both if 'body exists AND has content
  func-node 'body in { func-node 'body @ } { [] } ?! /maybe-body
  maybe-body # 0 = {
    ; No body-nodes or empty - create array of nodes (one per term)
    [ func { make-node! } foldl! ]
  } {
    maybe-body
  } ?! /body-nodes
  func-node 'free-vars in { func-node 'free-vars @ } { $ } ?! /free-vars

  ; Extract frame info
  ; max-slots: number of frame slots needed (default 0)
  func-node 'max-slots in { func-node 'max-slots @ } { 0 } ?! /max-slots
  ; needs-frame: 0 if frame needed, 1 if not (default 1 = no frame)
  ; need-enter: inverse of needs-frame (0 = need to emit enter-frame, 1 = already done/not needed)
  func-node 'needs-frame in { func-node 'needs-frame @ } { 1 } ?! /need-enter

  ; Build bound-slots map: identifier -> frame slot for each used binder
  ; Scan body-nodes for binder nodes that have 'slot set
  ; Carry (map, idx) through foldl
  ; Note: convert binder term /x to quoted identifier 'x for map key
  $ 0  ; initial: map=empty, idx=0
  body-nodes {
    /node /idx /map
    node 'term @ /term
    term isBinder {
      node 'slot in {
        node 'slot @ /slot
        term intern idToIdent /ident  ; convert /x to 'x
        map slot ident : idx 1 +
      } { map idx 1 + } ?!
    } { map idx 1 + } ?!
  } foldl!
  drop!  ; discard final idx
  /bound-slots

  ; Collect bytecode for each term in function body
  ; codegen-seq returns (addr' code-map' code')
  ; Pass self as codegen-fn for recursive compilation of nested functions
  ; Pass codegen-seq as seq-fn for generator body processing
  self codegen-seq addr code-map [] need-enter body-nodes free-vars bound-slots max-slots 0 codegen-seq!
  /body-code /new-code-map /next-emit-addr

  ; Check if last term is a tail call by looking at its node
  ; If so, don't emit return (tail-call handles the return)
  ; Only apply nodes have 'is-tail-call, so check with 'in first
  body-nodes # 0 > {
    body-nodes body-nodes # 1 - @ /last-node
    last-node 'is-tail-call in { last-node 'is-tail-call @ } { 1 } ?!
  } { 1 } ?! /last-is-tail
  last-is-tail { body-code } { body-code [ocReturn] concat! } ?! /final-code

  ; Emit at next-emit-addr (nested functions may have already used addr..next-emit-addr-1)
  final-code next-emit-addr emit-all-at! /next-addr

  ; Return (next-addr new-code-map func-addr)
  ; func-addr is where we emitted this function's code
  next-addr new-code-map next-emit-addr
} def-fn! /codegen-impl

; codegen: (addr code-map func-node -- next-addr new-code-map func-addr)
; Generate bytecode for a function.
; Walks body left-to-right, collects bytecode, emits at addr.
; func-node contains 'term (the function) and analysis data.
; The function term is preserved on the stack underneath the node.
['codegen-impl] { /func-node /code-map /addr
  codegen-impl addr code-map func-node codegen-impl!
} def-fn! /codegen

; Clean up impl and instruction/operator code bindings
env 'codegen-seq-impl delete 'codegen-impl delete
    'ocPushInt delete 'ocPushString delete 'ocOp delete 'ocReturn delete
    'ocPushQuotedApply delete 'ocPushContext delete 'ocPushLocal delete
    'ocPopLocal delete 'ocPopUnused delete 'ocEnterFrame delete 'ocLeaveFrame delete
    'ocStartArray delete 'ocEndArray delete 'ocTailCall delete 'ocCall delete
    'ocSaveContextPtr delete 'ocRestoreContextPtr delete
    'ocSaveReturnPtr delete 'ocRestoreReturnPtr delete
    'opIdToIdent delete 'opIdToBinder delete 'opWrap delete 'opClose delete 'opDeref delete
    restore
