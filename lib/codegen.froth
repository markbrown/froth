; codegen.froth - Bytecode code generation

; Get instruction codes
instruction-table 'push-int @ /ocPushInt
instruction-table 'push-string @ /ocPushString
instruction-table 'op @ /ocOp
instruction-table 'return @ /ocReturn
instruction-table 'push-quoted-apply @ /ocPushQuotedApply
instruction-table 'push-context @ /ocPushContext
instruction-table 'push-local @ /ocPushLocal
instruction-table 'pop-local @ /ocPopLocal
instruction-table 'pop-unused @ /ocPopUnused
instruction-table 'enter-frame @ /ocEnterFrame
instruction-table 'leave-frame @ /ocLeaveFrame
instruction-table 'start-array @ /ocStartArray
instruction-table 'end-array @ /ocEndArray
instruction-table 'tail-call @ /ocTailCall
instruction-table 'call @ /ocCall
instruction-table 'save-context-ptr @ /ocSaveContextPtr
instruction-table 'restore-context-ptr @ /ocRestoreContextPtr
instruction-table 'save-return-ptr @ /ocSaveReturnPtr
instruction-table 'restore-return-ptr @ /ocRestoreReturnPtr

; Get operator codes for quoted term construction and closure creation
operator-table 'idToIdent @ /opIdToIdent
operator-table 'idToBinder @ /opIdToBinder
operator-table 'wrap @ /opWrap
operator-table 'close @ /opClose
operator-table 'deref @ /opDeref

; codegen-term-impl: (addr code need-enter node max-slots seq-fn term-fn -- addr' code' need-enter')
; Generate bytecode for a single term, append to code array.
; seq-fn/term-fn are passed for processing generator bodies
; node is the analysis node for this term (from boundness/liveness/slots), contains 'term
; max-slots is the number of frame slots needed (for enter-frame/leave-frame)
; need-enter is 0 if we still need to emit enter-frame, 1 if already emitted
; Returns updated addr, code, and need-enter flag
['ocPushInt 'ocPushString 'ocOp 'operator-table
 'ocPushQuotedApply 'opIdToIdent 'opIdToBinder 'opWrap
 'ocPushContext 'ocPushLocal 'ocPopLocal 'ocPopUnused
 'ocEnterFrame 'ocLeaveFrame
 'ocStartArray 'ocEndArray 'opClose 'opDeref 'ocTailCall 'ocCall
 'ocSaveContextPtr 'ocRestoreContextPtr 'ocSaveReturnPtr 'ocRestoreReturnPtr
 'foldl 'reduce 'drop 'or 'and] {
  /term-fn /seq-fn /max-slots /node /need-enter /code /addr
  node 'term @ /term
  term isValue {
    ; Quoted literal value - unwrap and check type
    term unwrap /val
    val isInt {
      addr code ocPushInt , val , need-enter
    } {
    val isString {
      addr code ocPushString , val intern , need-enter
    } {
      ; Unsupported value type
      addr code need-enter
    } ?! } ?!
  } {
  term isBinder {
    ; Binder - check if used or dead
    node 'is-used in {
      node 'is-used @ {
        ; Used binder (is-used=0) - maybe emit enter-frame, then pop-local
        need-enter {
          ; First binder (need-enter=0) - enter frame first
          code ocEnterFrame , max-slots ,
        } {
          ; Already in frame
          code
        } ?!
        node 'slot @ /slot
        ocPopLocal , slot , /new-code
        addr new-code 1  ; now in frame (need-enter=1)
      } {
        ; Dead binder (is-used=1) - just discard
        addr code ocPopUnused , need-enter
      } ?!
    } {
      ; No 'is-used key - assume dead
      addr code ocPopUnused , need-enter
    } ?!
  } {
  term isIdent {
    node 'is-operator @ 0 = {
      ; Operator - emit op instruction with opcode
      operator-table term @ /opcode
      addr code ocOp , opcode , need-enter
    } {
      ; Variable - check if bound or free
      node 'is-bound @ {
        ; Bound variable (is-bound=0) - emit push-local
        node 'slot @ /slot
        code ocPushLocal , slot ,
        ; Check if this is the last frame access
        node 'leave-frame in {
          node 'leave-frame @ {
            ; Last frame access (leave-frame=0) - exit frame
            ocLeaveFrame , max-slots ,
          } { } ?!
        } { } ?!
        /new-code
        addr new-code need-enter
      } {
        ; Free variable (is-bound=1) - slot already set on node
        node 'slot @ /slot
        addr code ocPushContext , slot , need-enter
      } ?!
    } ?!
  } {
  term isQuote {
    ; Quote term - unwrap and check inner type
    term unwrap /inner
    inner isIdent {
      ; 'identifier -> push-int id, op idToIdent
      inner intern /id
      addr code ocPushInt , id , ocOp , opIdToIdent , need-enter
    } {
    inner isBinder {
      ; '/binder -> push-int id, op idToBinder
      inner intern /id
      addr code ocPushInt , id , ocOp , opIdToBinder , need-enter
    } {
    inner isApply {
      ; '! -> push-quoted-apply
      addr code ocPushQuotedApply , need-enter
    } {
    inner isValue {
      ; 'value -> push value, op wrap
      inner unwrap /val
      val isInt {
        addr code ocPushInt , val , ocOp , opWrap , need-enter
      } {
      val isString {
        addr code ocPushString , val intern , ocOp , opWrap , need-enter
      } {
        ; Unsupported quoted value type
        addr code need-enter
      } ?! } ?!
    } {
      ; Quoted function, generator, or nested quote - store in constant pool
      term ref /idx
      addr code ocPushInt , idx , ocOp , opDeref , need-enter
    } ?! } ?! } ?! } ?!
  } {
  term isFunc {
    ; Nested function - already compiled by compile-func, emit code to build closure
    ; node is the function-node with 'func-addr already set

    ; Read the pre-computed bytecode address
    node 'func-addr @ /nested-addr

    ; Get outer scope maps (set by boundness and slots passes)
    node 'outer-bound-vars-map in { node 'outer-bound-vars-map @ } { $ } ?! /outer-bound
    node 'outer-free-vars-map in { node 'outer-free-vars-map @ } { $ } ?! /outer-free

    ; Build context array at runtime: [start-array, push each captured var, end-array]
    ; The nested function's free-vars-array tells us what to capture (already in slot order)
    ; For each captured var, check if it's bound or free in OUTER scope
    node 'free-vars-array in { node 'free-vars-array @ } { [] } ?! /nested-free-array

    nested-free-array # 0 = {
      ; No captures - just push empty array and address
      code ocStartArray , ocEndArray , ocPushInt , nested-addr , ocOp , opClose ,
    } {
      ; Start building the context array
      code ocStartArray , /ctx-code

      ; For each captured variable (in slot order), emit push instruction
      nested-free-array ctx-code {
        /ident /acc
        ; Check if this var is bound or free in outer scope
        outer-bound ident in {
          ; Bound in outer - push from frame
          outer-bound ident @ /slot
          acc ocPushLocal , slot ,
        } {
          ; Free in outer - push from context
          outer-free ident @ /slot
          acc ocPushContext , slot ,
        } ?!
      } reduce! /ctx-code2

      ; End array, push address, close
      ctx-code2 ocEndArray , ocPushInt , nested-addr , ocOp , opClose ,
    } ?!
    ; Check if this closure is the last frame access
    node 'leave-frame in { node 'leave-frame @ 0 = } { 1 } ?! {
      ocLeaveFrame , max-slots ,
    } { } ?!
    /new-code

    ; addr unchanged (no recursive compilation)
    addr new-code need-enter
  } {
  term isGen {
    ; Generator - wrap body in start-array/end-array, share outer frame
    node 'body in { node 'body @ } { [ term { drop! $ } foldl! ] } ?! /gen-body-nodes

    ; Process: start-array, generator body, end-array
    ; Nested functions inside have outer-bound-vars-map/outer-free-vars-map already set
    addr code ocStartArray , need-enter gen-body-nodes max-slots 0 seq-fn term-fn seq-fn!
    /gen-code /gen-addr

    gen-addr gen-code ocEndArray , need-enter
  } {
  term isApply {
    ; Apply - check node for tail call flag
    node 'is-tail-call in { node 'is-tail-call @ } { 1 } ?! {
      ; Tail call (is-tail-call=0) - emit tail-call
      addr code ocTailCall , need-enter
    } {
      ; Non-tail call - handle register saves/restores
      ; Check if we need to save context or return pointer
      node 'save-context in { node 'save-context @ 0 = } { 1 } ?! /needs-save-ctx
      node 'save-return in { node 'save-return @ 0 = } { 1 } ?! /needs-save-rp

      ; Step 1: Enter frame if needed (haven't entered yet AND need to save registers)
      need-enter needs-save-ctx needs-save-rp 0 = or! 0 = and! {
        ; need-enter=0 AND (needs-save-ctx OR needs-save-rp) - enter frame first
        code ocEnterFrame , max-slots , 1
      } {
        code need-enter
      } ?! /new-need-enter /code1

      ; Step 2: Save context if this is the first call needing it
      needs-save-ctx {
        node 'ctx-save-slot @ /ctx-slot
        code1 ocSaveContextPtr , ocPopLocal , ctx-slot ,
      } { code1 } ?! /code2

      ; Step 3: Save return pointer if this is the first non-tail call
      needs-save-rp {
        node 'rp-save-slot @ /rp-slot
        code2 ocSaveReturnPtr , ocPopLocal , rp-slot ,
      } { code2 } ?! /code3

      ; Step 4: Emit call
      code3 ocCall , /code4

      ; Step 5: Restore context if needed
      node 'restore-context in { node 'restore-context @ 0 = } { 1 } ?! {
        node 'ctx-save-slot @ /ctx-slot
        code4 ocPushLocal , ctx-slot , ocRestoreContextPtr ,
      } { code4 } ?! /code5

      ; Step 6: Restore return pointer if this is the last non-tail call
      node 'restore-return in { node 'restore-return @ 0 = } { 1 } ?! {
        node 'rp-save-slot @ /rp-slot
        code5 ocPushLocal , rp-slot , ocRestoreReturnPtr ,
      } { code5 } ?! /code6

      ; Step 7: Leave frame if this is the last term using the frame
      node 'leave-frame in { node 'leave-frame @ 0 = } { 1 } ?! {
        code6 ocLeaveFrame , max-slots ,
      } { code6 } ?! /code7

      addr code7 new-need-enter
    } ?!
  } {
    ; Other term type - skip
    addr code need-enter
  } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /codegen-term-impl

; codegen-seq-impl: (addr code need-enter body-nodes max-slots idx seq-fn term-fn -- addr' code')
; Process terms from idx to end of body-nodes.
; body-nodes is an array of analysis nodes (each contains 'term)
; max-slots is the number of frame slots needed
; need-enter tracks whether enter-frame has been emitted (0=need, 1=done)
['codegen-term-impl] { /term-fn /seq-fn /idx /max-slots /body-nodes /need-enter /code /addr
  idx body-nodes # = {
    ; Done - discard need-enter, return (addr code)
    addr code
  } {
    ; Get node for current term
    body-nodes idx @ /node
    ; Process current term with term-fn
    addr code need-enter node max-slots seq-fn term-fn term-fn!
    /new-need-enter /new-code /new-addr
    ; Recurse with seq-fn
    new-addr new-code new-need-enter body-nodes max-slots idx 1 + seq-fn term-fn seq-fn!
  } ?!
} def-fn! /codegen-seq-impl

; codegen: (addr func-node -- next-addr func-node)
; Generate bytecode for a function.
; Walks body left-to-right, collects bytecode, emits at addr.
; func-node contains 'term (the function) and analysis data.
; Stores 'func-addr in node before returning.
['codegen-seq-impl 'codegen-term-impl 'lfoldr 'emit-all-at 'ocReturn 'foldl 'make-node] { /func-node /addr
  ; Extract the function term from the node
  func-node 'term @ /func

  ; Extract analysis info from func-node (or create empty defaults)
  ; 'in' returns 0 if found, 1 if not found
  ; Check both if 'body exists AND has content
  func-node 'body in { func-node 'body @ } { [] } ?! /maybe-body
  maybe-body # 0 = {
    ; No body-nodes or empty - create array of nodes (one per term)
    [ func { make-node! } foldl! ]
  } {
    maybe-body
  } ?! /body-nodes

  ; Extract frame info
  ; max-slots: number of frame slots needed (default 0)
  func-node 'max-slots in { func-node 'max-slots @ } { 0 } ?! /max-slots
  ; needs-frame: 0 if frame needed, 1 if not (default 1 = no frame)
  ; need-enter: inverse of needs-frame (0 = need to emit enter-frame, 1 = already done/not needed)
  func-node 'needs-frame in { func-node 'needs-frame @ } { 1 } ?! /need-enter

  ; Collect bytecode for each term in function body
  ; codegen-seq-impl returns (addr' code') where code' is a cons list (reversed)
  ; Pass impl functions for generator body processing
  addr . need-enter body-nodes max-slots 0 codegen-seq-impl codegen-term-impl codegen-seq-impl!
  /body-code /next-emit-addr

  ; Check if last term is a tail call by looking at its node
  ; If so, don't emit return (tail-call handles the return)
  ; Only apply nodes have 'is-tail-call, so check with 'in first
  body-nodes # 0 > {
    body-nodes body-nodes # 1 - @ /last-node
    last-node 'is-tail-call in { last-node 'is-tail-call @ } { 1 } ?!
  } { 1 } ?! /last-is-tail
  last-is-tail { body-code } { body-code ocReturn , } ?! /final-code

  ; Convert list to array (lfoldr processes tail-to-head, giving correct order)
  [ final-code { } lfoldr! ] addr emit-all-at! /next-addr

  ; Store func-addr in node and return (next-addr func-node)
  next-addr func-node addr 'func-addr :
} def-fn! /codegen

; Clean up impl and instruction/operator code bindings
env 'codegen-seq-impl delete 'codegen-term-impl delete
    'ocPushInt delete 'ocPushString delete 'ocOp delete 'ocReturn delete
    'ocPushQuotedApply delete 'ocPushContext delete 'ocPushLocal delete
    'ocPopLocal delete 'ocPopUnused delete 'ocEnterFrame delete 'ocLeaveFrame delete
    'ocStartArray delete 'ocEndArray delete 'ocTailCall delete 'ocCall delete
    'ocSaveContextPtr delete 'ocRestoreContextPtr delete
    'ocSaveReturnPtr delete 'ocRestoreReturnPtr delete
    'opIdToIdent delete 'opIdToBinder delete 'opWrap delete 'opClose delete 'opDeref delete
    restore
