; codegen.froth - Bytecode code generation

; Get instruction codes
instruction-table 'push-int @ /ocPushInt
instruction-table 'push-string @ /ocPushString
instruction-table 'op @ /ocOp
instruction-table 'return @ /ocReturn
instruction-table 'push-quoted-apply @ /ocPushQuotedApply
instruction-table 'push-context @ /ocPushContext

; Get operator codes for quoted term construction
operator-table 'idToIdent @ /opIdToIdent
operator-table 'idToBinder @ /opIdToBinder
operator-table 'wrap @ /opWrap

; codegen-term: (code term node free-vars -- code')
; Generate bytecode for a single term, append to code array.
; node is the analysis node for this term (from boundness/liveness/slots)
; free-vars maps identifiers to context slot numbers
['concat 'ocPushInt 'ocPushString 'ocOp 'operator-table
 'ocPushQuotedApply 'opIdToIdent 'opIdToBinder 'opWrap
 'ocPushContext] { /free-vars /node /term /code
  term isValue {
    ; Quoted literal value - unwrap and check type
    term unwrap /val
    val isInt {
      code [ocPushInt val] concat!
    } {
    val isString {
      code [ocPushString val intern] concat!
    } {
      ; Unsupported value type
      code
    } ?! } ?!
  } {
  term isIdent {
    term isOperator {
      ; Operator - emit op instruction with opcode
      operator-table term @ /opcode
      code [ocOp opcode] concat!
    } {
      ; Regular identifier - check if bound or free
      ; 'in' returns 0 if found, 1 if not found
      node 'is-bound in {
        ; 'is-bound exists - check its value
        ; is-bound=0 means bound, is-bound=1 means free
        ; ? takes then-branch when cond=0, else-branch when cond=non-zero
        node 'is-bound @ {
          ; is-bound=0 means bound variable - skip for now (needs frame support)
          code
        } {
          ; is-bound=1 means free variable - look up context slot
          free-vars term @ /slot
          code [ocPushContext slot] concat!
        } ?!
      } {
        ; No 'is-bound key - skip (no analysis data)
        code
      } ?!
    } ?!
  } {
  term isQuote {
    ; Quote term - unwrap and check inner type
    term unwrap /inner
    inner isIdent {
      ; 'identifier -> push-int id, op idToIdent
      inner intern /id
      code [ocPushInt id ocOp opIdToIdent] concat!
    } {
    inner isBinder {
      ; '/binder -> push-int id, op idToBinder
      inner intern /id
      code [ocPushInt id ocOp opIdToBinder] concat!
    } {
    inner isApply {
      ; '! -> push-quoted-apply
      code [ocPushQuotedApply] concat!
    } {
    inner isValue {
      ; 'value -> push value, op wrap
      inner unwrap /val
      val isInt {
        code [ocPushInt val ocOp opWrap] concat!
      } {
      val isString {
        code [ocPushString val intern ocOp opWrap] concat!
      } {
        ; Unsupported quoted value type
        code
      } ?! } ?!
    } {
      ; Quoted function, generator, or nested quote - skip for now
      code
    } ?! } ?! } ?! } ?!
  } {
    ; Other term type - skip for now
    code
  } ?! } ?! } ?!
} def-fn! /codegen-term

; codegen-seq: (code func body-nodes free-vars idx -- code')
; Process terms from idx to end of func.
; body-nodes is an array of analysis nodes parallel to func terms
; free-vars maps identifiers to context slot numbers
{ /self /idx /free-vars /body-nodes /func /code
  idx func # = {
    ; Done
    code
  } {
    ; Get term and its corresponding node
    func idx @ /term
    body-nodes idx @ /node
    ; Process current term, recurse
    code term node free-vars codegen-term!
    func body-nodes free-vars idx 1 + self self!
  } ?!
} /codegen-seq-impl

['codegen-seq-impl 'codegen-term] { /idx /free-vars /body-nodes /func /code
  code func body-nodes free-vars idx codegen-seq-impl codegen-seq-impl!
} def-fn! /codegen-seq

; codegen: (addr code-map func func-node -- next-addr new-code-map func-addr)
; Generate bytecode for a function.
; Walks body left-to-right, collects bytecode, emits at addr.
['codegen-seq 'concat 'emit-all-at 'ocReturn 'foldl 'drop] { /func-node /func /code-map /addr
  ; Extract analysis info from func-node (or create empty defaults)
  ; 'in' returns 0 if found, 1 if not found
  func-node 'body in {
    ; 'body found - use it
    func-node 'body @
  } {
    ; No body-nodes - create array of empty maps (one per term)
    [ func { drop! $ } foldl! ]
  } ?! /body-nodes
  func-node 'free-vars in { func-node 'free-vars @ } { $ } ?! /free-vars

  ; Collect bytecode for each term in function body
  [] func body-nodes free-vars 0 codegen-seq! /body-code

  ; Add return instruction
  body-code [ocReturn] concat! /final-code

  ; Emit at addr
  final-code addr emit-all-at! /next-addr

  ; Return (next-addr new-code-map func-addr)
  ; code-map unchanged since we don't handle nested functions yet
  next-addr code-map addr
} def-fn! /codegen

; Clean up impl
env 'codegen-seq-impl delete restore
