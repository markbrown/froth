; lib/codegen.froth
; Bytecode code generation for Froth compiler

; codegen-term-impl: (term node max-slots addr entered slot-map free-vars deferred seq-fn term-fn -- new-addr new-entered new-slot-map new-deferred)
; Generate bytecode for a single term.
; term: the source term
; node: the slots node (has all analysis info)
; max-slots: maximum frame slots for this function
; addr: current bytecode address
; entered: 1 if we haven't entered frame yet, 0 if we have
; slot-map: bound variable -> frame slot (for current function)
; free-vars: free variable -> context slot (for current function)
; deferred: cons list of (term, node, placeholder-addr) for nested closures
; Returns updated addr, entered, slot-map, and deferred list.
['emit-at 'emit-all-at 'and 'swap 'foldl 'not
 'ocPushInt 'ocOp 'ocReturn 'ocPushString 'ocPushContext 'ocPopUnused
 'ocPushLocal 'ocPopLocal 'ocEnterFrame 'ocLeaveFrame 'ocStartArray 'ocEndArray
 'ocCall 'ocTailCall 'ocSaveReturnPtr 'ocRestoreReturnPtr 'ocSaveContextPtr 'ocRestoreContextPtr
 'opClose 'op-table] { /term-fn /seq-fn /deferred /free-vars /slot-map /entered /addr /max-slots /node /term
  ; Helper: maybe enter frame (if not entered and slots needed)
  ; ( addr entered -- addr entered ) where entered becomes 0
  { /e /a
    e 0 = { a e } {
      max-slots 0 = { a e } {
        ocEnterFrame a emit-at! max-slots swap! emit-at! 0
      } ?!
    } ?!
  } /maybe-enter

  ; Helper: emit leave frame if this term has leave-frame=0
  ; ( addr entered -- addr entered )
  ; If we emit leaveFrame, set entered=1 (we've left the frame)
  { /e /a
    node 'leave-frame in 0 = {
      node 'leave-frame @ 0 = {
        ocLeaveFrame a emit-at! max-slots swap! emit-at! 1
      } { a e } ?!
    } { a e } ?!
  } /maybe-leave

  ; Handle value-wrapped literals (integers/strings in quoted closures)
  term isValue 0 = {
    term unwrap /val
    val isInt {
      ; Integer literal: pushInt n
      ocPushInt addr emit-at! val swap! emit-at! entered maybe-leave! slot-map deferred
    } {
      ; String literal: pushString intern-id
      ocPushString addr emit-at! val intern swap! emit-at! entered maybe-leave! slot-map deferred
    } ?!
  } {
  term isInt {
    ; Raw integer literal: pushInt n
    ocPushInt addr emit-at! term swap! emit-at! entered maybe-leave! slot-map deferred
  } {
  term isString {
    ; Raw string literal: pushString intern-id
    ocPushString addr emit-at! term intern swap! emit-at! entered maybe-leave! slot-map deferred
  } {
  term isIdent 0 = node 'is-bound in 0 = and! {
    ; Identifier with is-bound key (variable reference)
    node 'is-bound @ 0 = {
      ; Bound identifier: pushLocal slot
      node 'slot @ /slot
      addr entered maybe-enter! /new-entered
      ocPushLocal swap! emit-at! slot swap! emit-at! new-entered maybe-leave! slot-map deferred
    } {
      ; Free identifier: pushContext slot
      node 'slot @ /slot
      ocPushContext addr emit-at! slot swap! emit-at! entered maybe-leave! slot-map deferred
    } ?!
  } {
  term isBinder {
    ; Binder: popLocal slot (if used) or popUnused (if dead)
    node 'is-used @ 0 = {
      ; Used: need slot, update slot-map
      node 'slot @ /slot
      term intern idToIdent /ident
      addr entered maybe-enter! /new-entered
      ocPopLocal swap! emit-at! slot swap! emit-at!
      new-entered slot-map slot ident : deferred
    } {
      ; Dead: just discard
      ocPopUnused addr emit-at! entered slot-map deferred
    } ?!
  } {
  term isApply {
    ; Apply: handle saves, call, restores
    ; Get ctx-save-slot from node (per-call) and rp-slot from slot-map (function-level)
    node 'ctx-save-slot in 0 = { node 'ctx-save-slot @ } { . } ?! /ctx-slot
    slot-map 'rp-slot in 0 = { slot-map 'rp-slot @ } { . } ?! /rp-slot
    ; Check if we need to restore RP (restore-return=0 on this call)
    node 'restore-return in 0 = { node 'restore-return @ 0 = } { 1 } ?! /needs-restore-rp

    ; Tail call if no ctx-slot and no rp-slot
    ctx-slot isNil rp-slot isNil and! /is-tail-call

    ; Enter frame if needed for saves
    addr entered /cur-entered /cur-addr
    ctx-slot isNil { cur-addr cur-entered } {
      cur-addr cur-entered maybe-enter!
    } ?! /cur-entered /cur-addr
    rp-slot isNil { cur-addr cur-entered } {
      cur-addr cur-entered maybe-enter!
    } ?! /cur-entered /cur-addr

    ; Emit context save before call (if needed)
    ctx-slot isNil { cur-addr } {
      [ ocSaveContextPtr ocPopLocal ctx-slot ] cur-addr emit-all-at!
    } ?! /cur-addr
    ; Emit RP save before first non-tail call (check rp-save-done marker)
    slot-map 'rp-save-done in 1 = rp-slot isNil not! and! /do-save-rp
    do-save-rp {
      [ ocSaveReturnPtr ocPopLocal rp-slot ] cur-addr emit-all-at!
    } { cur-addr } ?! /cur-addr
    ; Update slot-map with marker if we saved
    do-save-rp { slot-map 0 'rp-save-done : } { slot-map } ?! /new-slot-map

    ; Emit call or tailcall
    is-tail-call {
      ; Tail call: use tailcall (preserves RP), and emit leaveFrame before if needed
      cur-addr cur-entered maybe-enter! /cur-entered /cur-addr
      cur-entered 0 = max-slots 0 > and! {
        ocLeaveFrame cur-addr emit-at! max-slots swap! emit-at!
      } { cur-addr } ?! /cur-addr
      ocTailCall cur-addr emit-at! /cur-addr
      ; Return entered=2 to signal seq-impl to skip return
      node cur-addr 2 new-slot-map deferred
    } {
      ; Non-tail call: use regular call with restores
      ocCall cur-addr emit-at! /cur-addr

      ; Emit RP restore after call (only if restore-return=0)
      needs-restore-rp {
        [ ocPushLocal rp-slot ocRestoreReturnPtr ] cur-addr emit-all-at!
      } { cur-addr } ?! /cur-addr
      ; Emit context restore after call (if needed)
      ctx-slot isNil { cur-addr } {
        [ ocPushLocal ctx-slot ocRestoreContextPtr ] cur-addr emit-all-at!
      } ?! /cur-addr

      ; Emit leaveFrame after all restores if needed
      cur-addr cur-entered maybe-leave! new-slot-map deferred
    } ?!
  } {
  ; isOperator throws on non-identifiers, so guard with isIdent (using conditional to short-circuit)
  term isIdent 0 = { term isOperator 0 = } { 1 } ?! {
    ; Operator: look up opcode number from op-table
    ocOp addr emit-at! op-table term @ swap! emit-at! entered maybe-leave! slot-map deferred
  } {
  term isFunc {
    ; Closure: emit context-building code, defer inner function compilation
    node 'free-vars-array @ /inner-free-arr

    ; Emit startArray
    addr ocStartArray swap! emit-at! /cur-addr

    ; For each identifier in free-vars-array, emit code to push its value
    cur-addr inner-free-arr { /ident /a
      ; Look up in current function's slot-map (bound vars) first
      slot-map ident in 0 = {
        ; Bound in current function: pushLocal
        slot-map ident @ /local-slot
        ocPushLocal a emit-at! local-slot swap! emit-at!
      } {
        ; Must be free in current function: pushContext
        free-vars ident @ /ctx-slot
        ocPushContext a emit-at! ctx-slot swap! emit-at!
      } ?!
    } foldl! /cur-addr

    ; Emit endArray
    cur-addr ocEndArray swap! emit-at! /cur-addr

    ; Emit pushInt with placeholder (0), record address for backpatching
    cur-addr /placeholder-addr
    ocPushInt cur-addr emit-at! 0 swap! emit-at! /cur-addr

    ; Call close operator to create bytecodeval
    ocOp cur-addr emit-at! opClose swap! emit-at! /cur-addr

    ; Add to deferred list: (entry, rest) where entry is (patch-addr, (node, (term, nil)))
    ; Build entry: . term , node , patch-addr ,
    ; Then cons onto deferred: deferred entry ,
    deferred . term , node , placeholder-addr 1 + , , /new-deferred

    ; Continue with maybe-leave
    cur-addr entered maybe-leave! slot-map new-deferred
  } {
  term isGen {
    ; Generator: startArray, compile body terms (no return/leaveFrame), endArray
    ; Generators share the current frame (same slot-map, free-vars, max-slots)
    node 'body @ /inner-body

    addr ocStartArray swap! emit-at! /cur-addr

    ; Compile each term in the generator body, but skip leave-frame handling
    ; Use a simple loop instead of seq-fn to avoid emitting return
    { /self /idx /def /sm /ent /a /body-nodes /body-terms
      idx body-terms # = {
        ; Done - return state without emitting return
        a ent sm def
      } {
        ; Get node and remove leave-frame key to prevent leaveFrame emission inside generator
        body-nodes idx @ /term-node
        term-node 'leave-frame in 0 = {
          term-node 'leave-frame delete
        } { term-node } ?! /gen-node
        ; Compile current term with modified node
        body-terms idx @ gen-node max-slots a ent sm free-vars def seq-fn term-fn term-fn!
        /after-def /after-sm /after-ent /after-a
        ; Recurse
        body-terms body-nodes after-a after-ent after-sm after-def idx 1 + self self!
      } ?!
    } /gen-loop
    term inner-body cur-addr entered slot-map deferred 0 gen-loop gen-loop!
    /new-deferred /new-slot-map /new-entered /after-addr

    after-addr ocEndArray swap! emit-at! new-entered maybe-leave! new-slot-map new-deferred
  } {
  term isQuote {
    ; Quoted terms not supported in bytecode
    "error: quoted terms not supported in bytecode" println!
    addr entered slot-map deferred
  } {
    ; Unknown term type - skip
    addr entered maybe-leave! slot-map deferred
  } ?! } ?! } ?! } ?! } ?! } ?! } ?! } ?! } ?! } ?!
} def-fn! /codegen-term-impl

; codegen-seq-impl: (func-body body-arr max-slots addr entered slot-map free-vars deferred idx seq-fn term-fn -- new-addr new-entered new-slot-map new-deferred)
; Process terms from idx to end (left-to-right).
; entered: 0=in frame, 1=not entered, 2=tail call (skip return)
['emit-at 'ocReturn 'ocLeaveFrame 'and 'swap] { /term-fn /seq-fn /idx /deferred /free-vars /slot-map /entered /addr /max-slots /body-arr /func-body
  idx func-body # = {
    ; Done: check if tail call (entered=2) - skip return
    entered 2 = {
      ; Tail call already emitted, no return needed
      addr entered slot-map deferred
    } {
      ; Normal: emit leaveFrame if we entered frame and it wasn't already emitted, then return
      ; entered=0 means we DID enter, max-slots>0 means there's a frame to leave
      entered 0 = max-slots 0 > and! {
        ; We entered a frame and have slots - emit leaveFrame first
        ocLeaveFrame addr emit-at! max-slots swap! emit-at!
      } { addr } ?! /addr
      ocReturn addr emit-at! entered slot-map deferred
    } ?!
  } {
    ; Process current term
    func-body idx @ body-arr idx @ max-slots addr entered slot-map free-vars deferred seq-fn term-fn term-fn!
    /after-deferred /after-slot-map /after-entered /after-addr
    ; Recurse for rest
    func-body body-arr max-slots after-addr after-entered after-slot-map free-vars after-deferred idx 1 + seq-fn term-fn seq-fn!
  } ?!
} def-fn! /codegen-seq-impl

; find-rp-slot: (body-arr -- slot-or-nil)
; Scan body array to find the rp-save-slot from the call with restore-return=0.
{ /self /idx /arr
  idx arr # = { . } {
    arr idx @ /node
    node 'rp-save-slot in 0 = {
      node 'rp-save-slot @
    } {
      arr idx 1 + self self!
    } ?!
  } ?!
} /find-rp-slot-loop
{ /arr arr 0 find-rp-slot-loop find-rp-slot-loop! } /find-rp-slot

; codegen-deferred-impl: (addr deferred seq-fn term-fn self -- final-addr)
; Process deferred closures: compile each and backpatch the placeholder.
['emit-at 'ocEnterFrame 'swap 'find-rp-slot] { /self /term-fn /seq-fn /deferred /addr
  deferred isNil { addr } {
    ; Extract (term, node, patch-addr) from head
    deferred fst /entry
    deferred snd /rest
    entry fst /patch-addr
    entry snd fst /node
    entry snd snd fst /term

    ; Backpatch: write current addr to the placeholder location
    addr patch-addr emit-at! /discard

    ; Compile the inner function body
    node 'body @ /inner-body
    node 'max-slots @ /inner-max
    node 'free-vars @ /inner-free-vars
    ; Enter frame at start if needed
    inner-max 0 > {
      ocEnterFrame addr emit-at! inner-max swap! emit-at! 0
    } { addr 1 } ?! /entered /start-addr
    ; Build initial slot-map with rp-slot if function needs RP saving
    ; Scan body for the call with rp-save-slot
    inner-body find-rp-slot! /rp-slot
    rp-slot isNil { $ } { $ rp-slot 'rp-slot : } ?! /init-slot-map
    term inner-body inner-max start-addr entered init-slot-map inner-free-vars . 0 seq-fn term-fn seq-fn!
    /inner-deferred /discard-slot-map /discard-entered /after-addr

    ; Process any closures deferred from the inner function
    after-addr inner-deferred seq-fn term-fn self self! /after-inner

    ; Continue with rest of deferred list
    after-inner rest seq-fn term-fn self self!
  } ?!
} def-fn! /codegen-deferred-impl

; find-rp-slot: (body-arr -- slot-or-nil)
; Scan body array to find the rp-save-slot from the call with restore-return=0.
{ /self /idx /arr
  idx arr # = { . } {
    arr idx @ /node
    node 'rp-save-slot in 0 = {
      node 'rp-save-slot @
    } {
      arr idx 1 + self self!
    } ?!
  } ?!
} /find-rp-slot-loop
{ /arr arr 0 find-rp-slot-loop find-rp-slot-loop! } /find-rp-slot

; codegen: (addr func closure-node -- next-addr)
; Generate bytecode for a function starting at addr.
; Returns the address after the generated code.
['codegen-seq-impl 'codegen-term-impl 'codegen-deferred-impl 'ocEnterFrame 'emit-at 'swap 'find-rp-slot] { /node /func /addr
  node 'body @ /body
  node 'max-slots @ /max-slots
  node 'free-vars @ /free-vars
  ; Enter frame at start if needed (don't defer - causes issues with non-tail calls)
  max-slots 0 > {
    ocEnterFrame addr emit-at! max-slots swap! emit-at! 0
  } { addr 1 } ?! /entered /start-addr
  ; Build initial slot-map with rp-slot if function needs RP saving
  ; Scan body for the call with rp-save-slot
  body find-rp-slot! /rp-slot
  rp-slot isNil { $ } { $ rp-slot 'rp-slot : } ?! /init-slot-map
  ; Compile main body, collecting deferred closures
  func body max-slots start-addr entered init-slot-map free-vars . 0 codegen-seq-impl codegen-term-impl codegen-seq-impl!
  /deferred /discard-slot-map /discard-entered /after-body
  ; Compile all deferred closures
  after-body deferred codegen-seq-impl codegen-term-impl codegen-deferred-impl codegen-deferred-impl!
} def-fn! /codegen

; Remove impl functions from the environment
env 'codegen-term-impl delete 'codegen-seq-impl delete 'codegen-deferred-impl delete restore

