; list.froth - Cons list utilities
;
; Lists are built from cons cells:
;   .              ; empty list (nil)
;   . 3 , 2 , 1 ,  ; list [1, 2, 3] (1 is head)
;
; Use fst/snd to access head/tail, isNil to test for empty.

; lfoldl: Apply a function to each element head-to-tail, leaving results on stack
; (list fn -- ...results...)
;
; The function may leave zero or more values on the stack per element.
; Use a generator to collect results into an array.
;
; Examples:
;   . 3 , 2 , 1 , {1 +} lfoldl!        ; leaves 2 3 4 on stack
;   [ . 3 , 2 , 1 , {1 +} lfoldl! ]    ; produces [2 3 4]
;   . 3 , 2 , 1 , {print} lfoldl!      ; prints 1, 2, 3

; lfoldl-impl: (xs fn self -- ...results...)
[] {/self /fn /xs
  xs isNil
    {}
    { xs fst fn!
      xs snd fn self self! }
  ?!
} def-fn! /lfoldl-impl

; lfoldl: (list fn -- ...results...)
['lfoldl-impl] {/fn /list
  list fn lfoldl-impl lfoldl-impl!
} def-fn! /lfoldl

; lfoldr: Apply a function to each element tail-to-head, leaving results on stack
; (list fn -- ...results...)
;
; Examples:
;   . 3 , 2 , 1 , {print} lfoldr!      ; prints 3, 2, 1

; lfoldr-impl: (xs fn self -- ...results...)
[] {/self /fn /xs
  xs isNil
    {}
    { xs snd fn self self!
      xs fst fn! }
  ?!
} def-fn! /lfoldr-impl

; lfoldr: (list fn -- ...results...)
['lfoldr-impl] {/fn /list
  list fn lfoldr-impl lfoldr-impl!
} def-fn! /lfoldr

; Remove impl functions from the environment
env 'lfoldl-impl delete 'lfoldr-impl delete restore

; lreverse: Reverse a list
; (list -- list)
;
; Example:
;   . 3 , 2 , 1 , lreverse!  ; produces . 1 , 2 , 3 , (i.e., [3, 2, 1])

['lfoldl] {/xs . xs {,} lfoldl!} def-fn! /lreverse

; lconcat: Concatenate two lists
; (list1 list2 -- list)
;
; Example:
;   . 2 , 1 , . 4 , 3 , lconcat!  ; produces . 4 , 3 , 2 , 1 , (i.e., [1, 2, 3, 4])

['lreverse 'lfoldl] {/xs2 /xs1
  xs2 xs1 lreverse! {,} lfoldl!
} def-fn! /lconcat

; lmap: Apply function to each element, returning a new list
; (list fn -- list)
;
; Example:
;   . 3 , 2 , 1 , {1 +} lmap!  ; produces . 4 , 3 , 2 , (i.e., [2, 3, 4])

['lfoldr] {/fn /xs
  . xs {fn! ,} lfoldr!
} def-fn! /lmap

; llength: Get the length of a list
; (list -- int)
;
; Example:
;   . 3 , 2 , 1 , llength!  ; produces 3

; llength-impl: (xs acc self -- int)
[] {/self /acc /xs
  xs isNil { acc } { xs snd acc 1 + self self! } ?!
} def-fn! /llength-impl

['llength-impl] {/xs xs 0 llength-impl llength-impl!} def-fn! /llength

; Remove impl function
env 'llength-impl delete restore

; lsplit: Split a list into two halves
; (list -- left right)
;
; For a list of length n, left gets floor(n/2) elements, right gets the rest.
;
; Example:
;   . 4 , 3 , 2 , 1 , lsplit!  ; produces (. 2 , 1 ,) (. 4 , 3 ,)

; lsplit-impl: (xs n acc self -- left right)
; Takes first n elements into acc (reversed), returns (acc rest)
[] {/self /acc /n /xs
  n 0 = { acc xs } {
    xs snd n 1 - acc xs fst , self self!
  } ?!
} def-fn! /lsplit-impl

['llength 'lsplit-impl 'lreverse] {/xs
  xs llength! 2 div /half
  xs half . lsplit-impl lsplit-impl! /right /left-rev
  left-rev lreverse! right
} def-fn! /lsplit

; Remove impl function
env 'lsplit-impl delete restore

; lmerge: Merge two sorted lists using a key function
; (list1 list2 key-fn -- merged-list)
;
; The key function extracts a comparable integer from each element.
; Elements are merged in ascending order of their keys.
;
; Example:
;   . 3 , 1 , . 4 , 2 , {} lmerge!  ; produces . 4 , 3 , 2 , 1 , (i.e., [1,2,3,4])

; lmerge-impl: (xs ys key-fn self -- merged-list)
[] {/self /key-fn /ys /xs
  xs isNil { ys } {
  ys isNil { xs } {
    xs fst key-fn! /kx
    ys fst key-fn! /ky
    kx ky < {
      ; xs head is smaller, take it
      xs snd ys key-fn self self! xs fst ,
    } {
      ; ys head is smaller or equal, take it
      xs ys snd key-fn self self! ys fst ,
    } ?!
  } ?! } ?!
} def-fn! /lmerge-impl

['lmerge-impl] {/key-fn /ys /xs
  xs ys key-fn lmerge-impl lmerge-impl!
} def-fn! /lmerge

; Remove impl function
env 'lmerge-impl delete restore

; lsort-by: Sort a list using merge sort with a key function
; (list key-fn -- sorted-list)
;
; The key function extracts a comparable integer from each element.
; Elements are sorted in ascending order of their keys.
;
; Examples:
;   . 3 , 1 , 2 , {} lsort-by!          ; produces . 3 , 2 , 1 , (i.e., [1,2,3])
;   . 'c , 'a , 'b , {intern} lsort-by! ; sort by intern id

; lsort-by-impl: (xs key-fn self -- sorted-list)
['lsplit 'lmerge] {/self /key-fn /xs
  xs isNil { . } {
  xs snd isNil { xs } {
    ; Split, sort recursively, merge
    xs lsplit! /right /left
    left key-fn self self! /sorted-left
    right key-fn self self! /sorted-right
    sorted-left sorted-right key-fn lmerge!
  } ?! } ?!
} def-fn! /lsort-by-impl

['lsort-by-impl] {/key-fn /xs
  xs key-fn lsort-by-impl lsort-by-impl!
} def-fn! /lsort-by

; Remove impl function
env 'lsort-by-impl delete restore
