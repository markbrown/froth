; array.froth - Array utilities

; foldl: Apply a function to each element left-to-right, leaving results on stack
; (arr fn -- ...results...)
;
; The function may leave zero or more values on the stack per element.
; Use a generator to collect results into an array.
;
; Examples:
;   [1 2 3] {1 +} foldl!        ; leaves 2 3 4 on stack
;   [ [1 2 3] {1 +} foldl! ]    ; produces [2 3 4]
;   [1 2 3] {/x x x} foldl!     ; duplicates: leaves 1 1 2 2 3 3

; foldl-impl: (idx arr fn self -- ...results...)
[] {/self /fn /arr /idx
  idx arr # =
    {}
    { arr idx @ fn!
      idx 1 + arr fn self self! }
  ?!
} def-fn! /foldl-impl

; foldl: (arr fn -- ...results...)
['foldl-impl] {/fn /arr
  0 arr fn foldl-impl foldl-impl!
} def-fn! /foldl

; foldr: Apply a function to each element right-to-left, leaving results on stack
; (arr fn -- ...results...)
;
; Examples:
;   [1 2 3] {print} foldr!      ; prints 3, 2, 1

; foldr-impl: (idx arr fn self -- ...results...)
[] {/self /fn /arr /idx
  idx 0 <
    {}
    { arr idx @ fn!
      idx 1 - arr fn self self! }
  ?!
} def-fn! /foldr-impl

; foldr: (arr fn -- ...results...)
['foldr-impl] {/fn /arr
  arr # 1 - arr fn foldr-impl foldr-impl!
} def-fn! /foldr

; Remove impl functions from the environment
env 'foldl-impl delete 'foldr-impl delete restore

; reverse: Reverse an array
; (arr -- arr)
;
; Example:
;   [1 2 3] reverse!  ; produces [3 2 1]

; reverse: (arr -- arr)
['foldr] { /arr [ arr {} foldr! ] } def-fn! /reverse

; map: Apply a function to each element, returning a new array
; (arr fn -- arr)
;
; Example:
;   [1 2 3] {1 +} map!  ; produces [2 3 4]

; map: (arr fn -- arr)
['foldl] { /fn /arr [ arr fn foldl! ] } def-fn! /map

; filter: Keep elements where predicate returns 0 (true)
; (arr fn -- arr)
;
; Example:
;   [1 2 3 4] {2 >} filter!  ; produces [3 4]

; filter: (arr fn -- arr)
['foldl] { /fn /arr [ arr { /x x fn! { x } {} ?! } foldl! ] } def-fn! /filter

; reduce: Reduce array to single value using binary function
; (arr init fn -- result)
;
; Example:
;   [1 2 3] 0 {+} reduce!  ; produces 6

; reduce: (arr init fn -- result)
['foldl] { /fn /acc /arr acc arr fn foldl! } def-fn! /reduce

; concat: Concatenate two arrays
; (arr1 arr2 -- arr)
;
; Example:
;   [1 2] [3 4] concat!  ; produces [1 2 3 4]

; concat: (arr1 arr2 -- arr)
['foldl] { /arr2 /arr1 [ arr1 {} foldl! arr2 {} foldl! ] } def-fn! /concat

; flatten: Flatten an array of arrays into a single array
; (arr-of-arrs -- arr)
;
; Example:
;   [[1 2] [3 4]] flatten!  ; produces [1 2 3 4]

; flatten: (arr-of-arrs -- arr)
['reduce 'concat] { [] {concat!} reduce! } def-fn! /flatten

; scanl: Iterate left-to-right until predicate returns zero
; (arr fn -- 0 | 1)
;
; Applies fn to each element. If fn returns 0, stops and returns 0.
; If fn returns non-zero, continues to next element.
; Returns 1 if no element causes fn to return 0.
;
; Example:
;   [1 2 3] {3 =} scanl!  ; returns 0 (found 3)
;   [1 2 3] {5 =} scanl!  ; returns 1 (not found)

; scanl-impl: (idx arr fn self -- 0 | 1)
[] {/self /fn /arr /idx
  idx arr # = {
    1  ; reached end without fn returning 0, return failure
  } {
    arr idx @ fn! {
      0  ; fn returned 0, found it
    } {
      idx 1 + arr fn self self!  ; fn returned non-0, continue
    } ?!
  } ?!
} def-fn! /scanl-impl

; scanl: (arr fn -- 0 | 1)
['scanl-impl] {/fn /arr
  0 arr fn scanl-impl scanl-impl!
} def-fn! /scanl

; scanr: Iterate right-to-left until predicate returns zero
; (arr fn -- 0 | 1)
;
; Same as scanl but iterates from end to start.
;
; Example:
;   [1 2 3] {1 =} scanr!  ; returns 0 (found 1)

; scanr-impl: (idx arr fn self -- 0 | 1)
[] {/self /fn /arr /idx
  idx 0 < {
    1  ; reached start without fn returning 0, return failure
  } {
    arr idx @ fn! {
      0  ; fn returned 0, found it
    } {
      idx 1 - arr fn self self!  ; fn returned non-0, continue
    } ?!
  } ?!
} def-fn! /scanr-impl

; scanr: (arr fn -- 0 | 1)
['scanr-impl] {/fn /arr
  arr # 1 - arr fn scanr-impl scanr-impl!
} def-fn! /scanr

; Remove impl functions from the environment
env 'scanl-impl delete 'scanr-impl delete restore

; contains: Check if array contains an element
; (arr x -- 0 | 1)
;
; Returns 0 if found, 1 if not found.
;
; Example:
;   [1 2 3] 2 contains!  ; returns 0 (found)
;   [1 2 3] 5 contains!  ; returns 1 (not found)

; contains: (arr x -- 0 | 1)
['scanl] {/x /arr
  arr {x =} scanl!
} def-fn! /contains
