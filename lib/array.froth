; array.froth - Array utilities

; foldl: Apply a function to each element left-to-right, leaving results on stack
; (arr fn -- ...results...)
;
; The function may leave zero or more values on the stack per element.
; Use a generator to collect results into an array.
;
; Examples:
;   [1 2 3] {1 +} foldl!        ; leaves 2 3 4 on stack
;   [ [1 2 3] {1 +} foldl! ]    ; produces [2 3 4]
;   [1 2 3] {/x x x} foldl!     ; duplicates: leaves 1 1 2 2 3 3

; foldl-impl: (idx arr fn self -- ...results...)
[] {/self /fn /arr /idx
  idx arr # =
    {}
    { arr idx @ fn!
      idx 1 + arr fn self self! }
  ?!
} def-fn! /foldl-impl

; foldl: (arr fn -- ...results...)
['foldl-impl] {/fn /arr
  0 arr fn foldl-impl foldl-impl!
} def-fn! /foldl

; foldr: Apply a function to each element right-to-left, leaving results on stack
; (arr fn -- ...results...)
;
; Examples:
;   [1 2 3] {print} foldr!      ; prints 3, 2, 1

; foldr-impl: (idx arr fn self -- ...results...)
[] {/self /fn /arr /idx
  idx 0 <
    {}
    { arr idx @ fn!
      idx 1 - arr fn self self! }
  ?!
} def-fn! /foldr-impl

; foldr: (arr fn -- ...results...)
['foldr-impl] {/fn /arr
  arr # 1 - arr fn foldr-impl foldr-impl!
} def-fn! /foldr

; Remove impl functions from the environment
env 'foldl-impl delete 'foldr-impl delete restore

; reverse: Reverse an array
; (arr -- arr)
;
; Example:
;   [1 2 3] reverse!  ; produces [3 2 1]

; reverse: (arr -- arr)
['foldr] { /arr [ arr {} foldr! ] } def-fn! /reverse

; map: Apply a function to each element, returning a new array
; (arr fn -- arr)
;
; Example:
;   [1 2 3] {1 +} map!  ; produces [2 3 4]

; map: (arr fn -- arr)
['foldl] { /fn /arr [ arr fn foldl! ] } def-fn! /map

; filter: Keep elements where predicate returns 0 (true)
; (arr fn -- arr)
;
; Example:
;   [1 2 3 4] {2 >} filter!  ; produces [3 4]

; filter: (arr fn -- arr)
['foldl] { /fn /arr [ arr { /x x fn! { x } {} ?! } foldl! ] } def-fn! /filter

; reduce: Reduce array to single value using binary function
; (arr init fn -- result)
;
; Example:
;   [1 2 3] 0 {+} reduce!  ; produces 6

; reduce: (arr init fn -- result)
['foldl] { /fn /acc /arr acc arr fn foldl! } def-fn! /reduce

; concat: Concatenate two arrays
; (arr1 arr2 -- arr)
;
; Example:
;   [1 2] [3 4] concat!  ; produces [1 2 3 4]

; concat: (arr1 arr2 -- arr)
['foldl] { /arr2 /arr1 [ arr1 {} foldl! arr2 {} foldl! ] } def-fn! /concat

; flatten: Flatten an array of arrays into a single array
; (arr-of-arrs -- arr)
;
; Example:
;   [[1 2] [3 4]] flatten!  ; produces [1 2 3 4]

; flatten: (arr-of-arrs -- arr)
['reduce 'concat] { [] {concat!} reduce! } def-fn! /flatten
