; slots.froth - Frame slot allocation for compiler
; Frame slot allocation for Froth compiler

; slots-term-impl: (term live-map slot-map free max seq-fn term-fn -- result-map new-slot-map new-free new-max)
; Allocate a slot for a single term.
; live-map: liveness map for this term (has 'is-used, 'is-live, 'body, 'dead-set, etc.)
; slot-map: identifier -> slot mapping
; free: cons list of free slots (nil if empty)
; max: next slot number to allocate if free list is empty
['delete-keys 'reduce 'swap 'and] { /term-fn /seq-fn /max /free /slot-map /live-map /term
  term isBinder {
    ; Binder: allocate slot if used (is-used=0), else no slot
    term intern idToIdent /ident
    live-map 'is-used @ 0 = {
      ; Used binder: allocate slot
      free isNil {
        ; No free slots, allocate new one
        live-map max 'slot : slot-map max ident : free max 1 +
      } {
        ; Pop from free list (cons cell)
        free fst /slot
        free snd /new-free
        live-map slot 'slot : slot-map slot ident : new-free max
      } ?!
    } {
      ; Dead binder: no slot needed
      live-map slot-map free max
    } ?!
  } {
  term isFunc {
    ; Closure: fresh frame (own slot space)
    live-map 'body @ /inner-body
    live-map 'dead-set @ /dead-set
    term # 1 - /last-idx
    term inner-body $ . 0 0 seq-fn term-fn seq-fn!
    /inner-max /discard-free /discard-slot-map /new-body
    ; Free slots for vars in dead-set (their last use was this capture)
    ; Only free if variable is bound (has a slot) - free vars don't have slots
    dead-set keys free { /v /f
      slot-map v in {
        ; v IS in slot-map (bound var) - free its slot
        slot-map v @ f swap! ,
      } {
        ; v is NOT in slot-map (free var) - nothing to free
        f
      } ?!
    } reduce! /new-free
    ; Return map with updated body and max-slots
    live-map new-body 'body : inner-max 'max-slots : slot-map new-free max
  } {
  term isGen {
    ; Generator: same frame, but binders are locally scoped
    live-map 'body @ /inner-body
    live-map 'bound-set @ /inner-bound-set
    inner-bound-set keys /bound-vars
    term # 1 - /last-idx
    ; Thread state through generator
    term inner-body slot-map free max 0 seq-fn term-fn seq-fn!
    /after-max /after-free /after-slot-map /new-body
    ; Remove inner binders from slot-map (out of scope)
    after-slot-map bound-vars delete-keys! /new-slot-map
    live-map new-body 'body : new-slot-map after-free after-max
  } {
  ; Check for bound identifier (has 'is-bound key with value 0)
  term isIdent live-map 'is-bound in 0 = and! {
    live-map 'is-bound @ 0 = {
      ; Bound identifier: lookup slot
      slot-map term @ /slot
      live-map 'is-live @ 1 = {
        ; Last use: add slot to free list
        live-map slot 'slot : slot-map free slot , max
      } {
        ; Still live
        live-map slot 'slot : slot-map free max
      } ?!
    } {
      ; Free identifier (is-bound = 1): no frame slot
      live-map slot-map free max
    } ?!
  } {
  term isApply {
    ; Apply: allocate slots for register saves if needed
    ; Slots are allocated then immediately freed (only used during this call)

    ; Allocate ctx-save-slot if restore-context=0
    ; Returns: (result-map ctx-slot cur-free cur-max)
    live-map 'restore-context in 0 = {
      live-map 'restore-context @ 0 = {
        free isNil {
          ; Allocate new slot
          live-map max 'ctx-save-slot : max free max 1 +
        } {
          ; Reuse from free list
          free fst /slot
          live-map slot 'ctx-save-slot : slot free snd max
        } ?!
      } {
        ; Key exists but value is not 0
        live-map . free max
      } ?!
    } {
      ; Key doesn't exist
      live-map . free max
    } ?! /cur-max /cur-free /ctx-slot /result-map

    ; Allocate rp-save-slot if restore-return=0
    ; Returns: (result-map rp-slot cur-free cur-max)
    result-map 'restore-return in 0 = {
      result-map 'restore-return @ 0 = {
        cur-free isNil {
          ; Allocate new slot
          result-map cur-max 'rp-save-slot : cur-max cur-free cur-max 1 +
        } {
          ; Reuse from free list
          cur-free fst /slot
          result-map slot 'rp-save-slot : slot cur-free snd cur-max
        } ?!
      } {
        result-map . cur-free cur-max
      } ?!
    } {
      result-map . cur-free cur-max
    } ?! /final-max /final-free /rp-slot /final-map

    ; Free the allocated slots (push back to free list)
    final-free /new-free
    ctx-slot isNil { } { ctx-slot new-free swap! , /new-free } ?!
    rp-slot isNil { } { rp-slot new-free swap! , /new-free } ?!

    final-map slot-map new-free final-max
  } {
    ; Not an identifier, or operator: no slot
    live-map slot-map free max
  } ?! } ?! } ?! } ?! } ?!
} def-fn! /slots-term-impl

; slots-seq-impl: (func-body body-arr slot-map free max idx seq-fn term-fn -- new-body-arr new-slot-map new-free new-max)
; Process terms from idx to end (left-to-right).
['concat] { /term-fn /seq-fn /idx /max /free /slot-map /body-arr /func-body
  idx func-body # = {
    ; Done
    [] slot-map free max
  } {
    ; Process current term
    func-body idx @ body-arr idx @ slot-map free max seq-fn term-fn term-fn!
    /after-max /after-free /after-slot-map /term-map
    ; Recurse for rest
    func-body body-arr after-slot-map after-free after-max idx 1 + seq-fn term-fn seq-fn!
    /final-max /final-free /final-slot-map /rest-body
    ; Prepend current result
    [term-map] rest-body concat! final-slot-map final-free final-max
  } ?!
} def-fn! /slots-seq-impl

; slots: (func liveness-node -- func slots-node)
; Allocate frame slots for a function.
; Adds 'slot key to binders and bound identifiers.
; Adds 'max-slots key to closures.
['slots-seq-impl 'slots-term-impl] { /live-map /func
  live-map 'body @ /body
  func body $ . 0 0 slots-seq-impl slots-term-impl slots-seq-impl!
  /max /free /slot-map /new-body
  func live-map new-body 'body : max 'max-slots :
} def-fn! /slots

; Remove impl functions
env 'slots-term-impl delete 'slots-seq-impl delete restore
