; control.froth - Control flow utilities
;
; State is passed through the stack, not through bindings.
; This is necessary because Froth! closures capture the environment at
; creation time, and bindings don't escape closure boundaries.

; while: ( cond body -- )
; Execute body while cond returns 0 (true).
; cond: ( -- flag ) returns 0 to continue, non-zero to stop
; body: ( -- ) executed each iteration
;
; NOTE: Captured variables are NOT updated between iterations because closures
; capture their environment at creation time. Use while-loop for stateful loops.
{ /self /cond /body
  cond! {
    body!
    body cond self self!
  } { } ?!
} /while-impl

['while-impl] { /body /cond body cond while-impl while-impl! } def-fn! /while

; while-loop: ( state cond body -- state' )
; Loop with state passed through the stack.
; cond: ( state -- state flag ) examines state, returns flag (0=continue)
; body: ( state -- state' ) transforms state
; Example: 0 { dup! 5 < } { dup! print " " print 1 + } while-loop! drop! nl!
{ /self /body /cond
  ; state is on stack
  cond! {
    body!
    cond body self self!
  } { } ?!
} /while-loop-impl

['while-loop-impl] { /body /cond cond body while-loop-impl while-loop-impl! } def-fn! /while-loop

; until: ( cond body -- )
; Execute body until cond returns 0 (true).
; cond: ( -- flag ) returns 0 to stop, non-zero to continue
; body: ( -- ) executed each iteration
;
; NOTE: Captured variables are NOT updated between iterations. Use until-loop
; for stateful loops.
{ /self /cond /body
  cond! {
  } {
    body!
    body cond self self!
  } ?!
} /until-impl

['until-impl] { /body /cond body cond until-impl until-impl! } def-fn! /until

; until-loop: ( state cond body -- state' )
; Loop with state passed through the stack.
; cond: ( state -- state flag ) examines state, returns flag (0=stop)
; body: ( state -- state' ) transforms state
; Example: 0 { dup! 5 = } { dup! print " " print 1 + } until-loop! drop! nl!
{ /self /body /cond
  ; state is on stack
  cond! {
  } {
    body!
    cond body self self!
  } ?!
} /until-loop-impl

['until-loop-impl] { /body /cond cond body until-loop-impl until-loop-impl! } def-fn! /until-loop

; times: ( n body -- )
; Execute body n times.
; Example: 5 { "hello" println! } times!
{ /self /n /body
  n 0 > {
    body!
    body n 1 - self self!
  } { } ?!
} /times-impl

['times-impl] { /body /n body n times-impl times-impl! } def-fn! /times

; times-loop: ( state n body -- state' )
; Execute body n times with state passed through the stack.
; body: ( state -- state' )
; Example: 0 5 { 1 + } times-loop!  ; returns 5
{ /self /body /n
  ; state is on stack
  n 0 > {
    body!
    n 1 - body self self!
  } { } ?!
} /times-loop-impl

['times-loop-impl] { /body /n n body times-loop-impl times-loop-impl! } def-fn! /times-loop

; Clean up impl functions
env 'while-impl delete 'until-impl delete 'times-impl delete restore
env 'while-loop-impl delete 'until-loop-impl delete 'times-loop-impl delete restore
