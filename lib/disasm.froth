; disasm.froth - Bytecode disassembler

; Build reverse instruction table (code -> name) as an array
; Index is opcode, value is quoted identifier
[
  'abort              ; 0
  'push-int           ; 1
  'op                 ; 2
  'return             ; 3
  'push-string        ; 4
  'push-context       ; 5
  'pop-unused         ; 6
  'push-local         ; 7
  'pop-local          ; 8
  'enter-frame        ; 9
  'leave-frame        ; 10
  'start-array        ; 11
  'end-array          ; 12
  'call               ; 13
  'save-rp            ; 14
  'restore-rp         ; 15
  'save-ctx           ; 16
  'restore-ctx        ; 17
  'tail-call          ; 18
  'push-quoted-apply  ; 19
] /instr-names

; Build reverse operator table (code -> name) as an array
[
  'print     ; 0
  'env       ; 1
  '+         ; 2
  '-         ; 3
  '*         ; 4
  '>         ; 5
  '<         ; 6
  '>=        ; 7
  '<=        ; 8
  '@         ; 9
  '#         ; 10
  '=         ; 11
  '?         ; 12
  '.         ; 13
  ',         ; 14
  'fst       ; 15
  'snd       ; 16
  'write     ; 17
  'fwrite    ; 18
  '$         ; 19
  'keys      ; 20
  ':         ; 21
  'in        ; 22
  'delete    ; 23
  'isInt     ; 24
  'isString  ; 25
  'isArray   ; 26
  'isMap     ; 27
  'isNil     ; 28
  'isCons    ; 29
  'isIdent   ; 30
  'isBinder  ; 31
  'isFunc    ; 32
  'isGen     ; 33
  'isQuote   ; 34
  'isApply   ; 35
  'isValue   ; 36
  'unwrap    ; 37
  'intern    ; 38
  'idToString  ; 39
  'idToIdent   ; 40
  'idToBinder  ; 41
  'isOperator  ; 42
  'arity       ; 43
  'stack       ; 44
  'import      ; 45
  'time        ; 46
  'restore     ; 47
  'close       ; 48
  'open        ; 49
  'isClosure   ; 50
  'peek        ; 51
  'poke        ; 52
  'ref         ; 53
  'deref       ; 54
  'applyOperator ; 55
  'wrap        ; 56
] /op-names

; Array of whether each instruction has data (0 = yes, 1 = no)
; Indexed by opcode
[
  1  ; 0: abort
  0  ; 1: push-int - has data
  0  ; 2: op - has data
  1  ; 3: return
  0  ; 4: push-string - has data
  0  ; 5: push-context - has data
  1  ; 6: pop-unused
  0  ; 7: push-local - has data
  0  ; 8: pop-local - has data
  0  ; 9: enter-frame - has data
  0  ; 10: leave-frame - has data
  1  ; 11: start-array
  1  ; 12: end-array
  1  ; 13: call
  1  ; 14: save-rp
  1  ; 15: restore-rp
  1  ; 16: save-ctx
  1  ; 17: restore-ctx
  1  ; 18: tail-call
  1  ; 19: push-quoted-apply
] /has-data-array

; Check if opcode has data (0 = yes, 1 = no)
['has-data-array] { /opcode has-data-array opcode @ } def-fn! /has-data

; Disassemble one instruction at addr
; Returns next address
['instr-names 'op-names 'has-data]
{
  /addr
  addr peek /opcode

  ; Print address
  addr print ": " print

  ; Check if valid instruction
  opcode instr-names # < {
    instr-names opcode @ /name
    name print

    ; If instruction has data, print it
    opcode has-data! {
      " " print
      addr 1 + peek /data
      data print

      ; For 'op instruction, also show operator name
      opcode 2 = {
        " (" print
        data op-names # < {
          op-names data @ print
        } {
          "?" print
        } ?!
        ")" print
      } { } ?!

      addr 2 +
    } {
      addr 1 +
    } ?!
  } {
    ; Unknown opcode - print as data
    "data " print opcode print
    addr 1 +
  } ?!

  "\n" print
} def-fn! /disasm-one

; Disassemble n instructions starting at addr (implementation)
; disasm-impl: (addr n self --)
['disasm-one]
{
  /self /n /addr
  n 0 > {
    addr disasm-one! /addr
    addr n 1 - self self!
  } { } ?!
} def-fn! /disasm-impl

; Disassemble n instructions starting at addr
; disasm: (addr n --)
['disasm-impl] { /n /addr addr n disasm-impl disasm-impl! } def-fn! /disasm
