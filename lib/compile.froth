; lib/compile.froth
; High-level compiler interface

; compile-func: (addr func -- next-addr)
; Compile a quoted function to bytecode starting at addr.
; Runs boundness, liveness, slots, and codegen passes.
; Use `close` to create an executable closure from the generated bytecode.
; Call `preflight` first if you need to check for env/import/applyOperator usage.
['boundness 'liveness 'slots 'codegen] {
  boundness! liveness! slots! codegen!
} def-fn! /compile-func

; compile-closure: (addr closure -- next-addr bytecodeval)
; Compile a closure to bytecode, preserving its captured environment.
; Extracts the function body and environment from the closure,
; builds the context array from captured variables, compiles,
; and returns both the next address and the resulting bytecode closure.
['boundness 'liveness 'slots 'codegen 'foldl] { /closure /addr
  closure closureBody /func
  closure closureEnv /env

  ; Run analysis passes
  func boundness! liveness! slots! /node /fn

  ; Build context array from free-vars-array and captured environment
  [ node 'free-vars-array @ { /ident env ident @ } foldl! ] /context

  ; Compile starting at addr
  addr fn node codegen! /next-addr

  ; Return next-addr and bytecode closure
  next-addr context addr close
} def-fn! /compile-closure

; compile: (addr env-map id -- next-addr new-env-map)
; Look up a closure in env-map by id, compile it, and update the map.
; Prints a status message and returns:
; - On success: next-addr and updated map with compiled closure
; - On failure: original addr and map unchanged
['compile-closure 'preflight 'println] { /id /env /addr
  id intern idToString /name
  env id in 0 = {
    ; Found - get the value
    env id @ /val
    val isClosure 0 = {
      ; It's a closure - check preflight
      val closureBody preflight! {
        ; Preflight passed (returns 0) - compile
        addr val compile-closure! /compiled /next-addr
        ["compile: " name " ok"] println!
        next-addr env compiled id :
      } {
        ; Preflight failed (returns 1)
        ["compile: " name " failed preflight"] println!
        addr env
      } ?!
    } {
      ; Not a closure
      ["compile: " name " is not a closure"] println!
      addr env
    } ?!
  } {
    ; Not found
    ["compile: " name " not found"] println!
    addr env
  } ?!
} def-fn! /compile
