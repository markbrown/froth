; compile.froth - Compiler orchestration

; compile-term-impl: (state term shadowed-ops seq-fn term-fn func-fn -- state node)
; Build a node for a single term.
; Recurses into nested functions and generators.
; shadowed-ops: set of operators that are shadowed by binders in outer scope
['make-node] { /func-fn /term-fn /seq-fn /shadowed-ops /term
  term isFunc {
    ; Nested function: recursively compile it with shadowed-ops info
    term shadowed-ops seq-fn term-fn func-fn func-fn!
  } {
  term isGen {
    ; Generator: process body, create generator-node
    ; Generators share outer scope, so pass shadowed-ops through
    term make-node! /node
    term 0 shadowed-ops seq-fn term-fn func-fn seq-fn! /body
    node body 'body :
  } {
    ; Other terms: just create node
    term make-node!
  } ?! } ?!
} def-fn! /compile-term-impl

; compile-seq-impl: (state terms idx shadowed-ops seq-fn term-fn func-fn -- state body-arr)
; Process terms from idx to end (left-to-right).
; Uses list accumulation internally, converts to array at idx=0.
; Tracks binders that shadow operator names and passes them to nested functions.
['lfoldl] { /func-fn /term-fn /seq-fn /shadowed-ops /idx /terms
  idx terms # = {
    ; Base case: empty list
    .
  } {
    ; Process current term with current shadowed-ops
    terms idx @ /term
    term shadowed-ops seq-fn term-fn func-fn term-fn! /node
    ; Update shadowed-ops if this term is a binder for an operator
    term isBinder {
      term intern idToIdent /ident
      ident isOperator {
        ; This binder shadows an operator - add to shadowed-ops
        shadowed-ops . ident :
      } {
        shadowed-ops  ; Not an operator name, keep shadowed-ops unchanged
      } ?!
    } {
      shadowed-ops  ; Not a binder, keep shadowed-ops unchanged
    } ?! /new-shadowed-ops
    ; Recurse for rest (returns a list)
    terms idx 1 + new-shadowed-ops seq-fn term-fn func-fn seq-fn! /rest
    ; Cons node onto rest
    rest node ,
  } ?!
  ; Convert list to array at top level (idx=0)
  idx 0 = { /list [ list { } lfoldl! ] } { } ?!
} def-fn! /compile-seq-impl

; compile-func-impl: (state func shadowed-ops seq-fn term-fn func-fn -- state func-node)
; Build the node tree for a function and run analysis passes.
; Checks code-map for existing node (deduplication via ref ID).
; shadowed-ops: set of operators shadowed by binders in outer scope
['make-node 'tree-get 'tree-set 'boundness 'liveness 'slots 'codegen] { /func-fn /term-fn /seq-fn /shadowed-ops /func /state
  state 'code-map @ /code-map
  func ref /func-id
  code-map func-id tree-get! {
    ; In cache (tree-get returned 0): return cached node
    /cached-node
    state cached-node
  } {
    ; Not in cache (tree-get returned 1): build node, run passes, add to cache
    ; seq-fn returns (state body) - leave state on stack
    ; Pass shadowed-ops to seq-fn so nested functions know about outer shadowed operators
    state func 0 shadowed-ops seq-fn term-fn func-fn seq-fn! /body /state
    ; Run analysis passes
    state 'addr @ func make-node! body 'body : shadowed-ops 'outer-shadowed-ops : boundness! liveness! slots! codegen! /func-node /final-addr
    ; Update state with new addr and code-map
    state 'code-map @ func-id func-node tree-set! /new-code-map
    state new-code-map 'code-map : final-addr 'addr : func-node
  } ?!
} def-fn! /compile-func-impl

; compile-func: (state func -- state func-node)
; Build the node tree for a function and run all compiler passes.
; Pipeline: boundness -> liveness -> slots -> codegen
; Recurses into nested functions to build complete analyzed nodes with bytecode.
; Top-level functions start with empty shadowed-ops set.
['compile-seq-impl 'compile-term-impl 'compile-func-impl] {
  $ compile-seq-impl compile-term-impl compile-func-impl compile-func-impl!
} def-fn! /compile-func

; compile-closure-impl: (state closureval name self -- state bytecodeval)
; Compile a closure to bytecode. Recursively compiles captured closures.
; Uses cache to avoid recompiling the same closure.
{ /self /name /closureval /state
  state 'cache @ name closureval cache-get! {
    ; Found in cache (cache-get returned 0)
    /bytecodeval
    state bytecodeval
  } {
    ; Not found (cache-get returned 1)
    "FROTH: compiled " print name writeln!
    closureval open /body /env

    ; Compile the function body
    state body compile-func! /func-node /state

    ; Get free vars array (with default if not present)
    func-node 'free-vars-array [] get-or! /free-vars

    ; Process free vars, building context
    ; Thread (state ctx-list) through foldl
    state .
    free-vars { /var-name /ctx-list /state
      env var-name @ /value
      value isClosure {
        value open /vbody /venv
        vbody isFunc {
          ; Uncompiled closureval - recursively compile
          state value var-name self self!
          /compiled /state
          state ctx-list compiled ,
        } {
          ; Already compiled (bytecodeval) - use as-is
          state ctx-list value ,
        } ?!
      } {
        ; Not a closure - use as-is
        state ctx-list value ,
      } ?!
    } foldl! /ctx-list /state

    ; Convert context list to array (lfoldr reverses the cons list back to slot order)
    [ ctx-list { } lfoldr! ] /context

    ; Create bytecodeval: context array + func-addr
    context func-node 'func-addr @ close /bytecodeval

    ; Update cache and return
    state 'cache @ name closureval bytecodeval cache-set! /cache
    state cache 'cache : bytecodeval
  } ?!
} /compile-closure-impl

; compile-named-closure: (state closureval name -- state bytecodeval)
; Compile a closure to bytecode with caching.
{ compile-closure-impl compile-closure-impl! } /compile-named-closure

; compile: (state env-map name -- state env-map)
; Look up identifier in env-map, compile it, and update env-map with the result.
{ /name /env-map /state
  env-map name @ /closureval
  state closureval name compile-named-closure!
  /bytecodeval /state
  state env-map bytecodeval name :
} /compile

; Remove impl functions
env 'compile-term-impl delete 'compile-seq-impl delete 'compile-func-impl delete
    'compile-closure-impl delete restore
