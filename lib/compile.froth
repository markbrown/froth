; lib/compile.froth
; High-level compiler interface

; compile-func: (addr func -- next-addr)
; Compile a quoted function to bytecode starting at addr.
; Runs boundness, liveness, slots, and codegen passes.
; Use `close` to create an executable closure from the generated bytecode.
; Call `preflight` first if you need to check for env/import/applyOperator usage.
['boundness 'liveness 'slots 'codegen] {
  boundness! liveness! slots! codegen!
} def-fn! /compile-func

; compile-closure: (addr closure -- next-addr bytecodeval)
; Compile a closure to bytecode, preserving its captured environment.
; Extracts the function body and environment from the closure,
; builds the context array from captured variables, compiles,
; and returns both the next address and the resulting bytecode closure.
['boundness 'liveness 'slots 'codegen 'foldl] { /closure /addr
  closure closureBody /func
  closure closureEnv /env

  ; Run analysis passes
  func boundness! liveness! slots! /node /fn

  ; Build context array from free-vars-array and captured environment
  [ node 'free-vars-array @ { /ident env ident @ } foldl! ] /context

  ; Compile starting at addr
  addr fn node codegen! /next-addr

  ; Return next-addr and bytecode closure
  next-addr context addr close
} def-fn! /compile-closure

; compile-impl: (addr env-map id self -- next-addr new-env-map)
; Internal implementation that takes self for recursion.
['compile-closure 'preflight 'println 'reduce 'fromList 'reverse
 'boundness 'liveness 'slots 'codegen] { /self /id /env /addr
  id intern idToString /name
  env id in 0 = {
    ; Found - get the value
    env id @ /val
    val isClosure 0 = {
      ; It's a closure - check preflight
      val closureBody preflight! {
        ; Preflight passed - compile with dependency handling
        val closureBody /func
        val closureEnv /closure-env

        ; Run analysis passes
        func boundness! liveness! slots! /node /fn

        ; Build context array, compiling closures as needed
        ; Accumulator: [context-list, addr, env, self]
        ; We build context as a cons list (prepending) then reverse
        node 'free-vars-array @ [. addr env self] { /ident /acc
          acc 0 @ /context-list
          acc 1 @ /current-addr
          acc 2 @ /current-env
          acc 3 @ /rec
          closure-env ident @ /cval

          cval isClosure {
            ; It's a closure - check cases
            current-env ident in {
              ; In env-map - check type
              current-env ident @ /env-val
              env-val isClosure {
                ; Closureval in env-map - compile recursively
                current-addr current-env ident rec rec!
                /updated-env /next-addr
                updated-env ident @ /compiled
                [context-list compiled , next-addr updated-env rec]
              } {
                ; Not a closure in env-map
                env-val closureEnv isArray {
                  ; Bytecodeval - use it
                  [context-list env-val , current-addr current-env rec]
                } {
                  ; Not a bytecodeval - compile standalone
                  current-addr cval compile-closure! /compiled /next-addr
                  [context-list compiled , next-addr current-env rec]
                } ?!
              } ?!
            } {
              ; Not in env-map - compile standalone
              current-addr cval compile-closure! /compiled /next-addr
              [context-list compiled , next-addr current-env rec]
            } ?!
          } {
            ; Not a closure - use directly
            [context-list cval , current-addr current-env rec]
          } ?!
        } reduce!
        /result
        result 0 @ /context-list
        result 1 @ /after-deps-addr
        result 2 @ /final-env

        ; Convert list to array and reverse (since we prepended)
        context-list fromList! reverse! /context

        ; Compile the main function
        after-deps-addr fn node codegen! /next-addr

        ; Build bytecodeval and update env
        context after-deps-addr close /compiled
        ["compile: " name " ok"] println!
        next-addr final-env compiled id :
      } {
        ; Preflight failed (returns 1)
        ["compile: " name " failed preflight"] println!
        addr env
      } ?!
    } {
      ; Not a closure
      ["compile: " name " is not a closure"] println!
      addr env
    } ?!
  } {
    ; Not found
    ["compile: " name " not found"] println!
    addr env
  } ?!
} def-fn! /compile-impl

; compile: (addr env-map id -- next-addr new-env-map)
; Look up a closure in env-map by id, compile it, and update the map.
; Recursively compiles any closures in the captured environment that also
; exist in env-map, ensuring shared closures are compiled once.
; Prints a status message and returns:
; - On success: next-addr and updated map with compiled closure
; - On failure: original addr and map unchanged
['compile-impl] { /id /env /addr
  addr env id compile-impl compile-impl!
} def-fn! /compile

; Remove impl from environment
env 'compile-impl delete restore
