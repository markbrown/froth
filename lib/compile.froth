; compile.froth - Compiler orchestration

; compile-term-impl: (code-map addr term shadowed-ops seq-fn term-fn func-fn -- code-map addr node)
; Build a node for a single term.
; Recurses into nested functions and generators.
; shadowed-ops: set of operators that are shadowed by binders in outer scope
['make-node] { /func-fn /term-fn /seq-fn /shadowed-ops /term
  term isFunc {
    ; Nested function: recursively compile it with shadowed-ops info
    term shadowed-ops seq-fn term-fn func-fn func-fn!
  } {
  term isGen {
    ; Generator: process body, create generator-node
    ; Generators share outer scope, so pass shadowed-ops through
    term make-node! /node
    term 0 shadowed-ops seq-fn term-fn func-fn seq-fn! /body
    node body 'body :
  } {
    ; Other terms: just create node
    term make-node!
  } ?! } ?!
} def-fn! /compile-term-impl

; compile-seq-impl: (code-map addr terms idx shadowed-ops seq-fn term-fn func-fn -- code-map addr body-arr)
; Process terms from idx to end (left-to-right).
; Uses list accumulation internally, converts to array at idx=0.
; Tracks binders that shadow operator names and passes them to nested functions.
['lfoldl] { /func-fn /term-fn /seq-fn /shadowed-ops /idx /terms
  idx terms # = {
    ; Base case: empty list
    .
  } {
    ; Process current term with current shadowed-ops
    terms idx @ /term
    term shadowed-ops seq-fn term-fn func-fn term-fn! /node
    ; Update shadowed-ops if this term is a binder for an operator
    term isBinder {
      term intern idToIdent /ident
      ident isOperator {
        ; This binder shadows an operator - add to shadowed-ops
        shadowed-ops . ident :
      } {
        shadowed-ops  ; Not an operator name, keep shadowed-ops unchanged
      } ?!
    } {
      shadowed-ops  ; Not a binder, keep shadowed-ops unchanged
    } ?! /new-shadowed-ops
    ; Recurse for rest (returns a list)
    terms idx 1 + new-shadowed-ops seq-fn term-fn func-fn seq-fn! /rest
    ; Cons node onto rest
    rest node ,
  } ?!
  ; Convert list to array at top level (idx=0)
  idx 0 = { /list [ list { } lfoldl! ] } { } ?!
} def-fn! /compile-seq-impl

; compile-func-impl: (code-map addr func shadowed-ops seq-fn term-fn func-fn -- code-map addr func-node)
; Build the node tree for a function and run analysis passes.
; Checks code-map for existing node (deduplication via ref ID).
; shadowed-ops: set of operators shadowed by binders in outer scope
['make-node 'tree-get 'tree-set 'boundness 'liveness 'slots 'codegen] { /func-fn /term-fn /seq-fn /shadowed-ops /func /addr
  /code-map  ; pop to check cache
  func ref /func-id
  code-map func-id tree-get! {
    ; In cache (tree-get returned 0): return cached node
    /cached-node
    code-map addr cached-node
  } {
    ; Not in cache (tree-get returned 1): build node, run passes, add to cache
    ; "compile-func: " print func write " at " print addr print "\n" print
    ; seq-fn returns (code-map addr body) - leave code-map and addr on stack
    ; Pass shadowed-ops to seq-fn so nested functions know about outer shadowed operators
    code-map addr func 0 shadowed-ops seq-fn term-fn func-fn seq-fn! /body
    ; Stack: new-code-map new-addr
    ; Store outer-shadowed-ops on func-node for boundness to use
    func make-node! body 'body : shadowed-ops 'outer-shadowed-ops : boundness! liveness! slots! codegen!
    ; Stack: new-code-map final-addr func-node
    /func-node /final-addr
    ; Stack: new-code-map
    func-id func-node tree-set! final-addr func-node
    ; Stack: updated-code-map final-addr func-node
  } ?!
} def-fn! /compile-func-impl

; compile-func: (code-map addr func -- code-map addr func-node)
; Build the node tree for a function and run all compiler passes.
; Pipeline: boundness -> liveness -> slots -> codegen
; Recurses into nested functions to build complete analyzed nodes with bytecode.
; Top-level functions start with empty shadowed-ops set.
['compile-seq-impl 'compile-term-impl 'compile-func-impl] {
  $ compile-seq-impl compile-term-impl compile-func-impl compile-func-impl!
} def-fn! /compile-func

; compile-closure-impl: (cache code-map addr closureval name self -- cache code-map addr bytecodeval)
; Compile a closure to bytecode. Recursively compiles captured closures.
; Uses cache to avoid recompiling the same closure.
{ /self /name /closureval /addr /code-map /cache
  cache name closureval cache-get! {
    ; Found in cache (cache-get returned 0)
    /bytecodeval
    cache code-map addr bytecodeval
  } {
    ; Not found (cache-get returned 1)
    "FROTH: compiled " print name writeln!
    closureval open /body /env

    ; Compile the function body
    ; cache stays on stack, compile-func doesn't touch it
    cache code-map addr body compile-func! /func-node /addr /code-map /cache

    ; Get free vars array (with default if not present)
    func-node 'free-vars-array in { func-node 'free-vars-array @ } { [] } ?! /free-vars

    ; Process free vars, building context
    ; Thread (cache code-map addr ctx-list) through foldl
    cache code-map addr .
    free-vars { /var-name /ctx-list /addr /code-map /cache
      env var-name @ /value
      value isClosure {
        value open /vbody /venv
        vbody isFunc {
          ; Uncompiled closureval - recursively compile
          cache code-map addr value var-name self self!
          /compiled /addr /code-map /cache
          cache code-map addr ctx-list compiled ,
        } {
          ; Already compiled (bytecodeval) - use as-is
          cache code-map addr ctx-list value ,
        } ?!
      } {
        ; Not a closure - use as-is
        cache code-map addr ctx-list value ,
      } ?!
    } foldl! /ctx-list /addr /code-map /cache

    ; Convert context list to array (lfoldr reverses the cons list back to slot order)
    [ ctx-list { } lfoldr! ] /context

    ; Create bytecodeval: context array + func-addr
    context func-node 'func-addr @ close /bytecodeval

    ; Update cache and return
    cache name closureval bytecodeval cache-set! code-map addr bytecodeval
  } ?!
} /compile-closure-impl

; compile-named-closure: (cache code-map addr closureval name -- cache code-map addr bytecodeval)
; Compile a closure to bytecode with caching.
{ compile-closure-impl compile-closure-impl! } /compile-named-closure

; compile: (cache code-map addr env-map name -- cache code-map addr env-map)
; Look up identifier in env-map, compile it, and update env-map with the result.
{ /name /env-map /addr /code-map /cache
  env-map name @ /closureval
  cache code-map addr closureval name compile-named-closure!
  /bytecodeval /addr /code-map /cache
  cache code-map addr env-map bytecodeval name :
} /compile

; Remove impl functions
env 'compile-term-impl delete 'compile-seq-impl delete 'compile-func-impl delete
    'compile-closure-impl delete restore
