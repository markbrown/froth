
 * ▐▛███▜▌ *   Claude Code v2.0.74
* ▝▜█████▛▘ *  Opus 4.5 · Claude Max
 *  ▘▘ ▝▝  *   ~/Documents/projects/froth
══════════════════ Conversation compacted · ctrl+o for history ═════════════════

> /compact 
  ⎿  Compacted (ctrl+o to see full summary)
  ⎿  Read eval.m (194 lines)
  ⎿  Read builtins.m (177 lines)
  ⎿  Read froth.m (261 lines)
  ⎿  Read lexer.m (500 lines)
  ⎿  Read types.m (137 lines)

> Let's add `get` and `length` builtins for arrays 

● I'll add get and length builtins for arrays. First let me update builtins.m.

● Update(builtins.m)
  ⎿  Added 3 lines, removed 1 line                                       
      17      ;       bi_env
      18      ;       bi_apply
      19      ;       bi_eval
      20 -    ;       bi_add.                                            
      20 +    ;       bi_add                                             
      21 +    ;       bi_get                                             
      22 +    ;       bi_length.                                         
      23  
      24      % builtin(Name, Builtin):
      25      % Map a name to a builtin operation.

● Update(builtins.m)
  ⎿  Added 2 lines                                                       
      33  :- pred builtin_stack(string_table::in, stack::in, io::di, io::
          uo) is det.
      34  :- pred builtin_env(string_table::in, env::in, io::di, io::uo) 
          is det.
      35  :- pred builtin_add(stack::in, stack::out) is det.
      36 +:- pred builtin_get(stack::in, stack::out) is det.             
      37 +:- pred builtin_length(stack::in, stack::out) is det.          
      38  
      39  %--------------------------------------------------------------
          ---------%
      40  

● Update(builtins.m)
  ⎿  Added 2 lines                                                       
      55  builtin("apply", bi_apply).
      56  builtin("eval", bi_eval).
      57  builtin("add", bi_add).
      58 +builtin("get", bi_get).                                        
      59 +builtin("length", bi_length).                                  
      60  
      61  %--------------------------------------------------------------
          ---------%
      62  % print: pop and print a value

● Update(builtins.m)
  ⎿  Added 31 lines                                                      
      178      ).
      179  
      180  %-------------------------------------------------------------
           ----------%
      181 +% get: get element from array by index                        
      182 +%-------------------------------------------------------------
          +----------%                                                   
      183 +                                                              
      184 +builtin_get(!Stack) :-                                        
      185 +    pop("get", IndexVal, !Stack),                             
      186 +    pop("get", ArrayVal, !Stack),                             
      187 +    ( if ArrayVal = arrayval(Array), IndexVal = intval(Index) 
          +then                                                          
      188 +        ( if array.semidet_lookup(Array, Index, Elem) then    
      189 +            push(Elem, !Stack)                                
      190 +        else                                                  
      191 +            throw(index_out_of_bounds(Index, array.size(Array)
          +))                                                            
      192 +        )                                                     
      193 +    else if ArrayVal = arrayval(_) then                       
      194 +        throw(type_error("int", IndexVal))                    
      195 +    else                                                      
      196 +        throw(type_error("array", ArrayVal))                  
      197 +    ).                                                        
      198 +                                                              
      199 +%-------------------------------------------------------------
          +----------%                                                   
      200 +% length: get length of array                                 
      201 +%-------------------------------------------------------------
          +----------%                                                   
      202 +                                                              
      203 +builtin_length(!Stack) :-                                     
      204 +    pop("length", V, !Stack),                                 
      205 +    ( if V = arrayval(Array) then                             
      206 +        push(intval(array.size(Array)), !Stack)               
      207 +    else                                                      
      208 +        throw(type_error("array", V))                         
      209 +    ).                                                        
      210 +                                                              
      211 +%-------------------------------------------------------------
          +----------%                                                   
      212  :- end_module builtins.
      213  %-------------------------------------------------------------
           ----------%

● Now I need to add the index_out_of_bounds error type to types.m.

● Update(types.m)
  ⎿  Added 2 lines, removed 1 line                                       
      52  :- type eval_error
      53      --->    stack_underflow(string)         % Operation that ca
          used it
      54      ;       type_error(string, value)       % Expected type, ac
          tual value
      55 -    ;       undefined_name(name).                              
      55 +    ;       undefined_name(name)                               
      56 +    ;       index_out_of_bounds(int, int).  % Index, array size
      57  
      58      % format_error(Error) = Message:
      59      % Convert an eval_error to a human-readable message.

● Update(types.m)
  ⎿  Added 2 lines                                                       
      111          [s(Expected), s(value_type_name(Actual))]).
      112  format_error(undefined_name(Name)) =
      113      string.format("undefined name: %s", [s(Name)]).
      114 +format_error(index_out_of_bounds(Index, Size)) =              
      115 +    string.format("index out of bounds: %d (array size: %d)", 
          +[i(Index), i(Size)]).                                         
      116  
      117  :- func value_type_name(value) = string.
      118  

● Now I need to add the cases to eval.m's eval_builtin.

● Update(eval.m)
  ⎿  Added 6 lines                                                       
      115      ;
      116          Builtin = builtins.bi_add,
      117          builtins.builtin_add(!Stack)
      118 +    ;                                                         
      119 +        Builtin = builtins.bi_get,                            
      120 +        builtins.builtin_get(!Stack)                          
      121 +    ;                                                         
      122 +        Builtin = builtins.bi_length,                         
      123 +        builtins.builtin_length(!Stack)                       
      124      ).
      125  
      126  %-------------------------------------------------------------
           ----------%

● Let me compile to check for errors.

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/eval.int3    
     Making Mercury/int3s/types.int3
     Making Mercury/int3s/builtins.int3
     … +17 lines (ctrl+o to expand)

● Now let me run the tests and create a test for the new builtins.

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: binder
     PASS: closure
     … +12 lines (ctrl+o to expand)

● All existing tests pass. Let me add a test for the new builtins.

● Write(tests/array_ops.froth)
  ⎿  Wrote 14 lines to tests/array_ops.froth
      1 # Test array get and length builtins
      2 [10 20 30] /arr
      3 # Length
      4 arr length print
      5 # Get elements by index
      6 arr 0 get print
      7 arr 1 get print
      8 arr 2 get print
     … +4 lines (ctrl+o to expand)

● Write(tests/array_ops.expected)
  ⎿  Wrote 6 lines to tests/array_ops.expected
      1 3
      2 10
      3 20
      4 30
      5 200

● Write(tests/index_error.froth)
  ⎿  Wrote 3 lines to tests/index_error.froth
      1 # Test index out of bounds error
      2 [1 2 3] 5 get

● Write(tests/index_error.expected)
  ⎿  Wrote 2 lines to tests/index_error.expected             
      1 Runtime error: index out of bounds: 5 (array size: 3)

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +14 lines (ctrl+o to expand)

● All 15 tests pass. Let me update FROTH.md to document the new builtins.

● Read(FROTH.md)
  ⎿  Read 147 lines

● Update(FROTH.md)
  ⎿  Added 2 lines                                                       
      86  | `apply` | `( closure -- ... )` | Pop a closure and execute it
           |
      87  | `eval` | `( term -- ... )` | Pop a quoted term and evaluate i
          t |
      88  | `add` | `( a b -- a+b )` | Pop two integers, push their sum |
      89 +| `get` | `( array index -- value )` | Get element at index fro
         +m array |                                                      
      90 +| `length` | `( array -- int )` | Get length of array |        
      91  
      92  ## Examples
      93  

● Update(FROTH.md)
  ⎿  Added 2 lines                                                       
      116  ### Arrays
      117  ```
      118  [ 1 2 3 ] print        # prints 123
      119 +[ 10 20 30 ] length print   # prints 3                        
      120 +[ 10 20 30 ] 1 get print    # prints 20                       
      121  ```
      122  
      123  ### Nested Functions

● Update(FROTH.md)
  ⎿  Added 1 line                                                        
      148  | `stack underflow in 'op'` | Operation `op` needed more value
           s than available |
      149  | `type error: expected T, got U` | Operation expected type T 
           but got type U |
      150  | `undefined name: N` | Name N is not a builtin and not in the
            environment |
      151 +| `index out of bounds: I (array size: S)` | Array index I is 
          +not in range 0..S-1 |                                         

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +14 lines (ctrl+o to expand)

● Done. Added get and length builtins for arrays:

  - get ( array index -- value ) - Get element at index from array
  - length ( array -- int ) - Get length of array

  Also added index_out_of_bounds error type for when the index is out of range. All 15 tests pass.

> Let's add an `eq` builtin to test for equality. It should pop two values 
and place `0` on the stack if they are equal, otherwise place `1` on the 
stack. Throw an exception for closures, or if the types do not match. 

● I'll add the eq builtin. Let me update the files.

● Update(builtins.m)
  ⎿  Added 2 lines, removed 1 line                                       
      19      ;       bi_eval
      20      ;       bi_add
      21      ;       bi_get
      22 -    ;       bi_length.                                         
      22 +    ;       bi_length                                          
      23 +    ;       bi_eq.                                             
      24  
      25      % builtin(Name, Builtin):
      26      % Map a name to a builtin operation.

● Update(builtins.m)
  ⎿  Added 1 line                                                        
      36  :- pred builtin_add(stack::in, stack::out) is det.
      37  :- pred builtin_get(stack::in, stack::out) is det.
      38  :- pred builtin_length(stack::in, stack::out) is det.
      39 +:- pred builtin_eq(stack::in, stack::out) is det.              
      40  
      41  %--------------------------------------------------------------
          ---------%
      42  

● Update(builtins.m)
  ⎿  Added 1 line                                                        
      59  builtin("add", bi_add).
      60  builtin("get", bi_get).
      61  builtin("length", bi_length).
      62 +builtin("eq", bi_eq).                                          
      63  
      64  %--------------------------------------------------------------
          ---------%
      65  % print: pop and print a value

● Update(builtins.m)
  ⎿  Added 55 lines                                                      
      212      ).
      213  
      214  %-------------------------------------------------------------
           ----------%
      215 +% eq: test equality of two values                             
      216 +%-------------------------------------------------------------
          +----------%                                                   
      217 +                                                              
      218 +builtin_eq(!Stack) :-                                         
      219 +    pop("eq", V1, !Stack),                                    
      220 +    pop("eq", V2, !Stack),                                    
      221 +    ( if values_equal(V1, V2, Equal) then                     
      222 +        ( Equal = yes, push(intval(0), !Stack)                
      223 +        ; Equal = no, push(intval(1), !Stack)                 
      224 +        )                                                     
      225 +    else                                                      
      226 +        throw(type_error("matching types", V1))               
      227 +    ).                                                        
      228 +                                                              
      229 +:- import_module bool.                                        
      230 +                                                              
      231 +:- pred values_equal(value::in, value::in, bool::out) is semid
          +et.                                                           
      232 +                                                              
      233 +values_equal(intval(I1), intval(I2), Equal) :-                
      234 +    ( if I1 = I2 then Equal = yes else Equal = no ).          
      235 +values_equal(stringval(Id1), stringval(Id2), Equal) :-        
      236 +    ( if Id1 = Id2 then Equal = yes else Equal = no ).        
      237 +values_equal(arrayval(A1), arrayval(A2), Equal) :-            
      238 +    arrays_equal(A1, A2, Equal).                              
      239 +values_equal(termval(T1), termval(T2), Equal) :-              
      240 +    ( if T1 = T2 then Equal = yes else Equal = no ).          
      241 +% closures: fail (caller will throw)                          
      242 +                                                              
      243 +:- pred arrays_equal(array(value)::in, array(value)::in, bool:
          +:out) is semidet.                                             
      244 +                                                              
      245 +arrays_equal(A1, A2, Equal) :-                                
      246 +    Size1 = array.size(A1),                                   
      247 +    Size2 = array.size(A2),                                   
      248 +    ( if Size1 \= Size2 then                                  
      249 +        Equal = no                                            
      250 +    else                                                      
      251 +        arrays_equal_loop(A1, A2, 0, Size1, Equal)            
      252 +    ).                                                        
      253 +                                                              
      254 +:- pred arrays_equal_loop(array(value)::in, array(value)::in, 
          +int::in, int::in,                                             
      255 +    bool::out) is semidet.                                    
      256 +                                                              
      257 +arrays_equal_loop(A1, A2, I, Size, Equal) :-                  
      258 +    ( if I >= Size then                                       
      259 +        Equal = yes                                           
      260 +    else                                                      
      261 +        array.lookup(A1, I, V1),                              
      262 +        array.lookup(A2, I, V2),                              
      263 +        values_equal(V1, V2, ElemEqual),                      
      264 +        ( ElemEqual = no, Equal = no                          
      265 +        ; ElemEqual = yes, arrays_equal_loop(A1, A2, I + 1, Si
          +ze, Equal)                                                    
      266 +        )                                                     
      267 +    ).                                                        
      268 +                                                              
      269 +%-------------------------------------------------------------
          +----------%                                                   
      270  :- end_module builtins.
      271  %-------------------------------------------------------------
           ----------%

● Update(eval.m)
  ⎿  Added 3 lines                                                       
      121      ;
      122          Builtin = builtins.bi_length,
      123          builtins.builtin_length(!Stack)
      124 +    ;                                                         
      125 +        Builtin = builtins.bi_eq,                             
      126 +        builtins.builtin_eq(!Stack)                           
      127      ).
      128  
      129  %-------------------------------------------------------------
           ----------%

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/eval.int3    
     Making Mercury/int3s/builtins.int3
     Making Mercury/ints/froth.int
     … +9 lines (ctrl+o to expand)

● Now let me add a test.

● Write(tests/eq.froth)
  ⎿  Wrote 34 lines to tests/eq.froth
      1 # Test eq builtin
      2 # Equal integers
      3 1 1 eq print
      4 42 42 eq print
      5 # Unequal integers
      6 1 2 eq print
      7 0 1 eq print
     … +24 lines (ctrl+o to expand)

● Write(tests/eq.expected)
  ⎿  Wrote 13 lines to tests/eq.expected
       1 0
       2 0
       3 1
       4 1
       5 0
       6 1
       7 0
       8 1
       9 1
      10 0
     … +3 lines (ctrl+o to expand)

● Write(tests/eq_closure_error.froth)
  ⎿  Wrote 3 lines to tests/eq_closure_error.froth    
      1 # Test that comparing closures throws an error
      2 { 1 } { 1 } eq

● Write(tests/eq_closure_error.expected)
  ⎿  Wrote 2 lines to tests/eq_closure_error.expected                  
      1 Runtime error: type error: expected matching types, got closure

● Write(tests/eq_type_error.froth)
  ⎿  Wrote 3 lines to tests/eq_type_error.froth              
      1 # Test that comparing different types throws an error
      2 1 "one" eq

● Write(tests/eq_type_error.expected)
  ⎿  Wrote 2 lines to tests/eq_type_error.expected                    
      1 Runtime error: type error: expected matching types, got string

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +17 lines (ctrl+o to expand)

● All 18 tests pass. Let me update FROTH.md.

● Update(FROTH.md)
  ⎿  Added 1 line                                                        
      88  | `add` | `( a b -- a+b )` | Pop two integers, push their sum |
      89  | `get` | `( array index -- value )` | Get element at index fro
          m array |
      90  | `length` | `( array -- int )` | Get length of array |
      91 +| `eq` | `( a b -- int )` | Push 0 if equal, 1 if not equal |  
      92  
      93  ## Examples
      94  

● Done. Added eq builtin:

  - eq ( a b -- int ) - Pops two values, pushes 0 if equal, 1 if not equal
  - Compares integers, strings, arrays (recursively), and terms
  - Throws type error for closures or mismatched types

  All 18 tests pass.

> Let's add an `ite` builtin `( a b c -- d )` where `d` is `b` if `a` is 
`0`, otherwise `d` is `c`. 

● I'll add the ite (if-then-else) builtin.

● Update(builtins.m)
  ⎿  Added 2 lines, removed 1 line                                       
      20      ;       bi_add
      21      ;       bi_get
      22      ;       bi_length
      23 -    ;       bi_eq.                                             
      23 +    ;       bi_eq                                              
      24 +    ;       bi_ite.                                            
      25  
      26      % builtin(Name, Builtin):
      27      % Map a name to a builtin operation.

● Update(builtins.m)
  ⎿  Added 1 line                                                        
      38  :- pred builtin_get(stack::in, stack::out) is det.
      39  :- pred builtin_length(stack::in, stack::out) is det.
      40  :- pred builtin_eq(stack::in, stack::out) is det.
      41 +:- pred builtin_ite(stack::in, stack::out) is det.             
      42  
      43  %--------------------------------------------------------------
          ---------%
      44  

● Update(builtins.m)
  ⎿  Added 1 line                                                        
      62  builtin("get", bi_get).
      63  builtin("length", bi_length).
      64  builtin("eq", bi_eq).
      65 +builtin("ite", bi_ite).                                        
      66  
      67  %--------------------------------------------------------------
          ---------%
      68  % print: pop and print a value

● Update(builtins.m)
  ⎿  Added 16 lines                                                      
      270      ).
      271  
      272  %-------------------------------------------------------------
           ----------%
      273 +% ite: if-then-else                                           
      274 +%-------------------------------------------------------------
          +----------%                                                   
      275 +                                                              
      276 +builtin_ite(!Stack) :-                                        
      277 +    pop("ite", C, !Stack),                                    
      278 +    pop("ite", B, !Stack),                                    
      279 +    pop("ite", A, !Stack),                                    
      280 +    ( if A = intval(0) then                                   
      281 +        push(B, !Stack)                                       
      282 +    else if A = intval(_) then                                
      283 +        push(C, !Stack)                                       
      284 +    else                                                      
      285 +        throw(type_error("int", A))                           
      286 +    ).                                                        
      287 +                                                              
      288 +%-------------------------------------------------------------
          +----------%                                                   
      289  :- end_module builtins.
      290  %-------------------------------------------------------------
           ----------%

● Update(eval.m)
  ⎿  Added 3 lines                                                       
      124      ;
      125          Builtin = builtins.bi_eq,
      126          builtins.builtin_eq(!Stack)
      127 +    ;                                                         
      128 +        Builtin = builtins.bi_ite,                            
      129 +        builtins.builtin_ite(!Stack)                          
      130      ).
      131  
      132  %-------------------------------------------------------------
           ----------%

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/eval.int3    
     Making Mercury/int3s/builtins.int3
     Making Mercury/ints/froth.int
     … +9 lines (ctrl+o to expand)

● Write(tests/ite.froth)
  ⎿  Wrote 18 lines to tests/ite.froth                              
      1 # Test ite (if-then-else) builtin
      2 # Condition is 0, select second argument (then-branch)
      3 0 "yes" "no" ite print
      4 # Condition is non-zero, select third argument (else-branch)
      5 1 "yes" "no" ite print
      6 42 "yes" "no" ite print
      7 -1 "yes" "no" ite print
     … +8 lines (ctrl+o to expand)

● Write(tests/ite.expected)
  ⎿  Wrote 9 lines to tests/ite.expected
      1 yes
      2 no
      3 no
      4 no
      5 100
      6 200
      7 equal
      8 not equal

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +18 lines (ctrl+o to expand)

● Now let me update FROTH.md.

● Update(FROTH.md)
  ⎿  Added 1 line                                                        
      89  | `get` | `( array index -- value )` | Get element at index fro
          m array |
      90  | `length` | `( array -- int )` | Get length of array |
      91  | `eq` | `( a b -- int )` | Push 0 if equal, 1 if not equal |
      92 +| `ite` | `( cond then else -- result )` | If cond is 0, push t
         +hen; otherwise push else |                                     
      93  
      94  ## Examples
      95  

● Done. Added ite builtin:

  - ite ( cond then else -- result ) - If cond is 0, push then; otherwise push else
  - Condition must be an integer (throws type error otherwise)

  All 19 tests pass.

> Let's try interning names in the same way that we have for strings. 

● I'll intern names similar to how we intern strings. Let me update the files.

● Update(types.m)
  ⎿  Added 1 line, removed 1 line                                        
      12  
      13  %--------------------------------------------------------------
          ---------%
      14  
      15 -:- type name == string.                                        
      15 +:- type name_id == int.                                        
      16  
      17  :- type string_id == int.
      18  

● Update(types.m)
  ⎿  Added 8 lines, removed 2 lines                                      
      16  
      17  :- type string_id == int.
      18  
      19 -    % String table: bidirectional mapping between strings and I
         -Ds.                                                            
      20 -    % All strings are interned during lexing.                  
      19 +    % Intern tables: bidirectional mappings between strings/nam
         +es and IDs.                                                    
      20 +    % All strings and names are interned during lexing.        
      21      %
      22  :- type string_table.
      23 +:- type name_table.                                            
      24  
      25  :- func empty_string_table = string_table.
      26  :- pred intern_string(string::in, string_id::out,
      27      string_table::in, string_table::out) is det.
      28  :- func lookup_string(string_table, string_id) = string.
      29  
      30 +:- func empty_name_table = name_table.                         
      31 +:- pred intern_name(string::in, name_id::out,                  
      32 +    name_table::in, name_table::out) is det.                   
      33 +:- func lookup_name(name_table, name_id) = string.             
      34 +                                                               
      35  :- type value
      36      --->    intval(int)
      37      ;       stringval(string_id)

● Update(types.m)
  ⎿  Added 3 lines, removed 3 lines                                      
      40      ;       termval(term).
      41  
      42  :- type term
      43 -    --->    identifier(name)                                   
      44 -    ;       binder(name)                                       
      43 +    --->    identifier(name_id)                                
      44 +    ;       binder(name_id)                                    
      45      ;       function(list(term))
      46      ;       generator(list(term))
      47      ;       quoted(term)
      48      ;       value(value).
      49  
      50 -:- type env == map(name, value).                               
      50 +:- type env == map(name_id, value).                            
      51  
      52  :- type stack == list(value).
      53  

● Update(types.m)
  ⎿  Added 1 line, removed 1 line                                        
      58  :- type eval_error
      59      --->    stack_underflow(string)         % Operation that ca
          used it
      60      ;       type_error(string, value)       % Expected type, ac
          tual value
      61 -    ;       undefined_name(name)                               
      61 +    ;       undefined_name(name_id)                            
      62      ;       index_out_of_bounds(int, int).  % Index, array size
      63  
      64      % format_error(Error) = Message:

● Update(types.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      61      ;       undefined_name(name_id)
      62      ;       index_out_of_bounds(int, int).  % Index, array size
      63  
      64 -    % format_error(Error) = Message:                           
      64 +    % format_error(NameTable, Error) = Message:                
      65      % Convert an eval_error to a human-readable message.
      66      %
      67 -:- func format_error(eval_error) = string.                     
      67 +:- func format_error(name_table, eval_error) = string.         
      68  
      69  %--------------------------------------------------------------
          ---------%
      70  % Stack operations

● Update(types.m)
  ⎿  Added 23 lines                                                      
       92                  st_to_string    :: map(string_id, string)
       93              ).
       94  
       95 +:- type name_table                                            
       96 +    --->    name_table(                                       
       97 +                nt_next_id      :: int,                       
       98 +                nt_to_id        :: map(string, name_id),      
       99 +                nt_to_name      :: map(name_id, string)       
      100 +            ).                                                
      101 +                                                              
      102  empty_string_table = string_table(0, map.init, map.init).
      103  
      104  intern_string(String, Id, !Table) :-
     ...
      115  lookup_string(Table, Id) = String :-
      116      map.lookup(Table ^ st_to_string, Id, String).
      117  
      118 +empty_name_table = name_table(0, map.init, map.init).         
      119 +                                                              
      120 +intern_name(Name, Id, !Table) :-                              
      121 +    ToId0 = !.Table ^ nt_to_id,                               
      122 +    ( if map.search(ToId0, Name, ExistingId) then             
      123 +        Id = ExistingId                                       
      124 +    else                                                      
      125 +        Id = !.Table ^ nt_next_id,                            
      126 +        map.det_insert(Name, Id, ToId0, ToId),                
      127 +        map.det_insert(Id, Name, !.Table ^ nt_to_name, ToName)
          +,                                                             
      128 +        !:Table = name_table(Id + 1, ToId, ToName)            
      129 +    ).                                                        
      130 +                                                              
      131 +lookup_name(Table, Id) = Name :-                              
      132 +    map.lookup(Table ^ nt_to_name, Id, Name).                 
      133 +                                                              
      134  %-------------------------------------------------------------
           ----------%
      135  
      136  format_error(stack_underflow(Op)) =

● Update(types.m)
  ⎿  Added 5 lines, removed 5 lines                                      
      133  
      134  %-------------------------------------------------------------
           ----------%
      135  
      136 -format_error(stack_underflow(Op)) =                           
      136 +format_error(_, stack_underflow(Op)) =                        
      137      string.format("stack underflow in '%s'", [s(Op)]).
      138 -format_error(type_error(Expected, Actual)) =                  
      138 +format_error(_, type_error(Expected, Actual)) =               
      139      string.format("type error: expected %s, got %s",
      140          [s(Expected), s(value_type_name(Actual))]).
      141 -format_error(undefined_name(Name)) =                          
      142 -    string.format("undefined name: %s", [s(Name)]).           
      143 -format_error(index_out_of_bounds(Index, Size)) =              
      141 +format_error(NT, undefined_name(NameId)) =                    
      142 +    string.format("undefined name: %s", [s(lookup_name(NT, Nam
          +eId))]).                                                      
      143 +format_error(_, index_out_of_bounds(Index, Size)) =           
      144      string.format("index out of bounds: %d (array size: %d)", 
           [i(Index), i(Size)]).
      145  
      146  :- func value_type_name(value) = string.

● Now I need to update the lexer to intern names. Let me update lexer.m.

● Update(lexer.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      12  %--------------------------------------------------------------
          ---------%
      13  
      14  :- type token
      15 -    --->    name(string)                                       
      16 -    ;       slash_name(string)      % The string excludes the l
         -eading /                                                       
      15 +    --->    name(name_id)                                      
      16 +    ;       slash_name(name_id)     % The name_id excludes the 
         +leading /                                                      
      17      ;       number(int)
      18      ;       string(string_id)       % Interned string ID
      19      ;       quote                   % The ' character

● Update(lexer.m)
  ⎿  Added 5 lines, removed 4 lines                                      
      40      ;       unterminated_block_comment(position).
      41  
      42  :- type lex_result
      43 -    --->    ok(list(located(token)), string_table)             
      43 +    --->    ok(list(located(token)), string_table, name_table) 
      44      ;       error(lex_error).
      45  
      46 -    % tokenize(Input, StringTable, Result):                    
      46 +    % tokenize(Input, StringTable, NameTable, Result):         
      47      % Tokenize the input string into a list of located tokens.
      48 -    % Takes an initial string table (use empty_string_table for
         - fresh start).                                                 
      48 +    % Takes initial string and name tables (use empty_*_table f
         +or fresh start).                                               
      49      %
      50 -:- pred tokenize(string::in, string_table::in, lex_result::out)
         - is det.                                                       
      50 +:- pred tokenize(string::in, string_table::in, name_table::in, 
      51 +    lex_result::out) is det.                                   
      52  
      53  %--------------------------------------------------------------
          ---------%
      54  

● Update(lexer.m)
  ⎿  Added 2 lines, removed 1 line                                       
      66                  ls_pos      :: int,         % Current position 
          in string
      67                  ls_line     :: int,
      68                  ls_column   :: int,
      69 -                ls_strings  :: string_table                    
      69 +                ls_strings  :: string_table,                   
      70 +                ls_names    :: name_table                      
      71              ).
      72  
      73      % Internal result type to avoid ambiguity with other ok/err
          or types.

● Update(lexer.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      77  
      78  %--------------------------------------------------------------
          ---------%
      79  
      80 -tokenize(Input, StringTable, Result) :-                        
      81 -    State0 = lex_state(Input, 0, 1, 1, StringTable),           
      80 +tokenize(Input, StringTable, NameTable, Result) :-             
      81 +    State0 = lex_state(Input, 0, 1, 1, StringTable, NameTable),
      82      tokenize_loop(State0, [], Result).
      83  
      84  :- pred tokenize_loop(lex_state::in, list(located(token))::in,

● Update(lexer.m)
  ⎿  Added 2 lines, removed 1 line                                       
      89      (
      90          SkipResult = ok(State1),
      91          ( if at_end(State1) then
      92 -            Result = ok(list.reverse(RevTokens), State1 ^ ls_st
         -rings)                                                         
      92 +            Result = ok(list.reverse(RevTokens), State1 ^ ls_st
         +rings,                                                         
      93 +                State1 ^ ls_names)                             
      94          else
      95              Pos = position(State1 ^ ls_line, State1 ^ ls_column
          ),
      96              read_token(State1, Pos, TokenResult),

● Update(lexer.m)
  ⎿  Added 4 lines, removed 2 lines                                      
      261          )
      262      then
      263          read_name_chars(State0, Chars, State1),
      264 -        Name = string.from_char_list(Chars),                  
      265 -        Result = ok({name(Name), State1})                     
      264 +        NameStr = string.from_char_list(Chars),               
      265 +        intern_name(NameStr, NameId, State1 ^ ls_names, NewNam
          +es),                                                          
      266 +        State2 = State1 ^ ls_names := NewNames,               
      267 +        Result = ok({name(NameId), State2})                   
      268      else
      269          % Fall through to junk
      270          read_junk(State0, Result)

● Update(lexer.m)
  ⎿  Added 4 lines, removed 2 lines                                      
      300          )
      301      then
      302          read_name_chars(State0, Chars, State1),
      303 -        Name = string.from_char_list(Chars),                  
      304 -        Result = ok({slash_name(Name), State1})               
      303 +        NameStr = string.from_char_list(Chars),               
      304 +        intern_name(NameStr, NameId, State1 ^ ls_names, NewNam
          +es),                                                          
      305 +        State2 = State1 ^ ls_names := NewNames,               
      306 +        Result = ok({slash_name(NameId), State2})             
      307      else
      308          % Just a slash followed by non-name, treat as junk
      309          % The slash was already consumed, so we return junk("/
           ")

● Now I need to update parser.m to use name_id tokens.

● Read(parser.m)
  ⎿  Read 229 lines

● The parser looks fine - it already passes name IDs through correctly. Now I need to update froth.m and builtins.m to handle the name_table.

● Update(froth.m)
  ⎿  Added 2 lines, removed 1 line                                       
      72      Env0 = map.init,
      73      Stack0 = [],
      74      StringTable0 = empty_string_table,
      75 -    repl_loop(StringTable0, Env0, Stack0, !IO).                
      75 +    NameTable0 = empty_name_table,                             
      76 +    repl_loop(StringTable0, NameTable0, Env0, Stack0, !IO).    
      77  
      78  :- pred repl_loop(string_table::in, env::in, stack::in,
      79      io::di, io::uo) is cc_multi.

● Update(froth.m)
  ⎿  Added 5 lines, removed 5 lines                                      
      75      NameTable0 = empty_name_table,
      76      repl_loop(StringTable0, NameTable0, Env0, Stack0, !IO).
      77  
      78 -:- pred repl_loop(string_table::in, env::in, stack::in,        
      78 +:- pred repl_loop(string_table::in, name_table::in, env::in, st
         +ack::in,                                                       
      79      io::di, io::uo) is cc_multi.
      80  
      81 -repl_loop(StringTable0, Env0, Stack0, !IO) :-                  
      81 +repl_loop(StringTable0, NameTable0, Env0, Stack0, !IO) :-      
      82      io.write_string("> ", !IO),
      83      io.flush_output(!IO),
      84      io.read_line_as_string(ReadResult, !IO),
      85      (
      86          ReadResult = ok(Line),
      87 -        repl_eval(Line, StringTable0, StringTable, Env0, Env, S
         -tack0, Stack,                                                  
      88 -            !IO),                                              
      89 -        repl_loop(StringTable, Env, Stack, !IO)                
      87 +        repl_eval(Line, StringTable0, StringTable, NameTable0, 
         +NameTable,                                                     
      88 +            Env0, Env, Stack0, Stack, !IO),                    
      89 +        repl_loop(StringTable, NameTable, Env, Stack, !IO)     
      90      ;
      91          ReadResult = eof,
      92          io.nl(!IO)

● Update(froth.m)
  ⎿  Added 11 lines, removed 5 lines                                     
       98      ).
       99  
      100  :- pred repl_eval(string::in, string_table::in, string_table::
           out,
      101 +    name_table::in, name_table::out,                          
      102      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is cc_multi.
      103  
      103 -repl_eval(Input, StringTable0, StringTable, Env0, Env, Stack0,
          - Stack, !IO) :-                                               
      104 -    lexer.tokenize(Input, StringTable0, LexResult),           
      104 +repl_eval(Input, StringTable0, StringTable, NameTable0, NameTa
          +ble,                                                          
      105 +        Env0, Env, Stack0, Stack, !IO) :-                     
      106 +    lexer.tokenize(Input, StringTable0, NameTable0, LexResult)
          +,                                                             
      107      (
      106 -        LexResult = ok(Tokens, StringTable1),                 
      108 +        LexResult = ok(Tokens, StringTable1, NameTable1),     
      109          parser.parse(Tokens, ParseResult),
      110          (
      111              ParseResult = ok(Terms),
      110 -            execute_repl(StringTable1, Terms, Env0, Env, Stack
          -0, Stack, !IO),                                               
      111 -            StringTable = StringTable1                        
      112 +            execute_repl(StringTable1, NameTable1, Terms, Env0
          +, Env,                                                        
      113 +                Stack0, Stack, !IO),                          
      114 +            StringTable = StringTable1,                       
      115 +            NameTable = NameTable1                            
      116          ;
      117              ParseResult = error(ParseError),
      118              report_parse_error(ParseError, !IO),
      119              StringTable = StringTable1,
      120 +            NameTable = NameTable1,                           
      121              Env = Env0,
      122              Stack = Stack0
      123          )
     ...
      125          LexResult = error(LexError),
      126          report_lex_error(LexError, !IO),
      127          StringTable = StringTable0,
      128 +        NameTable = NameTable0,                               
      129          Env = Env0,
      130          Stack = Stack0
      131      ).

● Update(froth.m)
  ⎿  Added 6 lines, removed 5 lines                                      
      130          Stack = Stack0
      131      ).
      132  
      133 -:- pred execute_repl(string_table::in, list(term)::in, env::in
          -, env::out,                                                   
      134 -    stack::in, stack::out, io::di, io::uo) is cc_multi.       
      133 +:- pred execute_repl(string_table::in, name_table::in, list(te
          +rm)::in,                                                      
      134 +    env::in, env::out, stack::in, stack::out, io::di, io::uo) 
          +is cc_multi.                                                  
      135  
      136 -execute_repl(StringTable, Terms, Env0, Env, Stack0, Stack, !IO
          -) :-                                                          
      137 -    try_io(eval_terms_wrapper(StringTable, Terms, Env0, Stack0
          -), Result, !IO),                                              
      136 +execute_repl(StringTable, NameTable, Terms, Env0, Env, Stack0,
          + Stack, !IO) :-                                               
      137 +    try_io(eval_terms_wrapper(StringTable, NameTable, Terms, E
          +nv0, Stack0),                                                 
      138 +        Result, !IO),                                         
      139      (
      140          Result = succeeded({Env, Stack})
      141      ;
      142          Result = exception(Exn),
      143          ( if univ_to_type(Exn, EvalError) then
      144              io.format("Runtime error: %s\n",
      144 -                [s(types.format_error(EvalError))], !IO),     
      145 +                [s(types.format_error(NameTable, EvalError))],
          + !IO),                                                        
      146              Env = Env0,
      147              Stack = Stack0
      148          else

● Update(froth.m)
  ⎿  Added 3 lines, removed 3 lines                                      
      171  :- pred run(string::in, io::di, io::uo) is cc_multi.
      172  
      173  run(Input, !IO) :-
      174 -    lexer.tokenize(Input, empty_string_table, LexResult),     
      174 +    lexer.tokenize(Input, empty_string_table, empty_name_table
          +, LexResult),                                                 
      175      (
      176 -        LexResult = ok(Tokens, StringTable),                  
      176 +        LexResult = ok(Tokens, StringTable, NameTable),       
      177          parser.parse(Tokens, ParseResult),
      178          (
      179              ParseResult = ok(Terms),
      180 -            execute(StringTable, Terms, !IO)                  
      180 +            execute(StringTable, NameTable, Terms, !IO)       
      181          ;
      182              ParseResult = error(ParseError),
      183              report_parse_error(ParseError, !IO),

● Update(froth.m)
  ⎿  Added 6 lines, removed 4 lines                                      
      189          io.set_exit_status(1, !IO)
      190      ).
      191  
      192 -:- pred execute(string_table::in, list(term)::in, io::di, io::
          -uo) is cc_multi.                                              
      192 +:- pred execute(string_table::in, name_table::in, list(term)::
          +in,                                                           
      193 +    io::di, io::uo) is cc_multi.                              
      194  
      194 -execute(StringTable, Terms, !IO) :-                           
      195 +execute(StringTable, NameTable, Terms, !IO) :-                
      196      Env0 = map.init,
      197      Stack0 = [],
      197 -    try_io(eval_terms_wrapper(StringTable, Terms, Env0, Stack0
          -), Result, !IO),                                              
      198 +    try_io(eval_terms_wrapper(StringTable, NameTable, Terms, E
          +nv0, Stack0),                                                 
      199 +        Result, !IO),                                         
      200      (
      201          Result = succeeded({_, _})
      202      ;
      203          Result = exception(Exn),
      204          ( if univ_to_type(Exn, EvalError) then
      205              io.format("Runtime error: %s\n",
      204 -                [s(types.format_error(EvalError))], !IO),     
      206 +                [s(types.format_error(NameTable, EvalError))],
          + !IO),                                                        
      207              io.set_exit_status(1, !IO)
      208          else
      209              rethrow(Result)

● Update(froth.m)
  ⎿  Added 6 lines, removed 4 lines                                      
      210          )
      211      ).
      212  
      213 -:- pred eval_terms_wrapper(string_table::in, list(term)::in, e
          -nv::in, stack::in,                                            
      214 -    {env, stack}::out, io::di, io::uo) is det.                
      213 +:- pred eval_terms_wrapper(string_table::in, name_table::in, l
          +ist(term)::in,                                                
      214 +    env::in, stack::in, {env, stack}::out, io::di, io::uo) is 
          +det.                                                          
      215  
      216 -eval_terms_wrapper(StringTable, Terms, Env0, Stack0, {Env, Sta
          -ck}, !IO) :-                                                  
      217 -    eval.eval_terms(StringTable, Terms, Env0, Env, Stack0, Sta
          -ck, !IO).                                                     
      216 +eval_terms_wrapper(StringTable, NameTable, Terms, Env0, Stack0
          +,                                                             
      217 +        {Env, Stack}, !IO) :-                                 
      218 +    eval.eval_terms(StringTable, NameTable, Terms, Env0, Env, 
          +Stack0, Stack,                                                
      219 +        !IO).                                                 
      220  
      221  %-------------------------------------------------------------
           ----------%
      222  % Error reporting

● Now I need to update token_to_string in froth.m - but this requires looking up the name. Let me check the current implementation.

● Read(froth.m)
  ⎿  Read 29 lines

● Update(froth.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      256  
      257  :- func token_to_string(token) = string.
      258  
      259 -token_to_string(name(S)) = string.format("name '%s'", [s(S)]).
      260 -token_to_string(slash_name(S)) = string.format("/%s", [s(S)]).
      259 +token_to_string(name(Id)) = string.format("name#%d", [i(Id)]).
      260 +token_to_string(slash_name(Id)) = string.format("/name#%d", [i
          +(Id)]).                                                       
      261  token_to_string(number(N)) = string.format("number %d", [i(N)]
           ).
      262  token_to_string(string(Id)) = string.format("string#%d", [i(Id
           )]).
      263  token_to_string(quote) = "'''".

● Now I need to update eval.m to take the name_table parameter.

● Update(eval.m)
  ⎿  Added 6 lines, removed 6 lines                                      
      12  
      13  %--------------------------------------------------------------
          ---------%
      14  
      15 -    % eval_terms(StringTable, Terms, !Env, !Stack, !IO):       
      15 +    % eval_terms(StringTable, NameTable, Terms, !Env, !Stack, !
         +IO):                                                           
      16      % Evaluate a list of terms, updating the environment and st
          ack.
      17 -    % StringTable is read-only (all strings known at lex time).
      17 +    % StringTable and NameTable are read-only (all strings/name
         +s known at lex time).                                          
      18      % Throws eval_error on failure.
      19      %
      20 -:- pred eval_terms(string_table::in, list(term)::in, env::in, e
         -nv::out,                                                       
      21 -    stack::in, stack::out, io::di, io::uo) is det.             
      20 +:- pred eval_terms(string_table::in, name_table::in, list(term)
         +::in,                                                          
      21 +    env::in, env::out, stack::in, stack::out, io::di, io::uo) i
         +s det.                                                         
      22  
      23      % Environment operations.
      24      %
      25 -:- pred get_env(name::in, value::out, env::in) is semidet.     
      26 -:- pred set_env(name::in, value::in, env::in, env::out) is det.
      25 +:- pred get_env(name_id::in, value::out, env::in) is semidet.  
      26 +:- pred set_env(name_id::in, value::in, env::in, env::out) is d
         +et.                                                            
      27  
      28  %--------------------------------------------------------------
          ---------%
      29  

● Read(eval.m)
  ⎿  Read 60 lines

● Update(eval.m)
  ⎿  Added 11 lines, removed 11 lines                                    
      48  % Main evaluation
      49  %--------------------------------------------------------------
          ---------%
      50  
      51 -eval_terms(_, [], !Env, !Stack, !IO).                          
      52 -eval_terms(ST, [Term | Terms], !Env, !Stack, !IO) :-           
      53 -    eval_term(ST, Term, !Env, !Stack, !IO),                    
      54 -    eval_terms(ST, Terms, !Env, !Stack, !IO).                  
      51 +eval_terms(_, _, [], !Env, !Stack, !IO).                       
      52 +eval_terms(ST, NT, [Term | Terms], !Env, !Stack, !IO) :-       
      53 +    eval_term(ST, NT, Term, !Env, !Stack, !IO),                
      54 +    eval_terms(ST, NT, Terms, !Env, !Stack, !IO).              
      55  
      56 -:- pred eval_term(string_table::in, term::in, env::in, env::out
         -,                                                              
      56 +:- pred eval_term(string_table::in, name_table::in, term::in, e
         +nv::in, env::out,                                              
      57      stack::in, stack::out, io::di, io::uo) is det.
      58  
      59 -eval_term(ST, Term, !Env, !Stack, !IO) :-                      
      59 +eval_term(ST, NT, Term, !Env, !Stack, !IO) :-                  
      60      (
      61 -        Term = identifier(Name),                               
      62 -        eval_identifier(ST, Name, !Env, !Stack, !IO)           
      61 +        Term = identifier(NameId),                             
      62 +        eval_identifier(ST, NT, NameId, !Env, !Stack, !IO)     
      63      ;
      64 -        Term = binder(Name),                                   
      65 -        eval_binder(Name, !Env, !Stack)                        
      64 +        Term = binder(NameId),                                 
      65 +        eval_binder(NameId, !Env, !Stack)                      
      66      ;
      67          Term = function(Terms),
      68          eval_function(Terms, !.Env, !Stack)
      69      ;
      70          Term = generator(Terms),
      71 -        eval_generator(ST, Terms, !Env, !Stack, !IO)           
      71 +        eval_generator(ST, NT, Terms, !Env, !Stack, !IO)       
      72      ;
      73          Term = quoted(T),
      74          push(termval(T), !Stack)

● Update(eval.m)
  ⎿  Added 8 lines, removed 7 lines                                      
      81  % Identifier evaluation
      82  %--------------------------------------------------------------
          ---------%
      83  
      84 -:- pred eval_identifier(string_table::in, name::in, env::in, en
         -v::out,                                                        
      85 -    stack::in, stack::out, io::di, io::uo) is det.             
      84 +:- pred eval_identifier(string_table::in, name_table::in, name_
         +id::in,                                                        
      85 +    env::in, env::out, stack::in, stack::out, io::di, io::uo) i
         +s det.                                                         
      86  
      87 -eval_identifier(ST, Name, !Env, !Stack, !IO) :-                
      88 -    ( if builtins.builtin(Name, Builtin) then                  
      89 -        eval_builtin(ST, Builtin, !Env, !Stack, !IO)           
      90 -    else if get_env(Name, V, !.Env) then                       
      87 +eval_identifier(ST, NT, NameId, !Env, !Stack, !IO) :-          
      88 +    NameStr = lookup_name(NT, NameId),                         
      89 +    ( if builtins.builtin(NameStr, Builtin) then               
      90 +        eval_builtin(ST, NT, Builtin, !Env, !Stack, !IO)       
      91 +    else if get_env(NameId, V, !.Env) then                     
      92          push(V, !Stack)
      93      else
      93 -        throw(undefined_name(Name))                            
      94 +        throw(undefined_name(NameId))                          
      95      ).
      96  
      97  :- pred eval_builtin(string_table::in, builtins.builtin::in, en
          v::in, env::out,

● Update(eval.m)
  ⎿  Added 8 lines, removed 8 lines                                      
       94          throw(undefined_name(NameId))
       95      ).
       96  
       97 -:- pred eval_builtin(string_table::in, builtins.builtin::in, e
          -nv::in, env::out,                                             
       98 -    stack::in, stack::out, io::di, io::uo) is det.            
       97 +:- pred eval_builtin(string_table::in, name_table::in, builtin
          +s.builtin::in,                                                
       98 +    env::in, env::out, stack::in, stack::out, io::di, io::uo) 
          +is det.                                                       
       99  
      100 -eval_builtin(ST, Builtin, !Env, !Stack, !IO) :-               
      100 +eval_builtin(ST, NT, Builtin, !Env, !Stack, !IO) :-           
      101      (
      102          Builtin = builtins.bi_print,
      103 -        builtins.builtin_print(ST, !Stack, !IO)               
      103 +        builtins.builtin_print(ST, NT, !Stack, !IO)           
      104      ;
      105          Builtin = builtins.bi_stack,
      106 -        builtins.builtin_stack(ST, !.Stack, !IO)              
      106 +        builtins.builtin_stack(ST, NT, !.Stack, !IO)          
      107      ;
      108          Builtin = builtins.bi_env,
      109 -        builtins.builtin_env(ST, !.Env, !IO)                  
      109 +        builtins.builtin_env(ST, NT, !.Env, !IO)              
      110      ;
      111          Builtin = builtins.bi_apply,
      112 -        builtin_apply(ST, !Env, !Stack, !IO)                  
      112 +        builtin_apply(ST, NT, !Env, !Stack, !IO)              
      113      ;
      114          Builtin = builtins.bi_eval,
      115 -        builtin_eval(ST, !Env, !Stack, !IO)                   
      115 +        builtin_eval(ST, NT, !Env, !Stack, !IO)               
      116      ;
      117          Builtin = builtins.bi_add,
      118          builtins.builtin_add(!Stack)

● Read(eval.m)
  ⎿  Read 75 lines

● Update(eval.m)
  ⎿  Added 15 lines, removed 15 lines                                    
      134  % Binder evaluation
      135  %-------------------------------------------------------------
           ----------%
      136  
      137 -:- pred eval_binder(name::in, env::in, env::out,              
      137 +:- pred eval_binder(name_id::in, env::in, env::out,           
      138      stack::in, stack::out) is det.
      139  
      140 -eval_binder(Name, !Env, !Stack) :-                            
      140 +eval_binder(NameId, !Env, !Stack) :-                          
      141      pop("binder", V, !Stack),
      142 -    set_env(Name, V, !Env).                                   
      142 +    set_env(NameId, V, !Env).                                 
      143  
      144  %-------------------------------------------------------------
           ----------%
      145  % Function evaluation
     ...
      156  % Generator evaluation
      157  %-------------------------------------------------------------
           ----------%
      158  
      159 -:- pred eval_generator(string_table::in, list(term)::in, env::
          -in, env::out,                                                 
      160 -    stack::in, stack::out, io::di, io::uo) is det.            
      159 +:- pred eval_generator(string_table::in, name_table::in, list(
          +term)::in,                                                    
      160 +    env::in, env::out, stack::in, stack::out, io::di, io::uo) 
          +is det.                                                       
      161  
      162 -eval_generator(ST, Terms, !Env, !Stack, !IO) :-               
      162 +eval_generator(ST, NT, Terms, !Env, !Stack, !IO) :-           
      163      % Save current stack, evaluate with empty stack
      164      SavedStack = !.Stack,
      165      !:Stack = [],
      166 -    eval_terms(ST, Terms, !Env, !Stack, !IO),                 
      166 +    eval_terms(ST, NT, Terms, !Env, !Stack, !IO),             
      167      % Convert stack to array (reverse since stack is LIFO)
      168      Array = array.from_reverse_list(!.Stack),
      169      % Restore stack and push array
     ...
      174  % apply: apply a closure
      175  %-------------------------------------------------------------
           ----------%
      176  
      177 -:- pred builtin_apply(string_table::in, env::in, env::out, sta
          -ck::in, stack::out,                                           
      178 -    io::di, io::uo) is det.                                   
      177 +:- pred builtin_apply(string_table::in, name_table::in, env::i
          +n, env::out,                                                  
      178 +    stack::in, stack::out, io::di, io::uo) is det.            
      179  
      180 -builtin_apply(ST, Env, Env, !Stack, !IO) :-                   
      180 +builtin_apply(ST, NT, Env, Env, !Stack, !IO) :-               
      181      pop("apply", V, !Stack),
      182      ( if V = closure(ClosureEnv, Terms) then
      183          % Evaluate with closure's env, then discard env change
           s (lexical scoping)
      184 -        eval_terms(ST, Terms, ClosureEnv, _, !Stack, !IO)     
      184 +        eval_terms(ST, NT, Terms, ClosureEnv, _, !Stack, !IO) 
      185      else
      186          throw(type_error("closure", V))
      187      ).
     ...
      190  % eval: evaluate a quoted term
      191  %-------------------------------------------------------------
           ----------%
      192  
      193 -:- pred builtin_eval(string_table::in, env::in, env::out, stac
          -k::in, stack::out,                                            
      194 -    io::di, io::uo) is det.                                   
      193 +:- pred builtin_eval(string_table::in, name_table::in, env::in
          +, env::out,                                                   
      194 +    stack::in, stack::out, io::di, io::uo) is det.            
      195  
      196 -builtin_eval(ST, !Env, !Stack, !IO) :-                        
      196 +builtin_eval(ST, NT, !Env, !Stack, !IO) :-                    
      197      pop("eval", V, !Stack),
      198      ( if V = termval(Term) then
      199 -        eval_term(ST, Term, !Env, !Stack, !IO)                
      199 +        eval_term(ST, NT, Term, !Env, !Stack, !IO)            
      200      else
      201          throw(type_error("term", V))
      202      ).

● Now I need to update builtins.m to take the name_table parameter.

● Update(builtins.m)
  ⎿  Added 5 lines, removed 3 lines                                      
      30  
      31      % Individual builtin operations.
      32      %
      33 -:- pred builtin_print(string_table::in, stack::in, stack::out, 
      33 +:- pred builtin_print(string_table::in, name_table::in, stack::
         +in, stack::out,                                                
      34      io::di, io::uo) is det.
      35 -:- pred builtin_stack(string_table::in, stack::in, io::di, io::
         -uo) is det.                                                    
      36 -:- pred builtin_env(string_table::in, env::in, io::di, io::uo) 
         -is det.                                                        
      35 +:- pred builtin_stack(string_table::in, name_table::in, stack::
         +in,                                                            
      36 +    io::di, io::uo) is det.                                    
      37 +:- pred builtin_env(string_table::in, name_table::in, env::in, 
      38 +    io::di, io::uo) is det.                                    
      39  :- pred builtin_add(stack::in, stack::out) is det.
      40  :- pred builtin_get(stack::in, stack::out) is det.
      41  :- pred builtin_length(stack::in, stack::out) is det.

● Update(builtins.m)
  ⎿  Added 29 lines, removed 26 lines                                    
       70  % print: pop and print a value
       71  %-------------------------------------------------------------
           ----------%
       72  
       73 -builtin_print(ST, !Stack, !IO) :-                             
       73 +builtin_print(ST, NT, !Stack, !IO) :-                         
       74      pop("print", V, !Stack),
       75 -    print_value(ST, V, !IO),                                  
       75 +    print_value(ST, NT, V, !IO),                              
       76      io.nl(!IO).
       77  
       78 -:- pred print_value(string_table::in, value::in, io::di, io::u
          -o) is det.                                                    
       78 +:- pred print_value(string_table::in, name_table::in, value::i
          +n,                                                            
       79 +    io::di, io::uo) is det.                                   
       80  
       80 -print_value(_, intval(I), !IO) :-                             
       81 +print_value(_, _, intval(I), !IO) :-                          
       82      io.write_int(I, !IO).
       82 -print_value(ST, stringval(Id), !IO) :-                        
       83 +print_value(ST, _, stringval(Id), !IO) :-                     
       84      io.write_string(lookup_string(ST, Id), !IO).
       84 -print_value(ST, arrayval(A), !IO) :-                          
       85 -    array.foldl(print_value(ST), A, !IO).                     
       86 -print_value(_, closure(_, _), !IO) :-                         
       85 +print_value(ST, NT, arrayval(A), !IO) :-                      
       86 +    array.foldl(print_value(ST, NT), A, !IO).                 
       87 +print_value(_, _, closure(_, _), !IO) :-                      
       88      io.write_string("<closure>", !IO).
       88 -print_value(ST, termval(T), !IO) :-                           
       89 -    print_term(ST, T, !IO).                                   
       89 +print_value(ST, NT, termval(T), !IO) :-                       
       90 +    print_term(ST, NT, T, !IO).                               
       91  
       91 -:- pred print_term(string_table::in, term::in, io::di, io::uo)
          - is det.                                                      
       92 +:- pred print_term(string_table::in, name_table::in, term::in,
       93 +    io::di, io::uo) is det.                                   
       94  
       93 -print_term(_, identifier(N), !IO) :-                          
       94 -    io.write_string(N, !IO).                                  
       95 -print_term(_, binder(N), !IO) :-                              
       96 -    io.format("/%s", [s(N)], !IO).                            
       97 -print_term(ST, function(Terms), !IO) :-                       
       95 +print_term(_, NT, identifier(NameId), !IO) :-                 
       96 +    io.write_string(lookup_name(NT, NameId), !IO).            
       97 +print_term(_, NT, binder(NameId), !IO) :-                     
       98 +    io.format("/%s", [s(lookup_name(NT, NameId))], !IO).      
       99 +print_term(ST, NT, function(Terms), !IO) :-                   
      100      io.write_string("{ ", !IO),
       99 -    list.foldl(print_term_space(ST), Terms, !IO),             
      101 +    list.foldl(print_term_space(ST, NT), Terms, !IO),         
      102      io.write_string("}", !IO).
      101 -print_term(ST, generator(Terms), !IO) :-                      
      103 +print_term(ST, NT, generator(Terms), !IO) :-                  
      104      io.write_string("[ ", !IO),
      103 -    list.foldl(print_term_space(ST), Terms, !IO),             
      105 +    list.foldl(print_term_space(ST, NT), Terms, !IO),         
      106      io.write_string("]", !IO).
      105 -print_term(ST, quoted(T), !IO) :-                             
      107 +print_term(ST, NT, quoted(T), !IO) :-                         
      108      io.write_string("'", !IO),
      107 -    print_term(ST, T, !IO).                                   
      108 -print_term(ST, value(V), !IO) :-                              
      109 -    print_value(ST, V, !IO).                                  
      109 +    print_term(ST, NT, T, !IO).                               
      110 +print_term(ST, NT, value(V), !IO) :-                          
      111 +    print_value(ST, NT, V, !IO).                              
      112  
      111 -:- pred print_term_space(string_table::in, term::in, io::di, i
          -o::uo) is det.                                                
      113 +:- pred print_term_space(string_table::in, name_table::in, ter
          +m::in,                                                        
      114 +    io::di, io::uo) is det.                                   
      115  
      113 -print_term_space(ST, T, !IO) :-                               
      114 -    print_term(ST, T, !IO),                                   
      116 +print_term_space(ST, NT, T, !IO) :-                           
      117 +    print_term(ST, NT, T, !IO),                               
      118      io.write_string(" ", !IO).
      119  
      120  %-------------------------------------------------------------
           ----------%

● Update(builtins.m)
  ⎿  Added 19 lines, removed 16 lines                                    
      121  % stack: print the stack
      122  %-------------------------------------------------------------
           ----------%
      123  
      124 -builtin_stack(ST, Stack, !IO) :-                              
      124 +builtin_stack(ST, NT, Stack, !IO) :-                          
      125      io.write_string("--- stack ---\n", !IO),
      126 -    list.foldl(print_stack_entry(ST), Stack, !IO),            
      126 +    list.foldl(print_stack_entry(ST, NT), Stack, !IO),        
      127      io.write_string("-------------\n", !IO).
      128  
      129 -:- pred print_stack_entry(string_table::in, value::in, io::di,
          - io::uo) is det.                                              
      129 +:- pred print_stack_entry(string_table::in, name_table::in, va
          +lue::in,                                                      
      130 +    io::di, io::uo) is det.                                   
      131  
      131 -print_stack_entry(ST, V, !IO) :-                              
      132 +print_stack_entry(ST, NT, V, !IO) :-                          
      133      io.write_string("  ", !IO),
      133 -    print_value_debug(ST, V, !IO),                            
      134 +    print_value_debug(ST, NT, V, !IO),                        
      135      io.nl(!IO).
      136  
      136 -:- pred print_value_debug(string_table::in, value::in, io::di,
          - io::uo) is det.                                              
      137 +:- pred print_value_debug(string_table::in, name_table::in, va
          +lue::in,                                                      
      138 +    io::di, io::uo) is det.                                   
      139  
      138 -print_value_debug(_, intval(I), !IO) :-                       
      140 +print_value_debug(_, _, intval(I), !IO) :-                    
      141      io.format("int(%d)", [i(I)], !IO).
      140 -print_value_debug(ST, stringval(Id), !IO) :-                  
      142 +print_value_debug(ST, _, stringval(Id), !IO) :-               
      143      io.format("string(\"%s\")", [s(lookup_string(ST, Id))], !I
           O).
      142 -print_value_debug(ST, arrayval(A), !IO) :-                    
      144 +print_value_debug(ST, NT, arrayval(A), !IO) :-                
      145      io.write_string("array(", !IO),
      144 -    array.foldl(print_array_elem_debug(ST), A, !IO),          
      146 +    array.foldl(print_array_elem_debug(ST, NT), A, !IO),      
      147      io.write_string(")", !IO).
      146 -print_value_debug(_, closure(_, _), !IO) :-                   
      148 +print_value_debug(_, _, closure(_, _), !IO) :-                
      149      io.write_string("<closure>", !IO).
      148 -print_value_debug(ST, termval(T), !IO) :-                     
      150 +print_value_debug(ST, NT, termval(T), !IO) :-                 
      151      io.write_string("term(", !IO),
      150 -    print_term(ST, T, !IO),                                   
      152 +    print_term(ST, NT, T, !IO),                               
      153      io.write_string(")", !IO).
      154  
      153 -:- pred print_array_elem_debug(string_table::in, value::in, io
          -::di, io::uo) is det.                                         
      155 +:- pred print_array_elem_debug(string_table::in, name_table::i
          +n, value::in,                                                 
      156 +    io::di, io::uo) is det.                                   
      157  
      155 -print_array_elem_debug(ST, V, !IO) :-                         
      156 -    print_value_debug(ST, V, !IO),                            
      158 +print_array_elem_debug(ST, NT, V, !IO) :-                     
      159 +    print_value_debug(ST, NT, V, !IO),                        
      160      io.write_string(" ", !IO).
      161  
      162  %-------------------------------------------------------------
           ----------%

● Update(builtins.m)
  ⎿  Added 7 lines, removed 7 lines                                      
      163  % env: print the environment
      164  %-------------------------------------------------------------
           ----------%
      165  
      166 -builtin_env(ST, Env, !IO) :-                                  
      166 +builtin_env(ST, NT, Env, !IO) :-                              
      167      io.write_string("--- env ---\n", !IO),
      168 -    map.foldl(print_env_entry(ST), Env, !IO),                 
      168 +    map.foldl(print_env_entry(ST, NT), Env, !IO),             
      169      io.write_string("-----------\n", !IO).
      170  
      171 -:- pred print_env_entry(string_table::in, name::in, value::in,
      172 -    io::di, io::uo) is det.                                   
      171 +:- pred print_env_entry(string_table::in, name_table::in, name
          +_id::in,                                                      
      172 +    value::in, io::di, io::uo) is det.                        
      173  
      174 -print_env_entry(ST, Name, V, !IO) :-                          
      175 -    io.format("  %s = ", [s(Name)], !IO),                     
      176 -    print_value_debug(ST, V, !IO),                            
      174 +print_env_entry(ST, NT, NameId, V, !IO) :-                    
      175 +    io.format("  %s = ", [s(lookup_name(NT, NameId))], !IO),  
      176 +    print_value_debug(ST, NT, V, !IO),                        
      177      io.nl(!IO).
      178  
      179  %-------------------------------------------------------------
           ----------%

● Now let me compile and check for errors.

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/froth.int3
     Making Mercury/int3s/eval.int3
     Making Mercury/int3s/types.int3
     … +21 lines (ctrl+o to expand)

● Now let me run the tests.

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +18 lines (ctrl+o to expand)

● All 19 tests pass. Name interning is now implemented:

  Changes made:
  - types.m: Added name_id == int, name_table type with empty_name_table, intern_name, lookup_name. Updated term to use name_id in identifier and binder. Updated env to be map(name_id, value). Updated eval_error and format_error to use name_id.
  - lexer.m: Added name_table to lex_state. Updated tokenize to take both tables. Tokens name and slash_name now hold name_id. Names are interned during lexing.
  - parser.m: No changes needed - it passes name_id through transparently.
  - eval.m: Added name_table parameter throughout. eval_identifier looks up name string to check builtins, but uses name_id for environment lookups.
  - builtins.m: Added name_table parameter to print functions. Uses lookup_name when printing identifiers/binders/env entries.
  - froth.m: Threads name_table through REPL and file execution.

> Let's add a new type that contains the string and name tables, as these 
are generally passed around together. 

● I'll create an intern_table type that bundles the string and name tables together.

● Update(types.m)
  ⎿  Added 7 lines                                                       
      21      %
      22  :- type string_table.
      23  :- type name_table.
      24 +:- type intern_table                                           
      25 +    --->    intern_table(                                      
      26 +                it_strings  :: string_table,                   
      27 +                it_names    :: name_table                      
      28 +            ).                                                 
      29  
      30  :- func empty_string_table = string_table.
      31  :- pred intern_string(string::in, string_id::out,
     ...
      37      name_table::in, name_table::out) is det.
      38  :- func lookup_name(name_table, name_id) = string.
      39  
      40 +:- func empty_intern_table = intern_table.                     
      41 +                                                               
      42  :- type value
      43      --->    intval(int)
      44      ;       stringval(string_id)

● Update(types.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      68      ;       undefined_name(name_id)
      69      ;       index_out_of_bounds(int, int).  % Index, array size
      70  
      71 -    % format_error(NameTable, Error) = Message:                
      71 +    % format_error(InternTable, Error) = Message:              
      72      % Convert an eval_error to a human-readable message.
      73      %
      74 -:- func format_error(name_table, eval_error) = string.         
      74 +:- func format_error(intern_table, eval_error) = string.       
      75  
      76  %--------------------------------------------------------------
          ---------%
      77  % Stack operations

● Update(types.m)
  ⎿  Added 4 lines, removed 2 lines                                      
      138  lookup_name(Table, Id) = Name :-
      139      map.lookup(Table ^ nt_to_name, Id, Name).
      140  
      141 +empty_intern_table = intern_table(empty_string_table, empty_na
          +me_table).                                                    
      142 +                                                              
      143  %-------------------------------------------------------------
           ----------%
      144  
      145  format_error(_, stack_underflow(Op)) =
     ...
      147  format_error(_, type_error(Expected, Actual)) =
      148      string.format("type error: expected %s, got %s",
      149          [s(Expected), s(value_type_name(Actual))]).
      148 -format_error(NT, undefined_name(NameId)) =                    
      149 -    string.format("undefined name: %s", [s(lookup_name(NT, Nam
          -eId))]).                                                      
      150 +format_error(IT, undefined_name(NameId)) =                    
      151 +    string.format("undefined name: %s", [s(lookup_name(IT ^ it
          +_names, NameId))]).                                           
      152  format_error(_, index_out_of_bounds(Index, Size)) =
      153      string.format("index out of bounds: %d (array size: %d)", 
           [i(Index), i(Size)]).
      154  

● Now let me update lexer.m to use intern_table.

● Update(lexer.m)
  ⎿  Added 4 lines, removed 5 lines                                      
      40      ;       unterminated_block_comment(position).
      41  
      42  :- type lex_result
      43 -    --->    ok(list(located(token)), string_table, name_table) 
      43 +    --->    ok(list(located(token)), intern_table)             
      44      ;       error(lex_error).
      45  
      46 -    % tokenize(Input, StringTable, NameTable, Result):         
      46 +    % tokenize(Input, InternTable, Result):                    
      47      % Tokenize the input string into a list of located tokens.
      48 -    % Takes initial string and name tables (use empty_*_table f
         -or fresh start).                                               
      48 +    % Takes initial intern table (use empty_intern_table for fr
         +esh start).                                                    
      49      %
      50 -:- pred tokenize(string::in, string_table::in, name_table::in, 
      51 -    lex_result::out) is det.                                   
      50 +:- pred tokenize(string::in, intern_table::in, lex_result::out)
         + is det.                                                       
      51  
      52  %--------------------------------------------------------------
          ---------%
      53  

● Update(lexer.m)
  ⎿  Added 1 line, removed 2 lines                                       
      65                  ls_pos      :: int,         % Current position 
          in string
      66                  ls_line     :: int,
      67                  ls_column   :: int,
      68 -                ls_strings  :: string_table,                   
      69 -                ls_names    :: name_table                      
      68 +                ls_intern   :: intern_table                    
      69              ).
      70  
      71      % Internal result type to avoid ambiguity with other ok/err
          or types.

● Update(lexer.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      75  
      76  %--------------------------------------------------------------
          ---------%
      77  
      78 -tokenize(Input, StringTable, NameTable, Result) :-             
      79 -    State0 = lex_state(Input, 0, 1, 1, StringTable, NameTable),
      78 +tokenize(Input, InternTable, Result) :-                        
      79 +    State0 = lex_state(Input, 0, 1, 1, InternTable),           
      80      tokenize_loop(State0, [], Result).
      81  
      82  :- pred tokenize_loop(lex_state::in, list(located(token))::in,

● Update(lexer.m)
  ⎿  Added 1 line, removed 2 lines                                       
      87      (
      88          SkipResult = ok(State1),
      89          ( if at_end(State1) then
      90 -            Result = ok(list.reverse(RevTokens), State1 ^ ls_st
         -rings,                                                         
      91 -                State1 ^ ls_names)                             
      90 +            Result = ok(list.reverse(RevTokens), State1 ^ ls_in
         +tern)                                                          
      91          else
      92              Pos = position(State1 ^ ls_line, State1 ^ ls_column
          ),
      93              read_token(State1, Pos, TokenResult),

● Update(lexer.m)
  ⎿  Added 3 lines, removed 2 lines                                      
      259      then
      260          read_name_chars(State0, Chars, State1),
      261          NameStr = string.from_char_list(Chars),
      262 -        intern_name(NameStr, NameId, State1 ^ ls_names, NewNam
          -es),                                                          
      263 -        State2 = State1 ^ ls_names := NewNames,               
      262 +        IT0 = State1 ^ ls_intern,                             
      263 +        intern_name(NameStr, NameId, IT0 ^ it_names, NewNames)
          +,                                                             
      264 +        State2 = State1 ^ ls_intern := (IT0 ^ it_names := NewN
          +ames),                                                        
      265          Result = ok({name(NameId), State2})
      266      else
      267          % Fall through to junk

● Update(lexer.m)
  ⎿  Added 3 lines, removed 2 lines                                      
      299      then
      300          read_name_chars(State0, Chars, State1),
      301          NameStr = string.from_char_list(Chars),
      302 -        intern_name(NameStr, NameId, State1 ^ ls_names, NewNam
          -es),                                                          
      303 -        State2 = State1 ^ ls_names := NewNames,               
      302 +        IT0 = State1 ^ ls_intern,                             
      303 +        intern_name(NameStr, NameId, IT0 ^ it_names, NewNames)
          +,                                                             
      304 +        State2 = State1 ^ ls_intern := (IT0 ^ it_names := NewN
          +ames),                                                        
      305          Result = ok({slash_name(NameId), State2})
      306      else
      307          % Just a slash followed by non-name, treat as junk

● Search(pattern: "read_string\(State1, Pos, Result\)", path: "lexer.m",
        output_mode: "content")
  ⎿  Found 1 line (ctrl+o to expand)

● Search(pattern: "ls_strings", path: "lexer.m", output_mode: "content")
  ⎿  Found 2 lines (ctrl+o to expand)

● Read(lexer.m)
  ⎿  Read 30 lines

● Update(lexer.m)
  ⎿  Added 3 lines, removed 2 lines                                      
      388      (
      389          StringResult = ok(State1),
      390          String = string.from_char_list(Chars),
      391 -        intern_string(String, Id, State1 ^ ls_strings, NewStri
          -ngs),                                                         
      392 -        State2 = State1 ^ ls_strings := NewStrings,           
      391 +        IT0 = State1 ^ ls_intern,                             
      392 +        intern_string(String, Id, IT0 ^ it_strings, NewStrings
          +),                                                            
      393 +        State2 = State1 ^ ls_intern := (IT0 ^ it_strings := Ne
          +wStrings),                                                    
      394          Result = ok({string(Id), State2})
      395      ;
      396          StringResult = error(Error),

● Now let me update eval.m to use intern_table.

● Update(eval.m)
  ⎿  Added 3 lines, removed 3 lines                                      
      12  
      13  %--------------------------------------------------------------
          ---------%
      14  
      15 -    % eval_terms(StringTable, NameTable, Terms, !Env, !Stack, !
         -IO):                                                           
      15 +    % eval_terms(InternTable, Terms, !Env, !Stack, !IO):       
      16      % Evaluate a list of terms, updating the environment and st
          ack.
      17 -    % StringTable and NameTable are read-only (all strings/name
         -s known at lex time).                                          
      17 +    % InternTable is read-only (all strings/names known at lex 
         +time).                                                         
      18      % Throws eval_error on failure.
      19      %
      20 -:- pred eval_terms(string_table::in, name_table::in, list(term)
         -::in,                                                          
      20 +:- pred eval_terms(intern_table::in, list(term)::in,           
      21      env::in, env::out, stack::in, stack::out, io::di, io::uo) i
          s det.
      22  
      23      % Environment operations.

● Update(eval.m)
  ⎿  Added 8 lines, removed 8 lines                                      
      48  % Main evaluation
      49  %--------------------------------------------------------------
          ---------%
      50  
      51 -eval_terms(_, _, [], !Env, !Stack, !IO).                       
      52 -eval_terms(ST, NT, [Term | Terms], !Env, !Stack, !IO) :-       
      53 -    eval_term(ST, NT, Term, !Env, !Stack, !IO),                
      54 -    eval_terms(ST, NT, Terms, !Env, !Stack, !IO).              
      51 +eval_terms(_, [], !Env, !Stack, !IO).                          
      52 +eval_terms(IT, [Term | Terms], !Env, !Stack, !IO) :-           
      53 +    eval_term(IT, Term, !Env, !Stack, !IO),                    
      54 +    eval_terms(IT, Terms, !Env, !Stack, !IO).                  
      55  
      56 -:- pred eval_term(string_table::in, name_table::in, term::in, e
         -nv::in, env::out,                                              
      56 +:- pred eval_term(intern_table::in, term::in, env::in, env::out
         +,                                                              
      57      stack::in, stack::out, io::di, io::uo) is det.
      58  
      59 -eval_term(ST, NT, Term, !Env, !Stack, !IO) :-                  
      59 +eval_term(IT, Term, !Env, !Stack, !IO) :-                      
      60      (
      61          Term = identifier(NameId),
      62 -        eval_identifier(ST, NT, NameId, !Env, !Stack, !IO)     
      62 +        eval_identifier(IT, NameId, !Env, !Stack, !IO)         
      63      ;
      64          Term = binder(NameId),
      65          eval_binder(NameId, !Env, !Stack)
     ...
      68          eval_function(Terms, !.Env, !Stack)
      69      ;
      70          Term = generator(Terms),
      71 -        eval_generator(ST, NT, Terms, !Env, !Stack, !IO)       
      71 +        eval_generator(IT, Terms, !Env, !Stack, !IO)           
      72      ;
      73          Term = quoted(T),
      74          push(termval(T), !Stack)

● Update(eval.m)
  ⎿  Added 11 lines, removed 11 lines                                    
       81  % Identifier evaluation
       82  %-------------------------------------------------------------
           ----------%
       83  
       84 -:- pred eval_identifier(string_table::in, name_table::in, name
          -_id::in,                                                      
       84 +:- pred eval_identifier(intern_table::in, name_id::in,        
       85      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is det.
       86  
       87 -eval_identifier(ST, NT, NameId, !Env, !Stack, !IO) :-         
       88 -    NameStr = lookup_name(NT, NameId),                        
       87 +eval_identifier(IT, NameId, !Env, !Stack, !IO) :-             
       88 +    NameStr = lookup_name(IT ^ it_names, NameId),             
       89      ( if builtins.builtin(NameStr, Builtin) then
       90 -        eval_builtin(ST, NT, Builtin, !Env, !Stack, !IO)      
       90 +        eval_builtin(IT, Builtin, !Env, !Stack, !IO)          
       91      else if get_env(NameId, V, !.Env) then
       92          push(V, !Stack)
       93      else
       94          throw(undefined_name(NameId))
       95      ).
       96  
       97 -:- pred eval_builtin(string_table::in, name_table::in, builtin
          -s.builtin::in,                                                
       97 +:- pred eval_builtin(intern_table::in, builtins.builtin::in,  
       98      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is det.
       99  
      100 -eval_builtin(ST, NT, Builtin, !Env, !Stack, !IO) :-           
      100 +eval_builtin(IT, Builtin, !Env, !Stack, !IO) :-               
      101      (
      102          Builtin = builtins.bi_print,
      103 -        builtins.builtin_print(ST, NT, !Stack, !IO)           
      103 +        builtins.builtin_print(IT, !Stack, !IO)               
      104      ;
      105          Builtin = builtins.bi_stack,
      106 -        builtins.builtin_stack(ST, NT, !.Stack, !IO)          
      106 +        builtins.builtin_stack(IT, !.Stack, !IO)              
      107      ;
      108          Builtin = builtins.bi_env,
      109 -        builtins.builtin_env(ST, NT, !.Env, !IO)              
      109 +        builtins.builtin_env(IT, !.Env, !IO)                  
      110      ;
      111          Builtin = builtins.bi_apply,
      112 -        builtin_apply(ST, NT, !Env, !Stack, !IO)              
      112 +        builtin_apply(IT, !Env, !Stack, !IO)                  
      113      ;
      114          Builtin = builtins.bi_eval,
      115 -        builtin_eval(ST, NT, !Env, !Stack, !IO)               
      115 +        builtin_eval(IT, !Env, !Stack, !IO)                   
      116      ;
      117          Builtin = builtins.bi_add,
      118          builtins.builtin_add(!Stack)

● Update(eval.m)
  ⎿  Added 9 lines, removed 9 lines                                      
      156  % Generator evaluation
      157  %-------------------------------------------------------------
           ----------%
      158  
      159 -:- pred eval_generator(string_table::in, name_table::in, list(
          -term)::in,                                                    
      159 +:- pred eval_generator(intern_table::in, list(term)::in,      
      160      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is det.
      161  
      162 -eval_generator(ST, NT, Terms, !Env, !Stack, !IO) :-           
      162 +eval_generator(IT, Terms, !Env, !Stack, !IO) :-               
      163      % Save current stack, evaluate with empty stack
      164      SavedStack = !.Stack,
      165      !:Stack = [],
      166 -    eval_terms(ST, NT, Terms, !Env, !Stack, !IO),             
      166 +    eval_terms(IT, Terms, !Env, !Stack, !IO),                 
      167      % Convert stack to array (reverse since stack is LIFO)
      168      Array = array.from_reverse_list(!.Stack),
      169      % Restore stack and push array
     ...
      174  % apply: apply a closure
      175  %-------------------------------------------------------------
           ----------%
      176  
      177 -:- pred builtin_apply(string_table::in, name_table::in, env::i
          -n, env::out,                                                  
      177 +:- pred builtin_apply(intern_table::in, env::in, env::out,    
      178      stack::in, stack::out, io::di, io::uo) is det.
      179  
      180 -builtin_apply(ST, NT, Env, Env, !Stack, !IO) :-               
      180 +builtin_apply(IT, Env, Env, !Stack, !IO) :-                   
      181      pop("apply", V, !Stack),
      182      ( if V = closure(ClosureEnv, Terms) then
      183          % Evaluate with closure's env, then discard env change
           s (lexical scoping)
      184 -        eval_terms(ST, NT, Terms, ClosureEnv, _, !Stack, !IO) 
      184 +        eval_terms(IT, Terms, ClosureEnv, _, !Stack, !IO)     
      185      else
      186          throw(type_error("closure", V))
      187      ).
     ...
      190  % eval: evaluate a quoted term
      191  %-------------------------------------------------------------
           ----------%
      192  
      193 -:- pred builtin_eval(string_table::in, name_table::in, env::in
          -, env::out,                                                   
      193 +:- pred builtin_eval(intern_table::in, env::in, env::out,     
      194      stack::in, stack::out, io::di, io::uo) is det.
      195  
      196 -builtin_eval(ST, NT, !Env, !Stack, !IO) :-                    
      196 +builtin_eval(IT, !Env, !Stack, !IO) :-                        
      197      pop("eval", V, !Stack),
      198      ( if V = termval(Term) then
      199 -        eval_term(ST, NT, Term, !Env, !Stack, !IO)            
      199 +        eval_term(IT, Term, !Env, !Stack, !IO)                
      200      else
      201          throw(type_error("term", V))
      202      ).

● Now let me update builtins.m to use intern_table.

● Update(builtins.m)
  ⎿  Added 3 lines, removed 5 lines                                      
      30  
      31      % Individual builtin operations.
      32      %
      33 -:- pred builtin_print(string_table::in, name_table::in, stack::
         -in, stack::out,                                                
      33 +:- pred builtin_print(intern_table::in, stack::in, stack::out, 
      34      io::di, io::uo) is det.
      35 -:- pred builtin_stack(string_table::in, name_table::in, stack::
         -in,                                                            
      36 -    io::di, io::uo) is det.                                    
      37 -:- pred builtin_env(string_table::in, name_table::in, env::in, 
      38 -    io::di, io::uo) is det.                                    
      35 +:- pred builtin_stack(intern_table::in, stack::in, io::di, io::
         +uo) is det.                                                    
      36 +:- pred builtin_env(intern_table::in, env::in, io::di, io::uo) 
         +is det.                                                        
      37  :- pred builtin_add(stack::in, stack::out) is det.
      38  :- pred builtin_get(stack::in, stack::out) is det.
      39  :- pred builtin_length(stack::in, stack::out) is det.

● Update(builtins.m)
  ⎿  Added 27 lines, removed 30 lines                                    
       68  % print: pop and print a value
       69  %-------------------------------------------------------------
           ----------%
       70  
       71 -builtin_print(ST, NT, !Stack, !IO) :-                         
       71 +builtin_print(IT, !Stack, !IO) :-                             
       72      pop("print", V, !Stack),
       73 -    print_value(ST, NT, V, !IO),                              
       73 +    print_value(IT, V, !IO),                                  
       74      io.nl(!IO).
       75  
       76 -:- pred print_value(string_table::in, name_table::in, value::i
          -n,                                                            
       77 -    io::di, io::uo) is det.                                   
       76 +:- pred print_value(intern_table::in, value::in, io::di, io::u
          +o) is det.                                                    
       77  
       79 -print_value(_, _, intval(I), !IO) :-                          
       78 +print_value(_, intval(I), !IO) :-                             
       79      io.write_int(I, !IO).
       81 -print_value(ST, _, stringval(Id), !IO) :-                     
       82 -    io.write_string(lookup_string(ST, Id), !IO).              
       83 -print_value(ST, NT, arrayval(A), !IO) :-                      
       84 -    array.foldl(print_value(ST, NT), A, !IO).                 
       85 -print_value(_, _, closure(_, _), !IO) :-                      
       80 +print_value(IT, stringval(Id), !IO) :-                        
       81 +    io.write_string(lookup_string(IT ^ it_strings, Id), !IO). 
       82 +print_value(IT, arrayval(A), !IO) :-                          
       83 +    array.foldl(print_value(IT), A, !IO).                     
       84 +print_value(_, closure(_, _), !IO) :-                         
       85      io.write_string("<closure>", !IO).
       87 -print_value(ST, NT, termval(T), !IO) :-                       
       88 -    print_term(ST, NT, T, !IO).                               
       86 +print_value(IT, termval(T), !IO) :-                           
       87 +    print_term(IT, T, !IO).                                   
       88  
       90 -:- pred print_term(string_table::in, name_table::in, term::in,
       91 -    io::di, io::uo) is det.                                   
       89 +:- pred print_term(intern_table::in, term::in, io::di, io::uo)
          + is det.                                                      
       90  
       93 -print_term(_, NT, identifier(NameId), !IO) :-                 
       94 -    io.write_string(lookup_name(NT, NameId), !IO).            
       95 -print_term(_, NT, binder(NameId), !IO) :-                     
       96 -    io.format("/%s", [s(lookup_name(NT, NameId))], !IO).      
       97 -print_term(ST, NT, function(Terms), !IO) :-                   
       91 +print_term(IT, identifier(NameId), !IO) :-                    
       92 +    io.write_string(lookup_name(IT ^ it_names, NameId), !IO). 
       93 +print_term(IT, binder(NameId), !IO) :-                        
       94 +    io.format("/%s", [s(lookup_name(IT ^ it_names, NameId))], 
          +!IO).                                                         
       95 +print_term(IT, function(Terms), !IO) :-                       
       96      io.write_string("{ ", !IO),
       99 -    list.foldl(print_term_space(ST, NT), Terms, !IO),         
       97 +    list.foldl(print_term_space(IT), Terms, !IO),             
       98      io.write_string("}", !IO).
      101 -print_term(ST, NT, generator(Terms), !IO) :-                  
       99 +print_term(IT, generator(Terms), !IO) :-                      
      100      io.write_string("[ ", !IO),
      103 -    list.foldl(print_term_space(ST, NT), Terms, !IO),         
      101 +    list.foldl(print_term_space(IT), Terms, !IO),             
      102      io.write_string("]", !IO).
      105 -print_term(ST, NT, quoted(T), !IO) :-                         
      103 +print_term(IT, quoted(T), !IO) :-                             
      104      io.write_string("'", !IO),
      107 -    print_term(ST, NT, T, !IO).                               
      108 -print_term(ST, NT, value(V), !IO) :-                          
      109 -    print_value(ST, NT, V, !IO).                              
      105 +    print_term(IT, T, !IO).                                   
      106 +print_term(IT, value(V), !IO) :-                              
      107 +    print_value(IT, V, !IO).                                  
      108  
      111 -:- pred print_term_space(string_table::in, name_table::in, ter
          -m::in,                                                        
      112 -    io::di, io::uo) is det.                                   
      109 +:- pred print_term_space(intern_table::in, term::in, io::di, i
          +o::uo) is det.                                                
      110  
      114 -print_term_space(ST, NT, T, !IO) :-                           
      115 -    print_term(ST, NT, T, !IO),                               
      111 +print_term_space(IT, T, !IO) :-                               
      112 +    print_term(IT, T, !IO),                                   
      113      io.write_string(" ", !IO).
      114  
      115  %-------------------------------------------------------------
           ----------%

● Update(builtins.m)
  ⎿  Added 24 lines, removed 26 lines                                    
      116  % stack: print the stack
      117  %-------------------------------------------------------------
           ----------%
      118  
      119 -builtin_stack(ST, NT, Stack, !IO) :-                          
      119 +builtin_stack(IT, Stack, !IO) :-                              
      120      io.write_string("--- stack ---\n", !IO),
      121 -    list.foldl(print_stack_entry(ST, NT), Stack, !IO),        
      121 +    list.foldl(print_stack_entry(IT), Stack, !IO),            
      122      io.write_string("-------------\n", !IO).
      123  
      124 -:- pred print_stack_entry(string_table::in, name_table::in, va
          -lue::in,                                                      
      125 -    io::di, io::uo) is det.                                   
      124 +:- pred print_stack_entry(intern_table::in, value::in, io::di,
          + io::uo) is det.                                              
      125  
      127 -print_stack_entry(ST, NT, V, !IO) :-                          
      126 +print_stack_entry(IT, V, !IO) :-                              
      127      io.write_string("  ", !IO),
      129 -    print_value_debug(ST, NT, V, !IO),                        
      128 +    print_value_debug(IT, V, !IO),                            
      129      io.nl(!IO).
      130  
      132 -:- pred print_value_debug(string_table::in, name_table::in, va
          -lue::in,                                                      
      133 -    io::di, io::uo) is det.                                   
      131 +:- pred print_value_debug(intern_table::in, value::in, io::di,
          + io::uo) is det.                                              
      132  
      135 -print_value_debug(_, _, intval(I), !IO) :-                    
      133 +print_value_debug(_, intval(I), !IO) :-                       
      134      io.format("int(%d)", [i(I)], !IO).
      137 -print_value_debug(ST, _, stringval(Id), !IO) :-               
      138 -    io.format("string(\"%s\")", [s(lookup_string(ST, Id))], !I
          -O).                                                           
      139 -print_value_debug(ST, NT, arrayval(A), !IO) :-                
      135 +print_value_debug(IT, stringval(Id), !IO) :-                  
      136 +    io.format("string(\"%s\")", [s(lookup_string(IT ^ it_strin
          +gs, Id))], !IO).                                              
      137 +print_value_debug(IT, arrayval(A), !IO) :-                    
      138      io.write_string("array(", !IO),
      141 -    array.foldl(print_array_elem_debug(ST, NT), A, !IO),      
      139 +    array.foldl(print_array_elem_debug(IT), A, !IO),          
      140      io.write_string(")", !IO).
      143 -print_value_debug(_, _, closure(_, _), !IO) :-                
      141 +print_value_debug(_, closure(_, _), !IO) :-                   
      142      io.write_string("<closure>", !IO).
      145 -print_value_debug(ST, NT, termval(T), !IO) :-                 
      143 +print_value_debug(IT, termval(T), !IO) :-                     
      144      io.write_string("term(", !IO),
      147 -    print_term(ST, NT, T, !IO),                               
      145 +    print_term(IT, T, !IO),                                   
      146      io.write_string(")", !IO).
      147  
      150 -:- pred print_array_elem_debug(string_table::in, name_table::i
          -n, value::in,                                                 
      148 +:- pred print_array_elem_debug(intern_table::in, value::in,   
      149      io::di, io::uo) is det.
      150  
      153 -print_array_elem_debug(ST, NT, V, !IO) :-                     
      154 -    print_value_debug(ST, NT, V, !IO),                        
      151 +print_array_elem_debug(IT, V, !IO) :-                         
      152 +    print_value_debug(IT, V, !IO),                            
      153      io.write_string(" ", !IO).
      154  
      155  %-------------------------------------------------------------
           ----------%
      156  % env: print the environment
      157  %-------------------------------------------------------------
           ----------%
      158  
      161 -builtin_env(ST, NT, Env, !IO) :-                              
      159 +builtin_env(IT, Env, !IO) :-                                  
      160      io.write_string("--- env ---\n", !IO),
      163 -    map.foldl(print_env_entry(ST, NT), Env, !IO),             
      161 +    map.foldl(print_env_entry(IT), Env, !IO),                 
      162      io.write_string("-----------\n", !IO).
      163  
      166 -:- pred print_env_entry(string_table::in, name_table::in, name
          -_id::in,                                                      
      167 -    value::in, io::di, io::uo) is det.                        
      164 +:- pred print_env_entry(intern_table::in, name_id::in, value::
          +in,                                                           
      165 +    io::di, io::uo) is det.                                   
      166  
      169 -print_env_entry(ST, NT, NameId, V, !IO) :-                    
      170 -    io.format("  %s = ", [s(lookup_name(NT, NameId))], !IO),  
      171 -    print_value_debug(ST, NT, V, !IO),                        
      167 +print_env_entry(IT, NameId, V, !IO) :-                        
      168 +    io.format("  %s = ", [s(lookup_name(IT ^ it_names, NameId)
          +)], !IO),                                                     
      169 +    print_value_debug(IT, V, !IO),                            
      170      io.nl(!IO).
      171  
      172  %-------------------------------------------------------------
           ----------%

● Now let me update froth.m to use intern_table.

● Update(froth.m)
  ⎿  Added 18 lines, removed 27 lines                                    
      71      io.write_string("Froth REPL. Press Ctrl-D to exit.\n", !IO)
          ,
      72      Env0 = map.init,
      73      Stack0 = [],
      74 -    StringTable0 = empty_string_table,                         
      75 -    NameTable0 = empty_name_table,                             
      76 -    repl_loop(StringTable0, NameTable0, Env0, Stack0, !IO).    
      74 +    IT0 = empty_intern_table,                                  
      75 +    repl_loop(IT0, Env0, Stack0, !IO).                         
      76  
      78 -:- pred repl_loop(string_table::in, name_table::in, env::in, st
         -ack::in,                                                       
      77 +:- pred repl_loop(intern_table::in, env::in, stack::in,        
      78      io::di, io::uo) is cc_multi.
      79  
      81 -repl_loop(StringTable0, NameTable0, Env0, Stack0, !IO) :-      
      80 +repl_loop(IT0, Env0, Stack0, !IO) :-                           
      81      io.write_string("> ", !IO),
      82      io.flush_output(!IO),
      83      io.read_line_as_string(ReadResult, !IO),
      84      (
      85          ReadResult = ok(Line),
      87 -        repl_eval(Line, StringTable0, StringTable, NameTable0, 
         -NameTable,                                                     
      88 -            Env0, Env, Stack0, Stack, !IO),                    
      89 -        repl_loop(StringTable, NameTable, Env, Stack, !IO)     
      86 +        repl_eval(Line, IT0, IT, Env0, Env, Stack0, Stack, !IO)
         +,                                                              
      87 +        repl_loop(IT, Env, Stack, !IO)                         
      88      ;
      89          ReadResult = eof,
      90          io.nl(!IO)
     ...
       95          io.set_exit_status(1, !IO)
       96      ).
       97  
      100 -:- pred repl_eval(string::in, string_table::in, string_table::
          -out,                                                          
      101 -    name_table::in, name_table::out,                          
       98 +:- pred repl_eval(string::in, intern_table::in, intern_table::
          +out,                                                          
       99      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is cc_multi.
      100  
      104 -repl_eval(Input, StringTable0, StringTable, NameTable0, NameTa
          -ble,                                                          
      105 -        Env0, Env, Stack0, Stack, !IO) :-                     
      106 -    lexer.tokenize(Input, StringTable0, NameTable0, LexResult)
          -,                                                             
      101 +repl_eval(Input, IT0, IT, Env0, Env, Stack0, Stack, !IO) :-   
      102 +    lexer.tokenize(Input, IT0, LexResult),                    
      103      (
      108 -        LexResult = ok(Tokens, StringTable1, NameTable1),     
      104 +        LexResult = ok(Tokens, IT1),                          
      105          parser.parse(Tokens, ParseResult),
      106          (
      107              ParseResult = ok(Terms),
      112 -            execute_repl(StringTable1, NameTable1, Terms, Env0
          -, Env,                                                        
      113 -                Stack0, Stack, !IO),                          
      114 -            StringTable = StringTable1,                       
      115 -            NameTable = NameTable1                            
      108 +            execute_repl(IT1, Terms, Env0, Env, Stack0, Stack,
          + !IO),                                                        
      109 +            IT = IT1                                          
      110          ;
      111              ParseResult = error(ParseError),
      112              report_parse_error(ParseError, !IO),
      119 -            StringTable = StringTable1,                       
      120 -            NameTable = NameTable1,                           
      113 +            IT = IT1,                                         
      114              Env = Env0,
      115              Stack = Stack0
      116          )
      117      ;
      118          LexResult = error(LexError),
      119          report_lex_error(LexError, !IO),
      127 -        StringTable = StringTable0,                           
      128 -        NameTable = NameTable0,                               
      120 +        IT = IT0,                                             
      121          Env = Env0,
      122          Stack = Stack0
      123      ).
      124  
      133 -:- pred execute_repl(string_table::in, name_table::in, list(te
          -rm)::in,                                                      
      125 +:- pred execute_repl(intern_table::in, list(term)::in,        
      126      env::in, env::out, stack::in, stack::out, io::di, io::uo) 
           is cc_multi.
      127  
      136 -execute_repl(StringTable, NameTable, Terms, Env0, Env, Stack0,
          - Stack, !IO) :-                                               
      137 -    try_io(eval_terms_wrapper(StringTable, NameTable, Terms, E
          -nv0, Stack0),                                                 
      138 -        Result, !IO),                                         
      128 +execute_repl(IT, Terms, Env0, Env, Stack0, Stack, !IO) :-     
      129 +    try_io(eval_terms_wrapper(IT, Terms, Env0, Stack0), Result
          +, !IO),                                                       
      130      (
      131          Result = succeeded({Env, Stack})
      132      ;
      133          Result = exception(Exn),
      134          ( if univ_to_type(Exn, EvalError) then
      135              io.format("Runtime error: %s\n",
      145 -                [s(types.format_error(NameTable, EvalError))],
          - !IO),                                                        
      136 +                [s(types.format_error(IT, EvalError))], !IO), 
      137              Env = Env0,
      138              Stack = Stack0
      139          else

● Update(froth.m)
  ⎿  Added 10 lines, removed 14 lines                                    
      162  :- pred run(string::in, io::di, io::uo) is cc_multi.
      163  
      164  run(Input, !IO) :-
      165 -    lexer.tokenize(Input, empty_string_table, empty_name_table
          -, LexResult),                                                 
      165 +    lexer.tokenize(Input, empty_intern_table, LexResult),     
      166      (
      167 -        LexResult = ok(Tokens, StringTable, NameTable),       
      167 +        LexResult = ok(Tokens, IT),                           
      168          parser.parse(Tokens, ParseResult),
      169          (
      170              ParseResult = ok(Terms),
      171 -            execute(StringTable, NameTable, Terms, !IO)       
      171 +            execute(IT, Terms, !IO)                           
      172          ;
      173              ParseResult = error(ParseError),
      174              report_parse_error(ParseError, !IO),
     ...
      180          io.set_exit_status(1, !IO)
      181      ).
      182  
      183 -:- pred execute(string_table::in, name_table::in, list(term)::
          -in,                                                           
      184 -    io::di, io::uo) is cc_multi.                              
      183 +:- pred execute(intern_table::in, list(term)::in, io::di, io::
          +uo) is cc_multi.                                              
      184  
      186 -execute(StringTable, NameTable, Terms, !IO) :-                
      185 +execute(IT, Terms, !IO) :-                                    
      186      Env0 = map.init,
      187      Stack0 = [],
      189 -    try_io(eval_terms_wrapper(StringTable, NameTable, Terms, E
          -nv0, Stack0),                                                 
      190 -        Result, !IO),                                         
      188 +    try_io(eval_terms_wrapper(IT, Terms, Env0, Stack0), Result
          +, !IO),                                                       
      189      (
      190          Result = succeeded({_, _})
      191      ;
      192          Result = exception(Exn),
      193          ( if univ_to_type(Exn, EvalError) then
      194              io.format("Runtime error: %s\n",
      197 -                [s(types.format_error(NameTable, EvalError))],
          - !IO),                                                        
      195 +                [s(types.format_error(IT, EvalError))], !IO), 
      196              io.set_exit_status(1, !IO)
      197          else
      198              rethrow(Result)
      199          )
      200      ).
      201  
      204 -:- pred eval_terms_wrapper(string_table::in, name_table::in, l
          -ist(term)::in,                                                
      202 +:- pred eval_terms_wrapper(intern_table::in, list(term)::in,  
      203      env::in, stack::in, {env, stack}::out, io::di, io::uo) is 
           det.
      204  
      207 -eval_terms_wrapper(StringTable, NameTable, Terms, Env0, Stack0
          -,                                                             
      208 -        {Env, Stack}, !IO) :-                                 
      209 -    eval.eval_terms(StringTable, NameTable, Terms, Env0, Env, 
          -Stack0, Stack,                                                
      210 -        !IO).                                                 
      205 +eval_terms_wrapper(IT, Terms, Env0, Stack0, {Env, Stack}, !IO)
          + :-                                                           
      206 +    eval.eval_terms(IT, Terms, Env0, Env, Stack0, Stack, !IO).
      207  
      208  %-------------------------------------------------------------
           ----------%
      209  % Error reporting

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/froth.int3
     Making Mercury/int3s/eval.int3
     Making Mercury/int3s/types.int3
     … +21 lines (ctrl+o to expand)

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +18 lines (ctrl+o to expand)

● All 19 tests pass. Added intern_table type that bundles string_table and name_table:

  :- type intern_table
      --->    intern_table(
                  it_strings  :: string_table,
                  it_names    :: name_table
              ).

  :- func empty_intern_table = intern_table.

  Updated all modules to use the single intern_table parameter instead of passing both tables separately. This simplified the function signatures throughout the codebase.

> Let's expand the lexical syntax to allow the following additional 
characters in names: `+`, `=`, `,`, `.`, `>`, `<`. If a token starts with 
`+` or `-` followed by a digit it should be treated as a number, otherwise 
it is an identifier. Does that cause any potential problems? 

● Let me think through the potential issues:

  1. 1+2 without spaces: Would parse as 1 (number) then +2 (number, since + followed by digit). That seems fine.
  2. a+b without spaces: Would parse as single name a+b. Need spaces for a + b to be three tokens.
  3. Floating point ambiguity: 1.5 would parse as 1 (number) then .5 (name). .5 alone would be a name. This rules out adding floats later without breaking changes.
  4. Comma in names: a,b would be one token. Unusual but consistent with Forth-style.

  These tradeoffs seem acceptable for a Forth-like language. Let me implement it.

● Update(lexer.m)
  ⎿  Added 15 lines, removed 8 lines                                     
      232  :- pred is_name_start(char::in) is semidet.
      233  
      234  is_name_start(Char) :-
      235 -    char.is_alpha(Char).                                      
      235 +    ( char.is_alpha(Char)                                     
      236 +    ; Char = ('+'')                                           
      237 +    ; Char = ('-')                                            
      238 +    ; Char = ('=')                                            
      239 +    ; Char = (',')                                            
      240 +    ; Char = ('.')                                            
      241 +    ; Char = ('>')                                            
      242 +    ; Char = ('<')                                            
      243 +    ).                                                        
      244  
      237 -:- pred is_name_start_with_hyphen(lex_state::in) is semidet.  
      238 -                                                              
      239 -is_name_start_with_hyphen(State) :-                           
      240 -    peek_char(State, '-'),                                    
      241 -    peek_char_at(State, 1, NextChar),                         
      242 -    char.is_alpha(NextChar).                                  
      243 -                                                              
      245  :- pred is_name_char(char::in) is semidet.
      246  
      247  is_name_char(Char) :-
      248      ( char.is_alnum(Char)
      249      ; Char = ('-')
      250 +    ; Char = ('+')                                            
      251 +    ; Char = ('=')                                            
      252 +    ; Char = (',')                                            
      253 +    ; Char = ('.')                                            
      254 +    ; Char = ('>')                                            
      255 +    ; Char = ('<')                                            
      256      ).
      257  
      258  :- pred read_name(lex_state::in,

● I made a typo. Let me fix it.

● Update(lexer.m)
  ⎿  Added 1 line, removed 1 line                                        
      233  
      234  is_name_start(Char) :-
      235      ( char.is_alpha(Char)
      236 -    ; Char = ('+'')                                           
      236 +    ; Char = ('+')                                            
      237      ; Char = ('-')
      238      ; Char = ('=')
      239      ; Char = (',')

● Now I need to update read_token to check is_number_start BEFORE is_name_start (since + and - are now name start chars, but +5 and -5 should still be numbers).

● Read(lexer.m)
  ⎿  Read 45 lines

● Update(lexer.m)
  ⎿  Added 3 lines, removed 4 lines                                      
      211          else if Char = ('/') then
      212              advance(State0, State1),
      213              read_slash_name(State1, Result)
      214 -        else if is_name_start(Char) then                      
      215 -            read_name(State0, Result)                         
      216 -        else if is_name_start_with_hyphen(State0) then        
      217 -            read_name(State0, Result)                         
      214          else if is_number_start(State0) then
      215 +            % Check number before name since +/- are now name 
          +start chars                                                   
      216              read_number(State0, Result)
      217 +        else if is_name_start(Char) then                      
      218 +            read_name(State0, Result)                         
      219          else
      220              read_junk(State0, Result)
      221          )

● Update(lexer.m)
  ⎿  Added 1 line, removed 5 lines                                       
      258      maybe_result({token, lex_state}, lex_error)::out) is det.
      259  
      260  read_name(State0, Result) :-
      261 -    ( if                                                      
      262 -        ( peek_char(State0, Char), char.is_alpha(Char)        
      263 -        ; is_name_start_with_hyphen(State0)                   
      264 -        )                                                     
      265 -    then                                                      
      261 +    ( if peek_char(State0, Char), is_name_start(Char) then    
      262          read_name_chars(State0, Chars, State1),
      263          NameStr = string.from_char_list(Chars),
      264          IT0 = State1 ^ ls_intern,

● Update(lexer.m)
  ⎿  Added 1 line, removed 5 lines                                       
      294      maybe_result({token, lex_state}, lex_error)::out) is det.
      295  
      296  read_slash_name(State0, Result) :-
      297 -    ( if                                                      
      298 -        ( peek_char(State0, Char), char.is_alpha(Char)        
      299 -        ; is_name_start_with_hyphen(State0)                   
      300 -        )                                                     
      301 -    then                                                      
      297 +    ( if peek_char(State0, Char), is_name_start(Char) then    
      298          read_name_chars(State0, Chars, State1),
      299          NameStr = string.from_char_list(Chars),
      300          IT0 = State1 ^ ls_intern,

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/lexer.int3
     Making Mercury/ints/lexer.int
     Making Mercury/cs/lexer.c
     … +2 lines (ctrl+o to expand)

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +18 lines (ctrl+o to expand)

● Let me add a test for the new name characters.

● Write(tests/extended_names.froth)
  ⎿  Wrote 31 lines to tests/extended_names.froth   
      1 # Test extended name characters: + = , . > <
      2 # Names with special characters
      3 1 /+
      4 + print
      5 2 /++
      6 ++ print
      7 3 /.
     … +21 lines (ctrl+o to expand)

● Write(tests/extended_names.expected)
  ⎿  Wrote 10 lines to tests/extended_names.expected
      1 1
      2 2
      3 3
      4 5
      5 -5
      6 1
      7 10
      8 20
      9 3

● Bash(./run_tests.sh)
  ⎿  PASS: add                     
     PASS: array_ops
     PASS: binder
     … +19 lines (ctrl+o to expand)

● Let me update the documentation.

● Update(FROTH.md)
  ⎿  Added 4 lines, removed 2 lines                                      
       8  
       9  | Token | Pattern | Description |
      10  |-------|---------|-------------|
      11 -| `name` | `[-]?[a-zA-Z][-a-zA-Z0-9]*` | Identifier |          
      11 +| `name` | `[a-zA-Z+=,.<>-][a-zA-Z0-9+=,.<>-]*` | Identifier | 
      12  | `slash_name` | `/` followed by a name | Binder (variable defi
          nition) |
      13 -| `number` | `[-+]?[0-9]+` | Integer literal |                 
      13 +| `number` | `[-+][0-9]+` or `[0-9]+` | Integer literal (`+`/`-
         +` followed by digit) |                                         
      14  | `string` | `"..."` | String literal |
      15  | `'` | | Quote (prevents evaluation) |
      16  | `{` `}` | | Function delimiters |
      17  | `[` `]` | | Generator delimiters |
      18  
      19 +**Note:** If a token starts with `+` or `-` followed by a digit
         +, it is parsed as a number. Otherwise, `+` and `-` are treated 
         +as name characters. This means `1+2` parses as two tokens: `1` 
         +and `+2` (both numbers), while `a+b` is a single name token.   
      20 +                                                               
      21  ### Comments
      22  
      23  - Line comments: `#` to end of line

● All 20 tests pass. The lexical syntax has been expanded:

  New name characters: +, =, ,, ., >, < (in addition to existing alphanumeric and -)

  Key behaviors:
  - +5 and -5 → numbers (sign followed by digit)
  - +, -, ++, ->, <> → names (no digit after sign)
  - a+b → single name (no spaces)
  - a + b → three names (with spaces)

  Potential considerations I mentioned:
  1. 1.5 parses as 1 .5 (no float support)
  2. a,b is one token (commas in names)
  3. Need spaces to separate operator-like names from operands

> /context 
  ⎿  
      Context Usage
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛀ ⛁   claude-opus-4-5-20251101 · 189k/200k tokens (94%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ 
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ System prompt: 2.9k tokens (1.5%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ System tools: 14.8k tokens (7.4%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ Memory files: 38 tokens (0.0%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ Messages: 126.0k tokens (63.0%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛶ Free space: 11k (5.6%)
     ⛁ ⛁ ⛶ ⛶ ⛶ ⛶ ⛶ ⛝ ⛝ ⛝   ⛝ Autocompact buffer: 45.0k tokens (22.5%)
     ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ 
     ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ 
     
     Memory files · /memory
     └ CLAUDE.md: 38 tokens
     
     Skills and slash commands · /skills
     
     



