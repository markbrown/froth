
 * ▐▛███▜▌ *   Claude Code v2.0.75
* ▝▜█████▛▘ *  Opus 4.5 · Claude Max
 *  ▘▘ ▝▝  *   ~/Documents/projects/froth
══════════════════ Conversation compacted · ctrl+o for history ═════════════════

> /compact 
  ⎿  Compacted (ctrl+o to see full summary)
  ⎿  Read src/stack_test.m (157 lines)
  ⎿  Read src/datastack.m (162 lines)
  ⎿  Read lib/bench.froth (27 lines)

> Let's update the evaluator to use the new datastack module. Review the 
evaluator code first if you need to. 

● Search(pattern: "**/eval*.m", path: "src")
  ⎿  Found 2 files (ctrl+o to expand)

● Search(pattern: "types\.stack", path: "src")
  ⎿  Found 0 files 

● Search(pattern: "stack", path: "src", glob: "*.m")
  ⎿  Found 7 files (ctrl+o to expand)

● Read(src/eval.m)
  ⎿  Read 289 lines

● Now let me check the types.m to see the current stack type definition:

● Read(src/types.m)
  ⎿  Read 263 lines

● Let me check operators.m as well:

● Read(src/operators.m)
  ⎿  Read 1192 lines

● Let me also check froth.m to see how the stack is initialized:

● Read(src/froth.m)
  ⎿  Read 558 lines

● Now I have a complete picture. This is a significant change that affects types.m, eval.m, operators.m, and froth.m. Let me create a plan and work through it systematically.

● Update(src/types.m)
  ⎿  Removed 2 lines                                                     
      130  
      131  :- type env == map(string_id, value).
      132  
      133 -:- type stack == list(value).                                 
      134 -                                                              
      133  %-------------------------------------------------------------
           ----------%
      134  % Runtime errors
      135  %-------------------------------------------------------------
           ----------%

● Update(src/types.m)
  ⎿  Removed 7 lines                                                     
      147  :- func format_error(string_table, eval_error) = string.
      148  
      149  %-------------------------------------------------------------
           ----------%
      150 -% Stack operations                                            
      151 -%-------------------------------------------------------------
          -----------%                                                   
      150  
      153 -:- pred push(value::in, stack::in, stack::out) is det.        
      154 -:- pred pop(string::in, value::out, stack::in, stack::out) is 
          -det.                                                          
      155 -                                                              
      156 -%-------------------------------------------------------------
          -----------%                                                   
      157 -                                                              
      151  :- implementation.
      152  
      153  :- import_module char.

● Update(src/types.m)
  ⎿  Removed 12 lines                                                    
      237  value_type_name(closureval(_, _)) = "closure".
      238  
      239  %-------------------------------------------------------------
           ----------%
      240 -                                                              
      241 -push(V, Stack, [V | Stack]).                                  
      242 -                                                              
      243 -pop(Op, V, Stack0, Stack) :-                                  
      244 -    (                                                         
      245 -        Stack0 = [V | Stack]                                  
      246 -    ;                                                         
      247 -        Stack0 = [],                                          
      248 -        throw(stack_underflow(Op))                            
      249 -    ).                                                        
      250 -                                                              
      251 -%-------------------------------------------------------------
          -----------%                                                   
      240  :- end_module types.
      241  %-------------------------------------------------------------
           ----------%

● Now let me update operators.m. This is the largest change. I'll start by updating the interface section:

● Update(src/operators.m)
  ⎿  Added 1 line                                                        
       6  :- module operators.
       7  :- interface.
       8  
       9 +:- import_module array.                                        
      10  :- import_module io.
      11  :- import_module types.
      12  

● Update(src/operators.m)
  ⎿  Added 3 lines, removed 2 lines                                      
      24      %
      25  :- pred operator(string::in, operator::out) is semidet.
      26  
      27 -    % eval_operator(OpTable, ST, Op, Env, !Stack, !IO):        
      27 +    % eval_operator(OpTable, ST, Op, Env, !StackArray, !StackPt
         +r, !IO):                                                       
      28      % Execute an operator. OpTable and ST are read-only.
      29      % Env is read-only (for the env operator).
      30      %
      31  :- pred eval_operator(operator_table::in, string_table::in, ope
          rator::in,
      32 -    env::in, stack::in, stack::out, io::di, io::uo) is det.    
      32 +    env::in, array(value)::array_di, array(value)::array_uo,   
      33 +    int::in, int::out, io::di, io::uo) is det.                 
      34  
      35      % Individual operator implementations.
      36      %

● Update(src/operators.m)
  ⎿  Added 107 lines, removed 53 lines                                   
       33      int::in, int::out, io::di, io::uo) is det.
       34  
       35      % Individual operator implementations.
       36 +    % All operators take the stack as array + pointer pair.   
       37      %
       37 -:- pred operator_print(string_table::in, stack::in, stack::out
          -,                                                             
       38 -    io::di, io::uo) is det.                                   
       39 -:- pred operator_env(env::in, stack::in, stack::out) is det.  
       40 -:- pred operator_add(stack::in, stack::out) is det.           
       41 -:- pred operator_sub(stack::in, stack::out) is det.           
       42 -:- pred operator_mul(stack::in, stack::out) is det.           
       43 -:- pred operator_gt(stack::in, stack::out) is det.            
       44 -:- pred operator_lt(stack::in, stack::out) is det.            
       45 -:- pred operator_gte(stack::in, stack::out) is det.           
       46 -:- pred operator_lte(stack::in, stack::out) is det.           
       47 -:- pred operator_get(stack::in, stack::out) is det.           
       48 -:- pred operator_length(stack::in, stack::out) is det.        
       49 -:- pred operator_eq(stack::in, stack::out) is det.            
       50 -:- pred operator_ite(stack::in, stack::out) is det.           
       51 -:- pred operator_nil(stack::in, stack::out) is det.           
       52 -:- pred operator_cons(stack::in, stack::out) is det.          
       53 -:- pred operator_fst(stack::in, stack::out) is det.           
       54 -:- pred operator_snd(stack::in, stack::out) is det.           
       55 -:- pred operator_write(string_table::in, stack::in, stack::out
          -,                                                             
       56 -    io::di, io::uo) is det.                                   
       57 -:- pred operator_fwrite(string_table::in, stack::in, stack::ou
          -t,                                                            
       58 -    io::di, io::uo) is det.                                   
       59 -:- pred operator_empty(stack::in, stack::out) is det.         
       60 -:- pred operator_keys(stack::in, stack::out) is det.          
       61 -:- pred operator_store(stack::in, stack::out) is det.         
       62 -:- pred operator_in(stack::in, stack::out) is det.            
       63 -:- pred operator_delete(stack::in, stack::out) is det.        
       64 -:- pred operator_is_int(stack::in, stack::out) is det.        
       65 -:- pred operator_is_string(stack::in, stack::out) is det.     
       66 -:- pred operator_is_array(stack::in, stack::out) is det.      
       67 -:- pred operator_is_map(stack::in, stack::out) is det.        
       68 -:- pred operator_is_nil(stack::in, stack::out) is det.        
       69 -:- pred operator_is_cons(stack::in, stack::out) is det.       
       70 -:- pred operator_is_ident(stack::in, stack::out) is det.      
       71 -:- pred operator_is_binder(stack::in, stack::out) is det.     
       72 -:- pred operator_is_func(stack::in, stack::out) is det.       
       73 -:- pred operator_is_gen(stack::in, stack::out) is det.        
       74 -:- pred operator_is_quote(stack::in, stack::out) is det.      
       75 -:- pred operator_is_apply(stack::in, stack::out) is det.      
       76 -:- pred operator_is_value(stack::in, stack::out) is det.      
       77 -:- pred operator_unwrap(stack::in, stack::out) is det.        
       78 -:- pred operator_intern(stack::in, stack::out) is det.        
       79 -:- pred operator_id_to_string(stack::in, stack::out) is det.  
       80 -:- pred operator_id_to_ident(stack::in, stack::out) is det.   
       81 -:- pred operator_id_to_binder(stack::in, stack::out) is det.  
       82 -:- pred operator_is_operator(operator_table::in, stack::in, st
          -ack::out) is det.                                             
       83 -:- pred operator_arity_op(operator_table::in, stack::in, stack
          -::out) is det.                                                
       84 -:- pred operator_stack(stack::in, stack::out) is det.         
       85 -:- pred operator_time(stack::in, stack::out, io::di, io::uo) i
          -s det.                                                        
       86 -:- pred operator_close(stack::in, stack::out) is det.         
       87 -:- pred operator_closure_env(stack::in, stack::out) is det.   
       88 -:- pred operator_closure_body(stack::in, stack::out) is det.  
       89 -:- pred operator_is_closure(stack::in, stack::out) is det.    
       38 +:- pred operator_print(string_table::in,                      
       39 +    array(value)::array_di, array(value)::array_uo,           
       40 +    int::in, int::out, io::di, io::uo) is det.                
       41 +:- pred operator_env(env::in,                                 
       42 +    array(value)::array_di, array(value)::array_uo,           
       43 +    int::in, int::out) is det.                                
       44 +:- pred operator_add(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       45 +    int::in, int::out) is det.                                
       46 +:- pred operator_sub(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       47 +    int::in, int::out) is det.                                
       48 +:- pred operator_mul(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       49 +    int::in, int::out) is det.                                
       50 +:- pred operator_gt(array(value)::array_di, array(value)::arra
          +y_uo,                                                         
       51 +    int::in, int::out) is det.                                
       52 +:- pred operator_lt(array(value)::array_di, array(value)::arra
          +y_uo,                                                         
       53 +    int::in, int::out) is det.                                
       54 +:- pred operator_gte(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       55 +    int::in, int::out) is det.                                
       56 +:- pred operator_lte(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       57 +    int::in, int::out) is det.                                
       58 +:- pred operator_get(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       59 +    int::in, int::out) is det.                                
       60 +:- pred operator_length(array(value)::array_di, array(value)::
          +array_uo,                                                     
       61 +    int::in, int::out) is det.                                
       62 +:- pred operator_eq(array(value)::array_di, array(value)::arra
          +y_uo,                                                         
       63 +    int::in, int::out) is det.                                
       64 +:- pred operator_ite(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       65 +    int::in, int::out) is det.                                
       66 +:- pred operator_nil(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       67 +    int::in, int::out) is det.                                
       68 +:- pred operator_cons(array(value)::array_di, array(value)::ar
          +ray_uo,                                                       
       69 +    int::in, int::out) is det.                                
       70 +:- pred operator_fst(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       71 +    int::in, int::out) is det.                                
       72 +:- pred operator_snd(array(value)::array_di, array(value)::arr
          +ay_uo,                                                        
       73 +    int::in, int::out) is det.                                
       74 +:- pred operator_write(string_table::in,                      
       75 +    array(value)::array_di, array(value)::array_uo,           
       76 +    int::in, int::out, io::di, io::uo) is det.                
       77 +:- pred operator_fwrite(string_table::in,                     
       78 +    array(value)::array_di, array(value)::array_uo,           
       79 +    int::in, int::out, io::di, io::uo) is det.                
       80 +:- pred operator_empty(array(value)::array_di, array(value)::a
          +rray_uo,                                                      
       81 +    int::in, int::out) is det.                                
       82 +:- pred operator_keys(array(value)::array_di, array(value)::ar
          +ray_uo,                                                       
       83 +    int::in, int::out) is det.                                
       84 +:- pred operator_store(array(value)::array_di, array(value)::a
          +rray_uo,                                                      
       85 +    int::in, int::out) is det.                                
       86 +:- pred operator_in(array(value)::array_di, array(value)::arra
          +y_uo,                                                         
       87 +    int::in, int::out) is det.                                
       88 +:- pred operator_delete(array(value)::array_di, array(value)::
          +array_uo,                                                     
       89 +    int::in, int::out) is det.                                
       90 +:- pred operator_is_int(array(value)::array_di, array(value)::
          +array_uo,                                                     
       91 +    int::in, int::out) is det.                                
       92 +:- pred operator_is_string(array(value)::array_di, array(value
          +)::array_uo,                                                  
       93 +    int::in, int::out) is det.                                
       94 +:- pred operator_is_array(array(value)::array_di, array(value)
          +::array_uo,                                                   
       95 +    int::in, int::out) is det.                                
       96 +:- pred operator_is_map(array(value)::array_di, array(value)::
          +array_uo,                                                     
       97 +    int::in, int::out) is det.                                
       98 +:- pred operator_is_nil(array(value)::array_di, array(value)::
          +array_uo,                                                     
       99 +    int::in, int::out) is det.                                
      100 +:- pred operator_is_cons(array(value)::array_di, array(value):
          +:array_uo,                                                    
      101 +    int::in, int::out) is det.                                
      102 +:- pred operator_is_ident(array(value)::array_di, array(value)
          +::array_uo,                                                   
      103 +    int::in, int::out) is det.                                
      104 +:- pred operator_is_binder(array(value)::array_di, array(value
          +)::array_uo,                                                  
      105 +    int::in, int::out) is det.                                
      106 +:- pred operator_is_func(array(value)::array_di, array(value):
          +:array_uo,                                                    
      107 +    int::in, int::out) is det.                                
      108 +:- pred operator_is_gen(array(value)::array_di, array(value)::
          +array_uo,                                                     
      109 +    int::in, int::out) is det.                                
      110 +:- pred operator_is_quote(array(value)::array_di, array(value)
          +::array_uo,                                                   
      111 +    int::in, int::out) is det.                                
      112 +:- pred operator_is_apply(array(value)::array_di, array(value)
          +::array_uo,                                                   
      113 +    int::in, int::out) is det.                                
      114 +:- pred operator_is_value(array(value)::array_di, array(value)
          +::array_uo,                                                   
      115 +    int::in, int::out) is det.                                
      116 +:- pred operator_unwrap(array(value)::array_di, array(value)::
          +array_uo,                                                     
      117 +    int::in, int::out) is det.                                
      118 +:- pred operator_intern(array(value)::array_di, array(value)::
          +array_uo,                                                     
      119 +    int::in, int::out) is det.                                
      120 +:- pred operator_id_to_string(array(value)::array_di, array(va
          +lue)::array_uo,                                               
      121 +    int::in, int::out) is det.                                
      122 +:- pred operator_id_to_ident(array(value)::array_di, array(val
          +ue)::array_uo,                                                
      123 +    int::in, int::out) is det.                                
      124 +:- pred operator_id_to_binder(array(value)::array_di, array(va
          +lue)::array_uo,                                               
      125 +    int::in, int::out) is det.                                
      126 +:- pred operator_is_operator(operator_table::in,              
      127 +    array(value)::array_di, array(value)::array_uo,           
      128 +    int::in, int::out) is det.                                
      129 +:- pred operator_arity_op(operator_table::in,                 
      130 +    array(value)::array_di, array(value)::array_uo,           
      131 +    int::in, int::out) is det.                                
      132 +:- pred operator_stack(array(value)::array_di, array(value)::a
          +rray_uo,                                                      
      133 +    int::in, int::out) is det.                                
      134 +:- pred operator_time(array(value)::array_di, array(value)::ar
          +ray_uo,                                                       
      135 +    int::in, int::out, io::di, io::uo) is det.                
      136 +:- pred operator_close(array(value)::array_di, array(value)::a
          +rray_uo,                                                      
      137 +    int::in, int::out) is det.                                
      138 +:- pred operator_closure_env(array(value)::array_di, array(val
          +ue)::array_uo,                                                
      139 +    int::in, int::out) is det.                                
      140 +:- pred operator_closure_body(array(value)::array_di, array(va
          +lue)::array_uo,                                               
      141 +    int::in, int::out) is det.                                
      142 +:- pred operator_is_closure(array(value)::array_di, array(valu
          +e)::array_uo,                                                 
      143 +    int::in, int::out) is det.                                
      144  
      145      % value_to_string(ST, Value) = String:
      146      % Convert a value to its string representation (for print/
           import).

● Now let me add the datastack import and update the implementation. First, the imports:

● Update(src/operators.m)
  ⎿  Added 1 line, removed 1 line                                        
      151  
      152  :- implementation.
      153  
      154 -:- import_module array.                                       
      154  :- import_module assoc_list.
      155 +:- import_module datastack.                                   
      156  :- import_module bool.
      157  :- import_module exception.
      158  :- import_module int.

● Now let me update the eval_operator dispatcher:

● Update(src/operators.m)
  ⎿  Added 51 lines, removed 51 lines                                    
      315  % eval_operator: dispatch to operator implementation
      316  %-------------------------------------------------------------
           ----------%
      317  
      318 -eval_operator(OpTable, ST, Op, Env, !Stack, !IO) :-           
      318 +eval_operator(OpTable, ST, Op, Env, !Array, !Ptr, !IO) :-     
      319      (
      320          Op = op_print,
      321 -        operator_print(ST, !Stack, !IO)                       
      321 +        operator_print(ST, !Array, !Ptr, !IO)                 
      322      ;
      323          Op = op_env,
      324 -        operator_env(Env, !Stack)                             
      324 +        operator_env(Env, !Array, !Ptr)                       
      325      ;
      326          Op = op_add,
      327 -        operator_add(!Stack)                                  
      327 +        operator_add(!Array, !Ptr)                            
      328      ;
      329          Op = op_sub,
      330 -        operator_sub(!Stack)                                  
      330 +        operator_sub(!Array, !Ptr)                            
      331      ;
      332          Op = op_mul,
      333 -        operator_mul(!Stack)                                  
      333 +        operator_mul(!Array, !Ptr)                            
      334      ;
      335          Op = op_gt,
      336 -        operator_gt(!Stack)                                   
      336 +        operator_gt(!Array, !Ptr)                             
      337      ;
      338          Op = op_lt,
      339 -        operator_lt(!Stack)                                   
      339 +        operator_lt(!Array, !Ptr)                             
      340      ;
      341          Op = op_gte,
      342 -        operator_gte(!Stack)                                  
      342 +        operator_gte(!Array, !Ptr)                            
      343      ;
      344          Op = op_lte,
      345 -        operator_lte(!Stack)                                  
      345 +        operator_lte(!Array, !Ptr)                            
      346      ;
      347          Op = op_get,
      348 -        operator_get(!Stack)                                  
      348 +        operator_get(!Array, !Ptr)                            
      349      ;
      350          Op = op_length,
      351 -        operator_length(!Stack)                               
      351 +        operator_length(!Array, !Ptr)                         
      352      ;
      353          Op = op_eq,
      354 -        operator_eq(!Stack)                                   
      354 +        operator_eq(!Array, !Ptr)                             
      355      ;
      356          Op = op_ite,
      357 -        operator_ite(!Stack)                                  
      357 +        operator_ite(!Array, !Ptr)                            
      358      ;
      359          Op = op_nil,
      360 -        operator_nil(!Stack)                                  
      360 +        operator_nil(!Array, !Ptr)                            
      361      ;
      362          Op = op_cons,
      363 -        operator_cons(!Stack)                                 
      363 +        operator_cons(!Array, !Ptr)                           
      364      ;
      365          Op = op_fst,
      366 -        operator_fst(!Stack)                                  
      366 +        operator_fst(!Array, !Ptr)                            
      367      ;
      368          Op = op_snd,
      369 -        operator_snd(!Stack)                                  
      369 +        operator_snd(!Array, !Ptr)                            
      370      ;
      371          Op = op_write,
      372 -        operator_write(ST, !Stack, !IO)                       
      372 +        operator_write(ST, !Array, !Ptr, !IO)                 
      373      ;
      374          Op = op_fwrite,
      375 -        operator_fwrite(ST, !Stack, !IO)                      
      375 +        operator_fwrite(ST, !Array, !Ptr, !IO)                
      376      ;
      377          Op = op_empty,
      378 -        operator_empty(!Stack)                                
      378 +        operator_empty(!Array, !Ptr)                          
      379      ;
      380          Op = op_keys,
      381 -        operator_keys(!Stack)                                 
      381 +        operator_keys(!Array, !Ptr)                           
      382      ;
      383          Op = op_store,
      384 -        operator_store(!Stack)                                
      384 +        operator_store(!Array, !Ptr)                          
      385      ;
      386          Op = op_in,
      387 -        operator_in(!Stack)                                   
      387 +        operator_in(!Array, !Ptr)                             
      388      ;
      389          Op = op_delete,
      390 -        operator_delete(!Stack)                               
      390 +        operator_delete(!Array, !Ptr)                         
      391      ;
      392          Op = op_is_int,
      393 -        operator_is_int(!Stack)                               
      393 +        operator_is_int(!Array, !Ptr)                         
      394      ;
      395          Op = op_is_string,
      396 -        operator_is_string(!Stack)                            
      396 +        operator_is_string(!Array, !Ptr)                      
      397      ;
      398          Op = op_is_array,
      399 -        operator_is_array(!Stack)                             
      399 +        operator_is_array(!Array, !Ptr)                       
      400      ;
      401          Op = op_is_map,
      402 -        operator_is_map(!Stack)                               
      402 +        operator_is_map(!Array, !Ptr)                         
      403      ;
      404          Op = op_is_nil,
      405 -        operator_is_nil(!Stack)                               
      405 +        operator_is_nil(!Array, !Ptr)                         
      406      ;
      407          Op = op_is_cons,
      408 -        operator_is_cons(!Stack)                              
      408 +        operator_is_cons(!Array, !Ptr)                        
      409      ;
      410          Op = op_is_ident,
      411 -        operator_is_ident(!Stack)                             
      411 +        operator_is_ident(!Array, !Ptr)                       
      412      ;
      413          Op = op_is_binder,
      414 -        operator_is_binder(!Stack)                            
      414 +        operator_is_binder(!Array, !Ptr)                      
      415      ;
      416          Op = op_is_func,
      417 -        operator_is_func(!Stack)                              
      417 +        operator_is_func(!Array, !Ptr)                        
      418      ;
      419          Op = op_is_gen,
      420 -        operator_is_gen(!Stack)                               
      420 +        operator_is_gen(!Array, !Ptr)                         
      421      ;
      422          Op = op_is_quote,
      423 -        operator_is_quote(!Stack)                             
      423 +        operator_is_quote(!Array, !Ptr)                       
      424      ;
      425          Op = op_is_apply,
      426 -        operator_is_apply(!Stack)                             
      426 +        operator_is_apply(!Array, !Ptr)                       
      427      ;
      428          Op = op_is_value,
      429 -        operator_is_value(!Stack)                             
      429 +        operator_is_value(!Array, !Ptr)                       
      430      ;
      431          Op = op_unwrap,
      432 -        operator_unwrap(!Stack)                               
      432 +        operator_unwrap(!Array, !Ptr)                         
      433      ;
      434          Op = op_intern,
      435 -        operator_intern(!Stack)                               
      435 +        operator_intern(!Array, !Ptr)                         
      436      ;
      437          Op = op_id_to_string,
      438 -        operator_id_to_string(!Stack)                         
      438 +        operator_id_to_string(!Array, !Ptr)                   
      439      ;
      440          Op = op_id_to_ident,
      441 -        operator_id_to_ident(!Stack)                          
      441 +        operator_id_to_ident(!Array, !Ptr)                    
      442      ;
      443          Op = op_id_to_binder,
      444 -        operator_id_to_binder(!Stack)                         
      444 +        operator_id_to_binder(!Array, !Ptr)                   
      445      ;
      446          Op = op_is_operator,
      447 -        operator_is_operator(OpTable, !Stack)                 
      447 +        operator_is_operator(OpTable, !Array, !Ptr)           
      448      ;
      449          Op = op_arity,
      450 -        operator_arity_op(OpTable, !Stack)                    
      450 +        operator_arity_op(OpTable, !Array, !Ptr)              
      451      ;
      452          Op = op_stack,
      453 -        operator_stack(!Stack)                                
      453 +        operator_stack(!Array, !Ptr)                          
      454      ;
      455          Op = op_import,
      456          % import is handled specially in eval.m, should not re
           ach here
      457          unexpected($pred, "import should be handled in eval.m"
           )
      458      ;
      459          Op = op_time,
      460 -        operator_time(!Stack, !IO)                            
      460 +        operator_time(!Array, !Ptr, !IO)                      
      461      ;
      462          Op = op_restore,
      463          % restore is handled specially in eval.m, should not r
           each here
      464          unexpected($pred, "restore should be handled in eval.m
           ")
      465      ;
      466          Op = op_close,
      467 -        operator_close(!Stack)                                
      467 +        operator_close(!Array, !Ptr)                          
      468      ;
      469          Op = op_closure_env,
      470 -        operator_closure_env(!Stack)                          
      470 +        operator_closure_env(!Array, !Ptr)                    
      471      ;
      472          Op = op_closure_body,
      473 -        operator_closure_body(!Stack)                         
      473 +        operator_closure_body(!Array, !Ptr)                   
      474      ;
      475          Op = op_is_closure,
      476 -        operator_is_closure(!Stack)                           
      476 +        operator_is_closure(!Array, !Ptr)                     
      477      ).
      478  
      479  %-------------------------------------------------------------
           ----------%

● Now I need to update all the individual operator implementations. Let me do them in chunks:

● Update(src/operators.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      480  % print: ( a -- ) Pop and print a value
      481  %-------------------------------------------------------------
           ----------%
      482  
      483 -operator_print(ST, !Stack, !IO) :-                            
      484 -    pop("print", V, !Stack),                                  
      483 +operator_print(ST, !Array, !Ptr, !IO) :-                      
      484 +    datastack.pop("print", V, !Array, !Ptr),                  
      485      io.write_string(value_to_string(ST, V), !IO).
      486  
      487  %-------------------------------------------------------------
           ----------%

● Update(src/operators.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      522  % env: ( -- map ) Push the current environment as a map
      523  %-------------------------------------------------------------
           ----------%
      524  
      525 -operator_env(Env, !Stack) :-                                  
      526 -    push(mapval(Env), !Stack).                                
      525 +operator_env(Env, !Array, !Ptr) :-                            
      526 +    datastack.push(mapval(Env), !Array, !Ptr).                
      527  
      528  %-------------------------------------------------------------
           ----------%
      529  % +: ( int int -- int ) Add two integers

● Update(src/operators.m)
  ⎿  Added 12 lines, removed 12 lines                                    
      529  % +: ( int int -- int ) Add two integers
      530  %-------------------------------------------------------------
           ----------%
      531  
      532 -operator_add(!Stack) :-                                       
      533 -    pop("+", V1, !Stack),                                     
      534 -    pop("+", V2, !Stack),                                     
      532 +operator_add(!Array, !Ptr) :-                                 
      533 +    datastack.pop("+", V1, !Array, !Ptr),                     
      534 +    datastack.pop("+", V2, !Array, !Ptr),                     
      535      ( if V1 = intval(I1), V2 = intval(I2) then
      536 -        push(intval(I1 + I2), !Stack)                         
      536 +        datastack.push(intval(I1 + I2), !Array, !Ptr)         
      537      else if V1 = intval(_) then
      538          throw(type_error("int", V2))
      539      else
     ...
      544  % -: ( int int -- int ) Subtract: a b - computes a - b
      545  %-------------------------------------------------------------
           ----------%
      546  
      547 -operator_sub(!Stack) :-                                       
      548 -    pop("-", V1, !Stack),                                     
      549 -    pop("-", V2, !Stack),                                     
      547 +operator_sub(!Array, !Ptr) :-                                 
      548 +    datastack.pop("-", V1, !Array, !Ptr),                     
      549 +    datastack.pop("-", V2, !Array, !Ptr),                     
      550      ( if V1 = intval(I1), V2 = intval(I2) then
      551 -        push(intval(I2 - I1), !Stack)                         
      551 +        datastack.push(intval(I2 - I1), !Array, !Ptr)         
      552      else if V1 = intval(_) then
      553          throw(type_error("int", V2))
      554      else
     ...
      559  % *: ( int int -- int ) Multiply two integers
      560  %-------------------------------------------------------------
           ----------%
      561  
      562 -operator_mul(!Stack) :-                                       
      563 -    pop("*", V1, !Stack),                                     
      564 -    pop("*", V2, !Stack),                                     
      562 +operator_mul(!Array, !Ptr) :-                                 
      563 +    datastack.pop("*", V1, !Array, !Ptr),                     
      564 +    datastack.pop("*", V2, !Array, !Ptr),                     
      565      ( if V1 = intval(I1), V2 = intval(I2) then
      566 -        push(intval(I1 * I2), !Stack)                         
      566 +        datastack.push(intval(I1 * I2), !Array, !Ptr)         
      567      else if V1 = intval(_) then
      568          throw(type_error("int", V2))
      569      else

● Update(src/operators.m)
  ⎿  Added 20 lines, removed 20 lines                                    
      574  % >: ( int int -- int ) Greater than: a b > is 0 if a > b, els
           e 1
      575  %-------------------------------------------------------------
           ----------%
      576  
      577 -operator_gt(!Stack) :-                                        
      578 -    pop(">", V1, !Stack),                                     
      579 -    pop(">", V2, !Stack),                                     
      577 +operator_gt(!Array, !Ptr) :-                                  
      578 +    datastack.pop(">", V1, !Array, !Ptr),                     
      579 +    datastack.pop(">", V2, !Array, !Ptr),                     
      580      ( if V1 = intval(I1), V2 = intval(I2) then
      581 -        ( if I2 > I1 then push(intval(0), !Stack)             
      582 -        else push(intval(1), !Stack)                          
      581 +        ( if I2 > I1 then datastack.push(intval(0), !Array, !P
          +tr)                                                           
      582 +        else datastack.push(intval(1), !Array, !Ptr)          
      583          )
      584      else if V1 = intval(_) then
      585          throw(type_error("int", V2))
     ...
      591  % <: ( int int -- int ) Less than: a b < is 0 if a < b, else 1
      592  %-------------------------------------------------------------
           ----------%
      593  
      594 -operator_lt(!Stack) :-                                        
      595 -    pop("<", V1, !Stack),                                     
      596 -    pop("<", V2, !Stack),                                     
      594 +operator_lt(!Array, !Ptr) :-                                  
      595 +    datastack.pop("<", V1, !Array, !Ptr),                     
      596 +    datastack.pop("<", V2, !Array, !Ptr),                     
      597      ( if V1 = intval(I1), V2 = intval(I2) then
      598 -        ( if I2 < I1 then push(intval(0), !Stack)             
      599 -        else push(intval(1), !Stack)                          
      598 +        ( if I2 < I1 then datastack.push(intval(0), !Array, !P
          +tr)                                                           
      599 +        else datastack.push(intval(1), !Array, !Ptr)          
      600          )
      601      else if V1 = intval(_) then
      602          throw(type_error("int", V2))
     ...
      608  % >=: ( int int -- int ) Greater or equal: a b >= is 0 if a >=
            b, else 1
      609  %-------------------------------------------------------------
           ----------%
      610  
      611 -operator_gte(!Stack) :-                                       
      612 -    pop(">=", V1, !Stack),                                    
      613 -    pop(">=", V2, !Stack),                                    
      611 +operator_gte(!Array, !Ptr) :-                                 
      612 +    datastack.pop(">=", V1, !Array, !Ptr),                    
      613 +    datastack.pop(">=", V2, !Array, !Ptr),                    
      614      ( if V1 = intval(I1), V2 = intval(I2) then
      615 -        ( if I2 >= I1 then push(intval(0), !Stack)            
      616 -        else push(intval(1), !Stack)                          
      615 +        ( if I2 >= I1 then datastack.push(intval(0), !Array, !
          +Ptr)                                                          
      616 +        else datastack.push(intval(1), !Array, !Ptr)          
      617          )
      618      else if V1 = intval(_) then
      619          throw(type_error("int", V2))
     ...
      625  % <=: ( int int -- int ) Less or equal: a b <= is 0 if a <= b,
            else 1
      626  %-------------------------------------------------------------
           ----------%
      627  
      628 -operator_lte(!Stack) :-                                       
      629 -    pop("<=", V1, !Stack),                                    
      630 -    pop("<=", V2, !Stack),                                    
      628 +operator_lte(!Array, !Ptr) :-                                 
      629 +    datastack.pop("<=", V1, !Array, !Ptr),                    
      630 +    datastack.pop("<=", V2, !Array, !Ptr),                    
      631      ( if V1 = intval(I1), V2 = intval(I2) then
      632 -        ( if I2 =< I1 then push(intval(0), !Stack)            
      633 -        else push(intval(1), !Stack)                          
      632 +        ( if I2 =< I1 then datastack.push(intval(0), !Array, !
          +Ptr)                                                          
      633 +        else datastack.push(intval(1), !Array, !Ptr)          
      634          )
      635      else if V1 = intval(_) then
      636          throw(type_error("int", V2))

● Update(src/operators.m)
  ⎿  Added 17 lines, removed 17 lines                                    
      643  % For arrays: key must be int. For maps: key must be quoted id
           entifier ('name).
      644  %-------------------------------------------------------------
           ----------%
      645  
      646 -operator_get(!Stack) :-                                       
      647 -    pop("@", KeyVal, !Stack),                                 
      648 -    pop("@", ContainerVal, !Stack),                           
      649 -    ( if ContainerVal = arrayval(Array), KeyVal = intval(Index
          -) then                                                        
      650 -        ( if array.semidet_lookup(Array, Index, Elem) then    
      651 -            push(Elem, !Stack)                                
      646 +operator_get(!Array, !Ptr) :-                                 
      647 +    datastack.pop("@", KeyVal, !Array, !Ptr),                 
      648 +    datastack.pop("@", ContainerVal, !Array, !Ptr),           
      649 +    ( if ContainerVal = arrayval(Arr), KeyVal = intval(Index) 
          +then                                                          
      650 +        ( if array.semidet_lookup(Arr, Index, Elem) then      
      651 +            datastack.push(Elem, !Array, !Ptr)                
      652          else
      653 -            throw(index_out_of_bounds(Index, array.size(Array)
          -))                                                            
      653 +            throw(index_out_of_bounds(Index, array.size(Arr)))
      654          )
      655      else if ContainerVal = mapval(Map), KeyVal = termval(ident
           ifier(NameId)) then
      656          ( if map.search(Map, NameId, Value) then
      657 -            push(Value, !Stack)                               
      657 +            datastack.push(Value, !Array, !Ptr)               
      658          else
      659              throw(undefined_name(NameId))
      660          )
      661      else if ContainerVal = termval(function(Terms)), KeyVal = 
           intval(Index) then
      662          ( if list.index0(Terms, Index, Term) then
      663 -            push(termval(Term), !Stack)                       
      663 +            datastack.push(termval(Term), !Array, !Ptr)       
      664          else
      665              throw(index_out_of_bounds(Index, list.length(Terms
           )))
      666          )
      667      else if ContainerVal = termval(generator(Terms)), KeyVal =
            intval(Index) then
      668          ( if list.index0(Terms, Index, Term) then
      669 -            push(termval(Term), !Stack)                       
      669 +            datastack.push(termval(Term), !Array, !Ptr)       
      670          else
      671              throw(index_out_of_bounds(Index, list.length(Terms
           )))
      672          )
     ...
      682  % #: ( container -- int ) Get length of array or size of map
      683  %-------------------------------------------------------------
           ----------%
      684  
      685 -operator_length(!Stack) :-                                    
      686 -    pop("#", V, !Stack),                                      
      687 -    ( if V = arrayval(Array) then                             
      688 -        push(intval(array.size(Array)), !Stack)               
      685 +operator_length(!Array, !Ptr) :-                              
      686 +    datastack.pop("#", V, !Array, !Ptr),                      
      687 +    ( if V = arrayval(Arr) then                               
      688 +        datastack.push(intval(array.size(Arr)), !Array, !Ptr) 
      689      else if V = mapval(Map) then
      690 -        push(intval(map.count(Map)), !Stack)                  
      690 +        datastack.push(intval(map.count(Map)), !Array, !Ptr)  
      691      else if V = termval(function(Terms)) then
      692 -        push(intval(list.length(Terms)), !Stack)              
      692 +        datastack.push(intval(list.length(Terms)), !Array, !Pt
          +r)                                                            
      693      else if V = termval(generator(Terms)) then
      694 -        push(intval(list.length(Terms)), !Stack)              
      694 +        datastack.push(intval(list.length(Terms)), !Array, !Pt
          +r)                                                            
      695      else
      696          throw(type_error("array, map, or quoted function/gener
           ator", V))
      697      ).

● Update(src/operators.m)
  ⎿  Added 5 lines, removed 5 lines                                      
      700  % =: ( a b -- int ) Test equality: push 0 if equal, 1 if not e
           qual
      701  %-------------------------------------------------------------
           ----------%
      702  
      703 -operator_eq(!Stack) :-                                        
      704 -    pop("=", V1, !Stack),                                     
      705 -    pop("=", V2, !Stack),                                     
      703 +operator_eq(!Array, !Ptr) :-                                  
      704 +    datastack.pop("=", V1, !Array, !Ptr),                     
      705 +    datastack.pop("=", V2, !Array, !Ptr),                     
      706      ( if values_equal(V1, V2, Equal) then
      707 -        ( Equal = yes, push(intval(0), !Stack)                
      708 -        ; Equal = no, push(intval(1), !Stack)                 
      707 +        ( Equal = yes, datastack.push(intval(0), !Array, !Ptr)
      708 +        ; Equal = no, datastack.push(intval(1), !Array, !Ptr) 
      709          )
      710      else
      711          throw(type_error("comparable values", V1))

● Update(src/operators.m)
  ⎿  Added 18 lines, removed 18 lines                                    
      789  % ?: ( cond then else -- result ) If cond is 0, push then; oth
           erwise push else
      790  %-------------------------------------------------------------
           ----------%
      791  
      792 -operator_ite(!Stack) :-                                       
      793 -    pop("?", C, !Stack),                                      
      794 -    pop("?", B, !Stack),                                      
      795 -    pop("?", A, !Stack),                                      
      792 +operator_ite(!Array, !Ptr) :-                                 
      793 +    datastack.pop("?", C, !Array, !Ptr),                      
      794 +    datastack.pop("?", B, !Array, !Ptr),                      
      795 +    datastack.pop("?", A, !Array, !Ptr),                      
      796      ( if A = intval(0) then
      797 -        push(B, !Stack)                                       
      797 +        datastack.push(B, !Array, !Ptr)                       
      798      else if A = intval(_) then
      799 -        push(C, !Stack)                                       
      799 +        datastack.push(C, !Array, !Ptr)                       
      800      else
      801          throw(type_error("int", A))
      802      ).
     ...
      805  % .: ( -- nil ) Push nil onto the stack
      806  %-------------------------------------------------------------
           ----------%
      807  
      808 -operator_nil(!Stack) :-                                       
      809 -    push(nilval, !Stack).                                     
      808 +operator_nil(!Array, !Ptr) :-                                 
      809 +    datastack.push(nilval, !Array, !Ptr).                     
      810  
      811  %-------------------------------------------------------------
           ----------%
      812  % ,: ( tail head -- cons ) Create a cons cell with head and ta
           il
      813  %-------------------------------------------------------------
           ----------%
      814  
      815 -operator_cons(!Stack) :-                                      
      816 -    pop(",", Head, !Stack),                                   
      817 -    pop(",", Tail, !Stack),                                   
      818 -    push(consval(Head, Tail), !Stack).                        
      815 +operator_cons(!Array, !Ptr) :-                                
      816 +    datastack.pop(",", Head, !Array, !Ptr),                   
      817 +    datastack.pop(",", Tail, !Array, !Ptr),                   
      818 +    datastack.push(consval(Head, Tail), !Array, !Ptr).        
      819  
      820  %-------------------------------------------------------------
           ----------%
      821  % fst: ( cons -- head ) Get the first element (head) of a cons
            cell
      822  %-------------------------------------------------------------
           ----------%
      823  
      824 -operator_fst(!Stack) :-                                       
      825 -    pop("fst", V, !Stack),                                    
      824 +operator_fst(!Array, !Ptr) :-                                 
      825 +    datastack.pop("fst", V, !Array, !Ptr),                    
      826      ( if V = consval(H, _) then
      827 -        push(H, !Stack)                                       
      827 +        datastack.push(H, !Array, !Ptr)                       
      828      else
      829          throw(type_error("cons", V))
      830      ).
     ...
      833  % snd: ( cons -- tail ) Get the second element (tail) of a con
           s cell
      834  %-------------------------------------------------------------
           ----------%
      835  
      836 -operator_snd(!Stack) :-                                       
      837 -    pop("snd", V, !Stack),                                    
      836 +operator_snd(!Array, !Ptr) :-                                 
      837 +    datastack.pop("snd", V, !Array, !Ptr),                    
      838      ( if V = consval(_, T) then
      839 -        push(T, !Stack)                                       
      839 +        datastack.push(T, !Array, !Ptr)                       
      840      else
      841          throw(type_error("cons", V))
      842      ).

● Update(src/operators.m)
  ⎿  Added 2 lines, removed 2 lines                                      
      845  % write: ( a -- ) Pop and print value in executable (round-tri
           ppable) form
      846  %-------------------------------------------------------------
           ----------%
      847  
      848 -operator_write(ST, !Stack, !IO) :-                            
      849 -    pop("write", V, !Stack),                                  
      848 +operator_write(ST, !Array, !Ptr, !IO) :-                      
      849 +    datastack.pop("write", V, !Array, !Ptr),                  
      850      io.write_string(value_to_write_string(ST, V), !IO).
      851  
      852  %-------------------------------------------------------------
           ----------%

● Update(src/operators.m)
  ⎿  Added 22 lines, removed 22 lines                                    
      900  % fwrite: ( value file -- ) Write value to file in executable 
           form
      901  %-------------------------------------------------------------
           ----------%
      902  
      903 -operator_fwrite(ST, !Stack, !IO) :-                           
      904 -    pop("fwrite", FileVal, !Stack),                           
      905 -    pop("fwrite", V, !Stack),                                 
      903 +operator_fwrite(ST, !Array, !Ptr, !IO) :-                     
      904 +    datastack.pop("fwrite", FileVal, !Array, !Ptr),           
      905 +    datastack.pop("fwrite", V, !Array, !Ptr),                 
      906      Filename = value_to_string(ST, FileVal),
      907      Content = value_to_write_string(ST, V),
      908      io.open_output(Filename, Result, !IO),
     ...
      920  % $: ( -- map ) Push an empty map onto the stack
      921  %-------------------------------------------------------------
           ----------%
      922  
      923 -operator_empty(!Stack) :-                                     
      924 -    push(mapval(map.init), !Stack).                           
      923 +operator_empty(!Array, !Ptr) :-                               
      924 +    datastack.push(mapval(map.init), !Array, !Ptr).           
      925  
      926  %-------------------------------------------------------------
           ----------%
      927  % keys: ( map -- array ) Get map keys as an array of quoted id
           entifiers
      928  %-------------------------------------------------------------
           ----------%
      929  
      930 -operator_keys(!Stack) :-                                      
      931 -    pop("keys", V, !Stack),                                   
      930 +operator_keys(!Array, !Ptr) :-                                
      931 +    datastack.pop("keys", V, !Array, !Ptr),                   
      932      ( if V = mapval(Map) then
      933          Keys = map.keys(Map),
      934          KeyTerms = list.map(
      935              (func(NameId) = termval(identifier(NameId))),
      936              Keys),
      937 -        push(arrayval(array.from_list(KeyTerms)), !Stack)     
      937 +        datastack.push(arrayval(array.from_list(KeyTerms)), !A
          +rray, !Ptr)                                                   
      938      else
      939          throw(type_error("map", V))
      940      ).
     ...
      943  % :: ( map val 'key -- map ) Store value in map under key, ret
           urn new map
      944  %-------------------------------------------------------------
           ----------%
      945  
      946 -operator_store(!Stack) :-                                     
      947 -    pop(":", KeyVal, !Stack),                                 
      948 -    pop(":", Val, !Stack),                                    
      949 -    pop(":", MapVal, !Stack),                                 
      946 +operator_store(!Array, !Ptr) :-                               
      947 +    datastack.pop(":", KeyVal, !Array, !Ptr),                 
      948 +    datastack.pop(":", Val, !Array, !Ptr),                    
      949 +    datastack.pop(":", MapVal, !Array, !Ptr),                 
      950      ( if MapVal = mapval(Map), KeyVal = termval(identifier(Nam
           eId)) then
      951          map.set(NameId, Val, Map, NewMap),
      952 -        push(mapval(NewMap), !Stack)                          
      952 +        datastack.push(mapval(NewMap), !Array, !Ptr)          
      953      else if MapVal = mapval(_) then
      954          throw(type_error("term", KeyVal))
      955      else
     ...
      960  % in: ( map 'key -- int ) Test if key exists in map: 0 if yes,
            1 if no
      961  %-------------------------------------------------------------
           ----------%
      962  
      963 -operator_in(!Stack) :-                                        
      964 -    pop("in", KeyVal, !Stack),                                
      965 -    pop("in", MapVal, !Stack),                                
      963 +operator_in(!Array, !Ptr) :-                                  
      964 +    datastack.pop("in", KeyVal, !Array, !Ptr),                
      965 +    datastack.pop("in", MapVal, !Array, !Ptr),                
      966      ( if MapVal = mapval(Map), KeyVal = termval(identifier(Nam
           eId)) then
      967          ( if map.contains(Map, NameId) then
      968 -            push(intval(0), !Stack)                           
      968 +            datastack.push(intval(0), !Array, !Ptr)           
      969          else
      970 -            push(intval(1), !Stack)                           
      970 +            datastack.push(intval(1), !Array, !Ptr)           
      971          )
      972      else if MapVal = mapval(_) then
      973          throw(type_error("term", KeyVal))
     ...
      979  % delete: ( map 'key -- map ) Remove key from map, return new 
           map
      980  %-------------------------------------------------------------
           ----------%
      981  
      982 -operator_delete(!Stack) :-                                    
      983 -    pop("delete", KeyVal, !Stack),                            
      984 -    pop("delete", MapVal, !Stack),                            
      982 +operator_delete(!Array, !Ptr) :-                              
      983 +    datastack.pop("delete", KeyVal, !Array, !Ptr),            
      984 +    datastack.pop("delete", MapVal, !Array, !Ptr),            
      985      ( if MapVal = mapval(Map), KeyVal = termval(identifier(Nam
           eId)) then
      986          map.delete(NameId, Map, NewMap),
      987 -        push(mapval(NewMap), !Stack)                          
      987 +        datastack.push(mapval(NewMap), !Array, !Ptr)          
      988      else if MapVal = mapval(_) then
      989          throw(type_error("term", KeyVal))
      990      else

● Update(src/operators.m)
  ⎿  Added 48 lines, removed 48 lines                                    
       996  % Each returns 0 if true, 1 if false (following Froth's boole
            an convention)
       997  %------------------------------------------------------------
            -----------%
       998  
       999 -operator_is_int(!Stack) :-                                   
      1000 -    pop("isInt", V, !Stack),                                 
      1001 -    ( if V = intval(_) then push(intval(0), !Stack)          
      1002 -    else push(intval(1), !Stack)                             
       999 +operator_is_int(!Array, !Ptr) :-                             
      1000 +    datastack.pop("isInt", V, !Array, !Ptr),                 
      1001 +    ( if V = intval(_) then datastack.push(intval(0), !Array,
           + !Ptr)                                                       
      1002 +    else datastack.push(intval(1), !Array, !Ptr)             
      1003      ).
      1004  
      1005 -operator_is_string(!Stack) :-                                
      1006 -    pop("isString", V, !Stack),                              
      1007 -    ( if V = stringval(_) then push(intval(0), !Stack)       
      1008 -    else push(intval(1), !Stack)                             
      1005 +operator_is_string(!Array, !Ptr) :-                          
      1006 +    datastack.pop("isString", V, !Array, !Ptr),              
      1007 +    ( if V = stringval(_) then datastack.push(intval(0), !Arr
           +ay, !Ptr)                                                    
      1008 +    else datastack.push(intval(1), !Array, !Ptr)             
      1009      ).
      1010  
      1011 -operator_is_array(!Stack) :-                                 
      1012 -    pop("isArray", V, !Stack),                               
      1013 -    ( if V = arrayval(_) then push(intval(0), !Stack)        
      1014 -    else push(intval(1), !Stack)                             
      1011 +operator_is_array(!Array, !Ptr) :-                           
      1012 +    datastack.pop("isArray", V, !Array, !Ptr),               
      1013 +    ( if V = arrayval(_) then datastack.push(intval(0), !Arra
           +y, !Ptr)                                                     
      1014 +    else datastack.push(intval(1), !Array, !Ptr)             
      1015      ).
      1016  
      1017 -operator_is_map(!Stack) :-                                   
      1018 -    pop("isMap", V, !Stack),                                 
      1019 -    ( if V = mapval(_) then push(intval(0), !Stack)          
      1020 -    else push(intval(1), !Stack)                             
      1017 +operator_is_map(!Array, !Ptr) :-                             
      1018 +    datastack.pop("isMap", V, !Array, !Ptr),                 
      1019 +    ( if V = mapval(_) then datastack.push(intval(0), !Array,
           + !Ptr)                                                       
      1020 +    else datastack.push(intval(1), !Array, !Ptr)             
      1021      ).
      1022  
      1023 -operator_is_nil(!Stack) :-                                   
      1024 -    pop("isNil", V, !Stack),                                 
      1025 -    ( if V = nilval then push(intval(0), !Stack)             
      1026 -    else push(intval(1), !Stack)                             
      1023 +operator_is_nil(!Array, !Ptr) :-                             
      1024 +    datastack.pop("isNil", V, !Array, !Ptr),                 
      1025 +    ( if V = nilval then datastack.push(intval(0), !Array, !P
           +tr)                                                          
      1026 +    else datastack.push(intval(1), !Array, !Ptr)             
      1027      ).
      1028  
      1029 -operator_is_cons(!Stack) :-                                  
      1030 -    pop("isCons", V, !Stack),                                
      1031 -    ( if V = consval(_, _) then push(intval(0), !Stack)      
      1032 -    else push(intval(1), !Stack)                             
      1029 +operator_is_cons(!Array, !Ptr) :-                            
      1030 +    datastack.pop("isCons", V, !Array, !Ptr),                
      1031 +    ( if V = consval(_, _) then datastack.push(intval(0), !Ar
           +ray, !Ptr)                                                   
      1032 +    else datastack.push(intval(1), !Array, !Ptr)             
      1033      ).
      1034  
      1035 -operator_is_ident(!Stack) :-                                 
      1036 -    pop("isIdent", V, !Stack),                               
      1037 -    ( if V = termval(identifier(_)) then push(intval(0), !Sta
           -ck)                                                          
      1038 -    else push(intval(1), !Stack)                             
      1035 +operator_is_ident(!Array, !Ptr) :-                           
      1036 +    datastack.pop("isIdent", V, !Array, !Ptr),               
      1037 +    ( if V = termval(identifier(_)) then datastack.push(intva
           +l(0), !Array, !Ptr)                                          
      1038 +    else datastack.push(intval(1), !Array, !Ptr)             
      1039      ).
      1040  
      1041 -operator_is_binder(!Stack) :-                                
      1042 -    pop("isBinder", V, !Stack),                              
      1043 -    ( if V = termval(binder(_)) then push(intval(0), !Stack) 
      1044 -    else push(intval(1), !Stack)                             
      1041 +operator_is_binder(!Array, !Ptr) :-                          
      1042 +    datastack.pop("isBinder", V, !Array, !Ptr),              
      1043 +    ( if V = termval(binder(_)) then datastack.push(intval(0)
           +, !Array, !Ptr)                                              
      1044 +    else datastack.push(intval(1), !Array, !Ptr)             
      1045      ).
      1046  
      1047 -operator_is_func(!Stack) :-                                  
      1048 -    pop("isFunc", V, !Stack),                                
      1049 -    ( if V = termval(function(_)) then push(intval(0), !Stack
           -)                                                            
      1050 -    else push(intval(1), !Stack)                             
      1047 +operator_is_func(!Array, !Ptr) :-                            
      1048 +    datastack.pop("isFunc", V, !Array, !Ptr),                
      1049 +    ( if V = termval(function(_)) then datastack.push(intval(
           +0), !Array, !Ptr)                                            
      1050 +    else datastack.push(intval(1), !Array, !Ptr)             
      1051      ).
      1052  
      1053 -operator_is_gen(!Stack) :-                                   
      1054 -    pop("isGen", V, !Stack),                                 
      1055 -    ( if V = termval(generator(_)) then push(intval(0), !Stac
           -k)                                                           
      1056 -    else push(intval(1), !Stack)                             
      1053 +operator_is_gen(!Array, !Ptr) :-                             
      1054 +    datastack.pop("isGen", V, !Array, !Ptr),                 
      1055 +    ( if V = termval(generator(_)) then datastack.push(intval
           +(0), !Array, !Ptr)                                           
      1056 +    else datastack.push(intval(1), !Array, !Ptr)             
      1057      ).
      1058  
      1059 -operator_is_quote(!Stack) :-                                 
      1060 -    pop("isQuote", V, !Stack),                               
      1061 -    ( if V = termval(quoted(_)) then push(intval(0), !Stack) 
      1062 -    else push(intval(1), !Stack)                             
      1059 +operator_is_quote(!Array, !Ptr) :-                           
      1060 +    datastack.pop("isQuote", V, !Array, !Ptr),               
      1061 +    ( if V = termval(quoted(_)) then datastack.push(intval(0)
           +, !Array, !Ptr)                                              
      1062 +    else datastack.push(intval(1), !Array, !Ptr)             
      1063      ).
      1064  
      1065 -operator_is_apply(!Stack) :-                                 
      1066 -    pop("isApply", V, !Stack),                               
      1067 -    ( if V = termval(apply_term) then push(intval(0), !Stack)
      1068 -    else push(intval(1), !Stack)                             
      1065 +operator_is_apply(!Array, !Ptr) :-                           
      1066 +    datastack.pop("isApply", V, !Array, !Ptr),               
      1067 +    ( if V = termval(apply_term) then datastack.push(intval(0
           +), !Array, !Ptr)                                             
      1068 +    else datastack.push(intval(1), !Array, !Ptr)             
      1069      ).
      1070  
      1071  %------------------------------------------------------------
            -----------%

● Update(src/operators.m)
  ⎿  Added 29 lines, removed 29 lines                                    
      1072  % isValue: ( a -- int ) Test if value is a quoted value term
      1073  %------------------------------------------------------------
            -----------%
      1074  
      1075 -operator_is_value(!Stack) :-                                 
      1076 -    pop("isValue", V, !Stack),                               
      1077 -    ( if V = termval(value(_)) then push(intval(0), !Stack)  
      1078 -    else push(intval(1), !Stack)                             
      1075 +operator_is_value(!Array, !Ptr) :-                           
      1076 +    datastack.pop("isValue", V, !Array, !Ptr),               
      1077 +    ( if V = termval(value(_)) then datastack.push(intval(0),
           + !Array, !Ptr)                                               
      1078 +    else datastack.push(intval(1), !Array, !Ptr)             
      1079      ).
      1080  
      1081  %------------------------------------------------------------
            -----------%
      1082  % unwrap: ( 'value -- value ) Extract value from quoted value
             term
      1083  %------------------------------------------------------------
            -----------%
      1084  
      1085 -operator_unwrap(!Stack) :-                                   
      1086 -    pop("unwrap", V, !Stack),                                
      1085 +operator_unwrap(!Array, !Ptr) :-                             
      1086 +    datastack.pop("unwrap", V, !Array, !Ptr),                
      1087      ( if V = termval(value(Inner)) then
      1088 -        push(Inner, !Stack)                                  
      1088 +        datastack.push(Inner, !Array, !Ptr)                  
      1089      else if V = termval(quoted(InnerTerm)) then
      1090 -        push(termval(InnerTerm), !Stack)                     
      1090 +        datastack.push(termval(InnerTerm), !Array, !Ptr)     
      1091      else
      1092          throw(type_error("quoted value or quoted term", V))
      1093      ).
     ...
      1096  % intern: ( string|'ident|'binder -- int ) Get the intern id
      1097  %------------------------------------------------------------
            -----------%
      1098  
      1099 -operator_intern(!Stack) :-                                   
      1100 -    pop("intern", V, !Stack),                                
      1099 +operator_intern(!Array, !Ptr) :-                             
      1100 +    datastack.pop("intern", V, !Array, !Ptr),                
      1101      ( if V = stringval(Id) then
      1102 -        push(intval(Id), !Stack)                             
      1102 +        datastack.push(intval(Id), !Array, !Ptr)             
      1103      else if V = termval(identifier(Id)) then
      1104 -        push(intval(Id), !Stack)                             
      1104 +        datastack.push(intval(Id), !Array, !Ptr)             
      1105      else if V = termval(binder(Id)) then
      1106 -        push(intval(Id), !Stack)                             
      1106 +        datastack.push(intval(Id), !Array, !Ptr)             
      1107      else
      1108          throw(type_error("string, identifier, or binder", V))
      1109      ).
     ...
      1112  % idToString: ( int -- string ) Create string from intern id
      1113  %------------------------------------------------------------
            -----------%
      1114  
      1115 -operator_id_to_string(!Stack) :-                             
      1116 -    pop("idToString", V, !Stack),                            
      1115 +operator_id_to_string(!Array, !Ptr) :-                       
      1116 +    datastack.pop("idToString", V, !Array, !Ptr),            
      1117      ( if V = intval(Id) then
      1118 -        push(stringval(Id), !Stack)                          
      1118 +        datastack.push(stringval(Id), !Array, !Ptr)          
      1119      else
      1120          throw(type_error("int", V))
      1121      ).
     ...
      1124  % idToIdent: ( int -- 'ident ) Create quoted identifier from 
            intern id
      1125  %------------------------------------------------------------
            -----------%
      1126  
      1127 -operator_id_to_ident(!Stack) :-                              
      1128 -    pop("idToIdent", V, !Stack),                             
      1127 +operator_id_to_ident(!Array, !Ptr) :-                        
      1128 +    datastack.pop("idToIdent", V, !Array, !Ptr),             
      1129      ( if V = intval(Id) then
      1130 -        push(termval(identifier(Id)), !Stack)                
      1130 +        datastack.push(termval(identifier(Id)), !Array, !Ptr)
      1131      else
      1132          throw(type_error("int", V))
      1133      ).
     ...
      1136  % idToBinder: ( int -- 'binder ) Create quoted binder from in
            tern id
      1137  %------------------------------------------------------------
            -----------%
      1138  
      1139 -operator_id_to_binder(!Stack) :-                             
      1140 -    pop("idToBinder", V, !Stack),                            
      1139 +operator_id_to_binder(!Array, !Ptr) :-                       
      1140 +    datastack.pop("idToBinder", V, !Array, !Ptr),            
      1141      ( if V = intval(Id) then
      1142 -        push(termval(binder(Id)), !Stack)                    
      1142 +        datastack.push(termval(binder(Id)), !Array, !Ptr)    
      1143      else
      1144          throw(type_error("int", V))
      1145      ).
     ...
      1148  % isOperator: ( 'ident -- int ) Test if identifier is an oper
            ator name
      1149  %------------------------------------------------------------
            -----------%
      1150  
      1151 -operator_is_operator(OpTable, !Stack) :-                     
      1152 -    pop("isOperator", V, !Stack),                            
      1151 +operator_is_operator(OpTable, !Array, !Ptr) :-               
      1152 +    datastack.pop("isOperator", V, !Array, !Ptr),            
      1153      ( if V = termval(identifier(Id)) then
      1154          ( if map.contains(OpTable, Id) then
      1155 -            push(intval(0), !Stack)                          
      1155 +            datastack.push(intval(0), !Array, !Ptr)          
      1156          else
      1157 -            push(intval(1), !Stack)                          
      1157 +            datastack.push(intval(1), !Array, !Ptr)          
      1158          )
      1159      else
      1160          throw(type_error("identifier", V))
     ...
      1164  % arity: ( 'ident -- int ) Get the arity of an operator
      1165  %------------------------------------------------------------
            -----------%
      1166  
      1167 -operator_arity_op(OpTable, !Stack) :-                        
      1168 -    pop("arity", V, !Stack),                                 
      1167 +operator_arity_op(OpTable, !Array, !Ptr) :-                  
      1168 +    datastack.pop("arity", V, !Array, !Ptr),                 
      1169      ( if V = termval(identifier(Id)) then
      1170          ( if map.search(OpTable, Id, Info) then
      1171 -            push(intval(Info ^ oi_arity), !Stack)            
      1171 +            datastack.push(intval(Info ^ oi_arity), !Array, !
           +Ptr)                                                         
      1172          else
      1173              throw(type_error("operator", V))
      1174          )

● Now let me update the remaining operators including the tricky operator_stack:

● Update(src/operators.m)
  ⎿  Added 23 lines, removed 20 lines                                    
      1180  % stack: ( ... -- array ) Convert entire stack to an array
      1181  %------------------------------------------------------------
            -----------%
      1182  
      1183 -operator_stack(!Stack) :-                                    
      1184 -    % Stack is LIFO (top first), reverse to get push order (b
           -ottom first)                                                 
      1185 -    Array = array.from_reverse_list(!.Stack),                
      1186 -    !:Stack = [arrayval(Array)].                             
      1183 +operator_stack(!Array, !Ptr) :-                              
      1184 +    % Extract all values from the stack (bottom to top order)
      1185 +    List = datastack.to_list(!.Array, !.Ptr),                
      1186 +    ResultArray = array.from_list(List),                     
      1187 +    % Clear the stack and push the result                    
      1188 +    !:Ptr = 0,                                               
      1189 +    datastack.push(arrayval(ResultArray), !Array, !Ptr).     
      1190  
      1191  %------------------------------------------------------------
            -----------%
      1192  % time: ( -- int ) Push current clock ticks
      1193  %------------------------------------------------------------
            -----------%
      1194  
      1192 -operator_time(!Stack, !IO) :-                                
      1195 +operator_time(!Array, !Ptr, !IO) :-                          
      1196      time.clock(Ticks, !IO),
      1194 -    push(intval(Ticks), !Stack).                             
      1197 +    datastack.push(intval(Ticks), !Array, !Ptr).             
      1198  
      1199  %------------------------------------------------------------
            -----------%
      1200  % close: ( env body -- closure ) Create a closure from env an
            d body
      1201  %------------------------------------------------------------
            -----------%
      1202  
      1200 -operator_close(!Stack) :-                                    
      1201 -    pop("close", BodyVal, !Stack),                           
      1202 -    pop("close", EnvVal, !Stack),                            
      1203 +operator_close(!Array, !Ptr) :-                              
      1204 +    datastack.pop("close", BodyVal, !Array, !Ptr),           
      1205 +    datastack.pop("close", EnvVal, !Array, !Ptr),            
      1206      ( if EnvVal = mapval(Env), BodyVal = termval(function(Bod
            y)) then
      1204 -        push(closureval(Env, Body), !Stack)                  
      1207 +        datastack.push(closureval(Env, Body), !Array, !Ptr)  
      1208      else if EnvVal = mapval(_) then
      1209          throw(type_error("function", BodyVal))
      1210      else
     ...
      1215  % closureEnv: ( closure -- env ) Get the environment from a c
            losure
      1216  %------------------------------------------------------------
            -----------%
      1217  
      1215 -operator_closure_env(!Stack) :-                              
      1216 -    pop("closureEnv", V, !Stack),                            
      1218 +operator_closure_env(!Array, !Ptr) :-                        
      1219 +    datastack.pop("closureEnv", V, !Array, !Ptr),            
      1220      ( if V = closureval(Env, _) then
      1218 -        push(mapval(Env), !Stack)                            
      1221 +        datastack.push(mapval(Env), !Array, !Ptr)            
      1222      else
      1223          throw(type_error("closure", V))
      1224      ).
     ...
      1227  % closureBody: ( closure -- body ) Get the body from a closur
            e
      1228  %------------------------------------------------------------
            -----------%
      1229  
      1227 -operator_closure_body(!Stack) :-                             
      1228 -    pop("closureBody", V, !Stack),                           
      1230 +operator_closure_body(!Array, !Ptr) :-                       
      1231 +    datastack.pop("closureBody", V, !Array, !Ptr),           
      1232      ( if V = closureval(_, Body) then
      1230 -        push(termval(function(Body)), !Stack)                
      1233 +        datastack.push(termval(function(Body)), !Array, !Ptr)
      1234      else
      1235          throw(type_error("closure", V))
      1236      ).
     ...
      1239  % isClosure: ( a -- int ) Test if value is a closure
      1240  %------------------------------------------------------------
            -----------%
      1241  
      1239 -operator_is_closure(!Stack) :-                               
      1240 -    pop("isClosure", V, !Stack),                             
      1241 -    ( if V = closureval(_, _) then push(intval(0), !Stack)   
      1242 -    else push(intval(1), !Stack)                             
      1242 +operator_is_closure(!Array, !Ptr) :-                         
      1243 +    datastack.pop("isClosure", V, !Array, !Ptr),             
      1244 +    ( if V = closureval(_, _) then datastack.push(intval(0), 
           +!Array, !Ptr)                                                
      1245 +    else datastack.push(intval(1), !Array, !Ptr)             
      1246      ).
      1247  
      1248  %------------------------------------------------------------
            -----------%

● Now let me update eval.m:

● Update(src/eval.m)
  ⎿  Added 6 lines, removed 2 lines                                      
       6  :- module eval.
       7  :- interface.
       8  
       9 +:- import_module array.                                        
      10  :- import_module io.
      11  :- import_module list.
      12  :- import_module types.
      13  
      14  %--------------------------------------------------------------
          ---------%
      15  
      15 -    % eval_terms(OpTable, BaseDir, Terms, !Env, !Stack, !ST, !I
         -O):                                                            
      16 +    % eval_terms(OpTable, BaseDir, Terms, !Env, !StackArray, !S
         +tackPtr, !ST, !IO):                                            
      17      % Evaluate a list of terms, updating the environment and st
          ack.
      18      % OpTable is read-only (fixed at engine startup).
      19      % BaseDir is used to resolve relative paths in imports.
      20      % StringTable is threaded through (may grow with dynamic im
          ports).
      21 +    % Stack is represented as an array and pointer (for efficie
         +nt operations).                                                
      22      % Throws eval_error on failure.
      23      %
      24  :- pred eval_terms(operator_table::in, string::in, list(term)::
          in,
      23 -    env::in, env::out, stack::in, stack::out,                  
      25 +    env::in, env::out,                                         
      26 +    array(value)::array_di, array(value)::array_uo,            
      27 +    int::in, int::out,                                         
      28      string_table::in, string_table::out, io::di, io::uo) is det
          .
      29  
      30      % Environment operations.

● Update(src/eval.m)
  ⎿  Added 1 line, removed 1 line                                        
      36  
      37  :- implementation.
      38  
      39 -:- import_module array.                                        
      39 +:- import_module datastack.                                    
      40  :- import_module dir.
      41  :- import_module exception.
      42  :- import_module lexer.

● Update(src/eval.m)
  ⎿  Added 14 lines, removed 13 lines                                    
      59  % Main evaluation
      60  %--------------------------------------------------------------
          ---------%
      61  
      62 -eval_terms(_, _, [], !Env, !Stack, !ST, !IO).                  
      63 -eval_terms(OpTable, BaseDir, [Term | Terms], !Env, !Stack, !ST,
         - !IO) :-                                                       
      64 -    eval_term(OpTable, BaseDir, Term, !Env, !Stack, !ST, !IO), 
      65 -    eval_terms(OpTable, BaseDir, Terms, !Env, !Stack, !ST, !IO)
         -.                                                              
      62 +eval_terms(_, _, [], !Env, !Array, !Ptr, !ST, !IO).            
      63 +eval_terms(OpTable, BaseDir, [Term | Terms], !Env, !Array, !Ptr
         +, !ST, !IO) :-                                                 
      64 +    eval_term(OpTable, BaseDir, Term, !Env, !Array, !Ptr, !ST, 
         +!IO),                                                          
      65 +    eval_terms(OpTable, BaseDir, Terms, !Env, !Array, !Ptr, !ST
         +, !IO).                                                        
      66  
      67  :- pred eval_term(operator_table::in, string::in, term::in, env
          ::in, env::out,
      68 -    stack::in, stack::out, string_table::in, string_table::out,
      68 +    array(value)::array_di, array(value)::array_uo,            
      69 +    int::in, int::out, string_table::in, string_table::out,    
      70      io::di, io::uo) is det.
      71  
      71 -eval_term(OpTable, BaseDir, Term, !Env, !Stack, !ST, !IO) :-   
      72 +eval_term(OpTable, BaseDir, Term, !Env, !Array, !Ptr, !ST, !IO)
         + :-                                                            
      73      (
      74          Term = identifier(NameId),
      74 -        eval_identifier(OpTable, BaseDir, NameId, !Env, !Stack,
         - !ST, !IO)                                                     
      75 +        eval_identifier(OpTable, BaseDir, NameId, !Env, !Array,
         + !Ptr, !ST, !IO)                                               
      76      ;
      77          Term = binder(NameId),
      77 -        eval_binder(NameId, !Env, !Stack)                      
      78 +        eval_binder(NameId, !Env, !Array, !Ptr)                
      79      ;
      80          Term = function(Terms),
      80 -        eval_function(Terms, !.Env, !Stack)                    
      81 +        eval_function(Terms, !.Env, !Array, !Ptr)              
      82      ;
      83          Term = generator(Terms),
      83 -        eval_generator(OpTable, BaseDir, Terms, !Env, !Stack, !
         -ST, !IO)                                                       
      84 +        eval_generator(OpTable, BaseDir, Terms, !Env, !Array, !
         +Ptr, !ST, !IO)                                                 
      85      ;
      86          Term = quoted(T),
      86 -        push(termval(T), !Stack)                               
      87 +        datastack.push(termval(T), !Array, !Ptr)               
      88      ;
      89          Term = value(V),
      89 -        push(V, !Stack)                                        
      90 +        datastack.push(V, !Array, !Ptr)                        
      91      ;
      92          Term = apply_term,
      92 -        eval_apply(OpTable, BaseDir, !Env, !Stack, !ST, !IO)   
      93 +        eval_apply(OpTable, BaseDir, !Env, !Array, !Ptr, !ST, !
         +IO)                                                            
      94      ).
      95  
      96  %--------------------------------------------------------------
          ---------%

● Update(src/eval.m)
  ⎿  Added 8 lines, removed 6 lines                                      
       98  %-------------------------------------------------------------
           ----------%
       99  
      100  :- pred eval_identifier(operator_table::in, string::in, string
           _id::in,
      101 -    env::in, env::out, stack::in, stack::out,                 
      101 +    env::in, env::out,                                        
      102 +    array(value)::array_di, array(value)::array_uo,           
      103 +    int::in, int::out,                                        
      104      string_table::in, string_table::out, io::di, io::uo) is de
           t.
      105  
      104 -eval_identifier(OpTable, BaseDir, NameId, !Env, !Stack, !ST, !
          -IO) :-                                                        
      106 +eval_identifier(OpTable, BaseDir, NameId, !Env, !Array, !Ptr, 
          +!ST, !IO) :-                                                  
      107      ( if get_env(NameId, V, !.Env) then
      106 -        push(V, !Stack)                                       
      108 +        datastack.push(V, !Array, !Ptr)                       
      109      else if map.search(OpTable, NameId, Info) then
      110          ( if Info ^ oi_operator = op_import then
      111              % import is special: it can modify Env and ST
      110 -            eval_import(OpTable, BaseDir, !Env, !Stack, !ST, !
          -IO)                                                           
      112 +            eval_import(OpTable, BaseDir, !Env, !Array, !Ptr, 
          +!ST, !IO)                                                     
      113          else if Info ^ oi_operator = op_restore then
      114              % restore is special: it replaces the current Env
      113 -            eval_restore(!Env, !Stack)                        
      115 +            eval_restore(!Env, !Array, !Ptr)                  
      116          else
      117              operators.eval_operator(OpTable, !.ST, Info ^ oi_o
           perator, !.Env,
      116 -                !Stack, !IO)                                  
      118 +                !Array, !Ptr, !IO)                            
      119          )
      120      else
      121          throw(undefined_name(NameId))

● Update(src/eval.m)
  ⎿  Added 48 lines, removed 17 lines                                    
      126  %-------------------------------------------------------------
           ----------%
      127  
      128  :- pred eval_binder(string_id::in, env::in, env::out,
      129 -    stack::in, stack::out) is det.                            
      129 +    array(value)::array_di, array(value)::array_uo,           
      130 +    int::in, int::out) is det.                                
      131  
      131 -eval_binder(NameId, !Env, !Stack) :-                          
      132 -    pop("binder", V, !Stack),                                 
      132 +eval_binder(NameId, !Env, !Array, !Ptr) :-                    
      133 +    datastack.pop("binder", V, !Array, !Ptr),                 
      134      set_env(NameId, V, !Env).
      135  
      136  %-------------------------------------------------------------
           ----------%
     ...
      138  %-------------------------------------------------------------
           ----------%
      139  
      140  :- pred eval_function(list(term)::in, env::in,
      140 -    stack::in, stack::out) is det.                            
      141 +    array(value)::array_di, array(value)::array_uo,           
      142 +    int::in, int::out) is det.                                
      143  
      144  % A closure is represented as: closureval(Env, Terms)
      143 -eval_function(Terms, Env, !Stack) :-                          
      145 +eval_function(Terms, Env, !Array, !Ptr) :-                    
      146      Closure = closureval(Env, Terms),
      145 -    push(Closure, !Stack).                                    
      147 +    datastack.push(Closure, !Array, !Ptr).                    
      148  
      149  %-------------------------------------------------------------
           ----------%
      150  % Generator evaluation
      151  %-------------------------------------------------------------
           ----------%
      152  
      153  :- pred eval_generator(operator_table::in, string::in, list(te
           rm)::in,
      152 -    env::in, env::out, stack::in, stack::out,                 
      154 +    env::in, env::out,                                        
      155 +    array(value)::array_di, array(value)::array_uo,           
      156 +    int::in, int::out,                                        
      157      string_table::in, string_table::out, io::di, io::uo) is de
           t.
      158  
      155 -eval_generator(OpTable, BaseDir, Terms, !Env, !Stack, !ST, !IO
          -) :-                                                          
      156 -    % Save current stack, evaluate with empty stack           
      157 -    SavedStack = !.Stack,                                     
      158 -    !:Stack = [],                                             
      159 -    eval_terms(OpTable, BaseDir, Terms, !Env, !Stack, !ST, !IO
          -),                                                            
      160 -    % Convert stack to array (reverse since stack is LIFO)    
      161 -    Array = array.from_reverse_list(!.Stack),                 
      162 -    % Restore stack and push array                            
      163 -    !:Stack = SavedStack,                                     
      164 -    push(arrayval(Array), !Stack).                            
      159 +eval_generator(OpTable, BaseDir, Terms, !Env, !Array, !Ptr, !S
          +T, !IO) :-                                                    
      160 +    % Save current stack pointer                              
      161 +    SavedPtr = !.Ptr,                                         
      162 +    % Evaluate generator terms (they push values onto the stac
          +k)                                                            
      163 +    eval_terms(OpTable, BaseDir, Terms, !Env, !Array, !Ptr, !S
          +T, !IO),                                                      
      164 +    % Extract values pushed by the generator as an array      
      165 +    extract_range(!.Array, SavedPtr, !.Ptr, ResultArray),     
      166 +    % Restore stack pointer and push the result array         
      167 +    !:Ptr = SavedPtr,                                         
      168 +    datastack.push(arrayval(ResultArray), !Array, !Ptr).      
      169  
      170 +    % extract_range(Array, Start, End, Result):               
      171 +    % Extract values from Array[Start..End-1] into a new array
          +.                                                             
      172 +    %                                                         
      173 +:- pred extract_range(array(value)::in, int::in, int::in,     
      174 +    array(value)::out) is det.                                
      175 +                                                              
      176 +extract_range(SrcArray, Start, End, Result) :-                
      177 +    Len = End - Start,                                        
      178 +    ( if Len =< 0 then                                        
      179 +        Result = array.init(0, nilval)                        
      180 +    else                                                      
      181 +        Result0 = array.init(Len, nilval),                    
      182 +        extract_range_loop(SrcArray, Start, 0, Len, Result0, R
          +esult)                                                        
      183 +    ).                                                        
      184 +                                                              
      185 +:- pred extract_range_loop(array(value)::in, int::in, int::in,
          + int::in,                                                     
      186 +    array(value)::array_di, array(value)::array_uo) is det.   
      187 +                                                              
      188 +extract_range_loop(Src, SrcIdx, DstIdx, Len, !Dst) :-         
      189 +    ( if DstIdx >= Len then                                   
      190 +        true                                                  
      191 +    else                                                      
      192 +        array.lookup(Src, SrcIdx, Value),                     
      193 +        array.set(DstIdx, Value, !Dst),                       
      194 +        extract_range_loop(Src, SrcIdx + 1, DstIdx + 1, Len, !
          +Dst)                                                          
      195 +    ).                                                        
      196 +                                                              
      197  %-------------------------------------------------------------
           ----------%
      198  % apply (!)
      199  %-------------------------------------------------------------
           ----------%

● Update(src/eval.m)
  ⎿  Added 7 lines, removed 6 lines                                      
      199  %-------------------------------------------------------------
           ----------%
      200  
      201  :- pred eval_apply(operator_table::in, string::in, env::in, en
           v::out,
      202 -    stack::in, stack::out, string_table::in, string_table::out
          -,                                                             
      202 +    array(value)::array_di, array(value)::array_uo,           
      203 +    int::in, int::out, string_table::in, string_table::out,   
      204      io::di, io::uo) is det.
      205  
      205 -eval_apply(OpTable, BaseDir, Env, Env, !Stack, !ST, !IO) :-   
      206 -    pop("!", V, !Stack),                                      
      206 +eval_apply(OpTable, BaseDir, Env, Env, !Array, !Ptr, !ST, !IO)
          + :-                                                           
      207 +    datastack.pop("!", V, !Array, !Ptr),                      
      208      ( if V = closureval(ClosureEnv, Terms) then
      209          % Evaluate with closure's env, then discard env change
           s (lexical scoping)
      209 -        eval_terms(OpTable, BaseDir, Terms, ClosureEnv, _, !St
          -ack, !ST, !IO)                                                
      210 +        eval_terms(OpTable, BaseDir, Terms, ClosureEnv, _, !Ar
          +ray, !Ptr, !ST, !IO)                                          
      211      else if V = termval(identifier(Id)), map.search(OpTable, I
           d, Info) then
      212          ( if Info ^ oi_operator = op_import then
      213              % import is special: it can modify Env (but we dis
           card here like closures)
      213 -            eval_import(OpTable, BaseDir, Env, _, !Stack, !ST,
          - !IO)                                                         
      214 +            eval_import(OpTable, BaseDir, Env, _, !Array, !Ptr
          +, !ST, !IO)                                                   
      215          else
      216              % Apply a quoted operator
      217              operators.eval_operator(OpTable, !.ST, Info ^ oi_o
           perator, Env,
      217 -                !Stack, !IO)                                  
      218 +                !Array, !Ptr, !IO)                            
      219          )
      220      else
      221          throw(type_error("closure or operator", V))

● Update(src/eval.m)
  ⎿  Added 6 lines, removed 5 lines                                      
      226  %-------------------------------------------------------------
           ----------%
      227  
      228  :- pred eval_import(operator_table::in, string::in, env::in, e
           nv::out,
      229 -    stack::in, stack::out, string_table::in, string_table::out
          -,                                                             
      230 -    io::di, io::uo) is det.                                   
      229 +    array(value)::array_di, array(value)::array_uo,           
      230 +    int::in, int::out,                                        
      231 +    string_table::in, string_table::out, io::di, io::uo) is de
          +t.                                                            
      232  
      232 -eval_import(OpTable, BaseDir, !Env, !Stack, !ST, !IO) :-      
      233 -    pop("import", V, !Stack),                                 
      233 +eval_import(OpTable, BaseDir, !Env, !Array, !Ptr, !ST, !IO) :-
      234 +    datastack.pop("import", V, !Array, !Ptr),                 
      235      RelFilename = operators.value_to_string(!.ST, V),
      236      % Resolve relative paths using BaseDir
      237      ( if dir.path_name_is_absolute(RelFilename) then
     ...
      249              parser.parse(Tokens, ParseResult),
      250              (
      251                  ParseResult = ok(Terms),
      251 -                eval_terms(OpTable, NewBaseDir, Terms, !Env, !
          -Stack, !ST, !IO)                                              
      252 +                eval_terms(OpTable, NewBaseDir, Terms, !Env, !
          +Array, !Ptr, !ST, !IO)                                        
      253              ;
      254                  ParseResult = error(ParseError),
      255                  throw_parse_error(Filename, ParseError)

● Update(src/eval.m)
  ⎿  Added 5 lines, removed 3 lines                                      
      313  % restore: ( map -- ) Replace current environment with the giv
           en map
      314  %-------------------------------------------------------------
           ----------%
      315  
      316 -:- pred eval_restore(env::in, env::out, stack::in, stack::out)
          - is det.                                                      
      316 +:- pred eval_restore(env::in, env::out,                       
      317 +    array(value)::array_di, array(value)::array_uo,           
      318 +    int::in, int::out) is det.                                
      319  
      318 -eval_restore(!Env, !Stack) :-                                 
      319 -    pop("restore", V, !Stack),                                
      320 +eval_restore(!Env, !Array, !Ptr) :-                           
      321 +    datastack.pop("restore", V, !Array, !Ptr),                
      322      ( if V = mapval(NewEnv) then
      323          !:Env = NewEnv
      324      else

● Now let me update froth.m:

● Update(src/froth.m)
  ⎿  Added 2 lines                                                       
      14  
      15  :- implementation.
      16  
      17 +:- import_module array.                                        
      18  :- import_module bool.
      19 +:- import_module datastack.                                    
      20  :- import_module dir.
      21  :- import_module eval.
      22  :- import_module exception.

● Update(src/froth.m)
  ⎿  Added 3 lines, removed 2 lines                                      
      179              parser.parse(Tokens, ParseResult),
      180              (
      181                  ParseResult = ok(Terms),
      182 +                datastack.init(Array0, Ptr0),                 
      183                  try_io(eval_terms_wrapper(OpTable, LibDir, ST1
           , Terms,
      183 -                    map.init, []), EvalResult, !IO),          
      184 +                    map.init, Array0, Ptr0), EvalResult, !IO),
      185                  (
      185 -                    EvalResult = succeeded({ST, Env, _Stack}),
      186 +                    EvalResult = succeeded({ST, Env, _Array, _
          +Ptr}),                                                        
      187                      Result = stdlib_ok(OpTable, ST, Env)
      188                  ;
      189                      EvalResult = exception(Exn),

● Update(src/froth.m)
  ⎿  Added 4 lines, removed 2 lines                                      
      240      % Initialize state
      241      ( if Opts ^ opt_no_stdlib = yes then
      242          init_without_stdlib(OpTable, ST0, Env0),
      243 -        run_actions(Opts, OpTable, ST0, Env0, [], !IO)        
      243 +        datastack.init(Array0, Ptr0),                         
      244 +        run_actions(Opts, OpTable, ST0, Env0, Array0, Ptr0, !I
          +O)                                                            
      245      else
      246          init_with_stdlib(InitResult, !IO),
      247          (
      248              InitResult = init_ok(OpTable, ST0, Env0),
      248 -            run_actions(Opts, OpTable, ST0, Env0, [], !IO)    
      249 +            datastack.init(Array0, Ptr0),                     
      250 +            run_actions(Opts, OpTable, ST0, Env0, Array0, Ptr0
          +, !IO)                                                        
      251          ;
      252              InitResult = init_error,
      253              io.set_exit_status(1, !IO)

● Update(src/froth.m)
  ⎿  Added 15 lines, removed 12 lines                                    
      259  %-------------------------------------------------------------
           ----------%
      260  
      261  :- pred run_actions(options::in, operator_table::in,
      262 -    string_table::in, env::in, stack::in, io::di, io::uo) is c
          -c_multi.                                                      
      262 +    string_table::in, env::in,                                
      263 +    array(value)::array_di, int::in, io::di, io::uo) is cc_mul
          +ti.                                                           
      264  
      264 -run_actions(Opts, OpTable, ST0, Env0, Stack0, !IO) :-         
      265 +run_actions(Opts, OpTable, ST0, Env0, Array0, Ptr0, !IO) :-   
      266      Actions = Opts ^ opt_actions,
      267      (
      268          Actions = [],
      269          % No actions: start REPL
      269 -        start_repl(Opts, OpTable, ST0, Env0, Stack0, !IO)     
      270 +        start_repl(Opts, OpTable, ST0, Env0, Array0, Ptr0, !IO
          +)                                                             
      271      ;
      272          Actions = [_ | _],
      272 -        execute_actions(Actions, OpTable, ST0, ST, Env0, Env, 
          -Stack0, Stack,                                                
      273 -            yes, Success, !IO),                               
      273 +        execute_actions(Actions, OpTable, ST0, ST, Env0, Env, 
          +Array0, Array,                                                
      274 +            Ptr0, Ptr, yes, Success, !IO),                    
      275          (
      276              Success = yes,
      277              ( if Opts ^ opt_interactive = yes then
      277 -                start_repl(Opts, OpTable, ST, Env, Stack, !IO)
      278 +                start_repl(Opts, OpTable, ST, Env, Array, Ptr,
          + !IO)                                                         
      279              else
      280                  true
      281              )
     ...
      287  
      288  :- pred execute_actions(list(action)::in, operator_table::in,
      289      string_table::in, string_table::out,
      289 -    env::in, env::out, stack::in, stack::out,                 
      290 +    env::in, env::out,                                        
      291 +    array(value)::array_di, array(value)::array_uo,           
      292 +    int::in, int::out,                                        
      293      bool::in, bool::out, io::di, io::uo) is cc_multi.
      294  
      292 -execute_actions([], _, !ST, !Env, !Stack, !Success, !IO).     
      293 -execute_actions([Action | Rest], OpTable, !ST, !Env, !Stack, !
          -Success, !IO) :-                                              
      295 +execute_actions([], _, !ST, !Env, !Array, !Ptr, !Success, !IO)
          +.                                                             
      296 +execute_actions([Action | Rest], OpTable, !ST, !Env, !Array, !
          +Ptr, !Success, !IO) :-                                        
      297      (
      298          !.Success = no
      299          % Skip remaining actions if we already failed
     ...
      301          !.Success = yes,
      302          (
      303              Action = exec_code(Code),
      301 -            execute_code(OpTable, Code, !ST, !Env, !Stack, !Su
          -ccess, !IO)                                                   
      304 +            execute_code(OpTable, Code, !ST, !Env, !Array, !Pt
          +r, !Success, !IO)                                             
      305          ;
      306              Action = exec_file(File),
      304 -            execute_file(OpTable, File, !ST, !Env, !Stack, !Su
          -ccess, !IO)                                                   
      307 +            execute_file(OpTable, File, !ST, !Env, !Array, !Pt
          +r, !Success, !IO)                                             
      308          ),
      306 -        execute_actions(Rest, OpTable, !ST, !Env, !Stack, !Suc
          -cess, !IO)                                                    
      309 +        execute_actions(Rest, OpTable, !ST, !Env, !Array, !Ptr
          +, !Success, !IO)                                              
      310      ).
      311  
      312  :- pred execute_code(operator_table::in, string::in,

● Update(src/froth.m)
  ⎿  Added 23 lines, removed 17 lines                                    
      311  
      312  :- pred execute_code(operator_table::in, string::in,
      313      string_table::in, string_table::out,
      314 -    env::in, env::out, stack::in, stack::out,                 
      314 +    env::in, env::out,                                        
      315 +    array(value)::array_di, array(value)::array_uo,           
      316 +    int::in, int::out,                                        
      317      bool::in, bool::out, io::di, io::uo) is cc_multi.
      318  
      317 -execute_code(OpTable, Code, ST0, ST, Env0, Env, Stack0, Stack,
          - _, Success, !IO) :-                                          
      319 +execute_code(OpTable, Code, ST0, ST, Env0, Env, Array0, Array,
          + Ptr0, Ptr,                                                   
      320 +        _, Success, !IO) :-                                   
      321      lexer.tokenize(Code, ST0, LexResult),
      322      (
      323          LexResult = ok(Tokens, ST1),
     ...
      325          (
      326              ParseResult = ok(Terms),
      327              % Use "." as BaseDir for code strings (current dir
           ectory)
      325 -            try_io(eval_terms_wrapper(OpTable, ".", ST1, Terms
          -, Env0, Stack0),                                              
      326 -                EvalResult, !IO),                             
      328 +            try_io(eval_terms_wrapper(OpTable, ".", ST1, Terms
          +, Env0,                                                       
      329 +                Array0, Ptr0), EvalResult, !IO),              
      330              (
      328 -                EvalResult = succeeded({ST, Env, Stack}),     
      331 +                EvalResult = succeeded({ST, Env, Array, Ptr}),
      332                  Success = yes
      333              ;
      334                  EvalResult = exception(Exn),
      335                  ( if univ_to_type(Exn, EvalError) then
      336                      io.format("Runtime error: %s\n",
      337                          [s(types.format_error(ST1, EvalError))
           ], !IO),
      335 -                    ST = ST1, Env = Env0, Stack = Stack0,     
      338 +                    ST = ST1, Env = Env0, Array = Array0, Ptr 
          += Ptr0,                                                       
      339                      Success = no
      340                  else
      341                      rethrow(EvalResult)
     ...
      344          ;
      345              ParseResult = error(ParseError),
      346              report_parse_error(ParseError, !IO),
      344 -            ST = ST1, Env = Env0, Stack = Stack0,             
      347 +            ST = ST1, Env = Env0, Array = Array0, Ptr = Ptr0, 
      348              Success = no
      349          )
      350      ;
      351          LexResult = error(LexError),
      352          report_lex_error(LexError, !IO),
      350 -        ST = ST0, Env = Env0, Stack = Stack0,                 
      353 +        ST = ST0, Env = Env0, Array = Array0, Ptr = Ptr0,     
      354          Success = no
      355      ).
      356  
      357  :- pred execute_file(operator_table::in, string::in,
      358      string_table::in, string_table::out,
      356 -    env::in, env::out, stack::in, stack::out,                 
      359 +    env::in, env::out,                                        
      360 +    array(value)::array_di, array(value)::array_uo,           
      361 +    int::in, int::out,                                        
      362      bool::in, bool::out, io::di, io::uo) is cc_multi.
      363  
      359 -execute_file(OpTable, Filename, ST0, ST, Env0, Env, Stack0, St
          -ack, _, Success, !IO) :-                                      
      364 +execute_file(OpTable, Filename, ST0, ST, Env0, Env, Array0, Ar
          +ray, Ptr0, Ptr,                                               
      365 +        _, Success, !IO) :-                                   
      366      io.read_named_file_as_string(Filename, ReadResult, !IO),
      367      (
      368          ReadResult = ok(Content),
     ...
      373              parser.parse(Tokens, ParseResult),
      374              (
      375                  ParseResult = ok(Terms),
      370 -                try_io(eval_terms_wrapper(OpTable, BaseDir, ST
          -1, Terms, Env0, Stack0),                                      
      371 -                    EvalResult, !IO),                         
      376 +                try_io(eval_terms_wrapper(OpTable, BaseDir, ST
          +1, Terms, Env0,                                               
      377 +                    Array0, Ptr0), EvalResult, !IO),          
      378                  (
      373 -                    EvalResult = succeeded({ST, Env, Stack}), 
      379 +                    EvalResult = succeeded({ST, Env, Array, Pt
          +r}),                                                          
      380                      Success = yes
      381                  ;
      382                      EvalResult = exception(Exn),
      383                      ( if univ_to_type(Exn, EvalError) then
      384                          io.format("Runtime error: %s\n",
      385                              [s(types.format_error(ST1, EvalErr
           or))], !IO),
      380 -                        ST = ST1, Env = Env0, Stack = Stack0, 
      386 +                        ST = ST1, Env = Env0, Array = Array0, 
          +Ptr = Ptr0,                                                   
      387                          Success = no
      388                      else
      389                          rethrow(EvalResult)
     ...
      392              ;
      393                  ParseResult = error(ParseError),
      394                  report_parse_error(ParseError, !IO),
      389 -                ST = ST1, Env = Env0, Stack = Stack0,         
      395 +                ST = ST1, Env = Env0, Array = Array0, Ptr = Pt
          +r0,                                                           
      396                  Success = no
      397              )
      398          ;
      399              LexResult = error(LexError),
      400              report_lex_error(LexError, !IO),
      395 -            ST = ST0, Env = Env0, Stack = Stack0,             
      401 +            ST = ST0, Env = Env0, Array = Array0, Ptr = Ptr0, 
      402              Success = no
      403          )
      404      ;
      405          ReadResult = error(Error),
      406          io.format("Error reading '%s': %s\n",
      407              [s(Filename), s(io.error_message(Error))], !IO),
      402 -        ST = ST0, Env = Env0, Stack = Stack0,                 
      408 +        ST = ST0, Env = Env0, Array = Array0, Ptr = Ptr0,     
      409          Success = no
      410      ).
      411  

● Update(src/froth.m)
  ⎿  Added 19 lines, removed 16 lines                                    
      414  %-------------------------------------------------------------
           ----------%
      415  
      416  :- pred start_repl(options::in, operator_table::in, string_tab
           le::in,
      417 -    env::in, stack::in, io::di, io::uo) is cc_multi.          
      417 +    env::in, array(value)::array_di, int::in, io::di, io::uo) 
          +is cc_multi.                                                  
      418  
      419 -start_repl(Opts, OpTable, ST, Env, Stack, !IO) :-             
      419 +start_repl(Opts, OpTable, ST, Env, Array, Ptr, !IO) :-        
      420      ( if Opts ^ opt_quiet = no then
      421          io.write_string("Froth REPL. Press Ctrl-D to exit.\n",
            !IO)
      422      else
      423          true
      424      ),
      425 -    repl_loop(OpTable, ST, Env, Stack, !IO).                  
      425 +    repl_loop(OpTable, ST, Env, Array, Ptr, !IO).             
      426  
      427 -:- pred repl_loop(operator_table::in, string_table::in, env::i
          -n, stack::in,                                                 
      428 -    io::di, io::uo) is cc_multi.                              
      427 +:- pred repl_loop(operator_table::in, string_table::in, env::i
          +n,                                                            
      428 +    array(value)::array_di, int::in, io::di, io::uo) is cc_mul
          +ti.                                                           
      429  
      430 -repl_loop(OpTable, ST0, Env0, Stack0, !IO) :-                 
      430 +repl_loop(OpTable, ST0, Env0, Array0, Ptr0, !IO) :-           
      431      io.write_string("> ", !IO),
      432      io.flush_output(!IO),
      433      io.read_line_as_string(ReadResult, !IO),
      434      (
      435          ReadResult = ok(Line),
      436 -        repl_eval(OpTable, Line, ST0, ST, Env0, Env, Stack0, S
          -tack, !IO),                                                   
      437 -        repl_loop(OpTable, ST, Env, Stack, !IO)               
      436 +        repl_eval(OpTable, Line, ST0, ST, Env0, Env, Array0, A
          +rray, Ptr0, Ptr,                                              
      437 +            !IO),                                             
      438 +        repl_loop(OpTable, ST, Env, Array, Ptr, !IO)          
      439      ;
      440          ReadResult = eof,
      441          io.nl(!IO)
     ...
      448  
      449  :- pred repl_eval(operator_table::in, string::in,
      450      string_table::in, string_table::out,
      450 -    env::in, env::out, stack::in, stack::out, io::di, io::uo) 
          -is cc_multi.                                                  
      451 +    env::in, env::out,                                        
      452 +    array(value)::array_di, array(value)::array_uo,           
      453 +    int::in, int::out, io::di, io::uo) is cc_multi.           
      454  
      452 -repl_eval(OpTable, Input, ST0, ST, Env0, Env, Stack0, Stack, !
          -IO) :-                                                        
      455 +repl_eval(OpTable, Input, ST0, ST, Env0, Env, Array0, Array, P
          +tr0, Ptr, !IO) :-                                             
      456      lexer.tokenize(Input, ST0, LexResult),
      457      (
      458          LexResult = ok(Tokens, ST1),
      459          parser.parse(Tokens, ParseResult),
      460          (
      461              ParseResult = ok(Terms),
      459 -            try_io(eval_terms_wrapper(OpTable, ".", ST1, Terms
          -, Env0, Stack0),                                              
      460 -                Result, !IO),                                 
      462 +            try_io(eval_terms_wrapper(OpTable, ".", ST1, Terms
          +, Env0,                                                       
      463 +                Array0, Ptr0), Result, !IO),                  
      464              (
      462 -                Result = succeeded({ST, Env, Stack})          
      465 +                Result = succeeded({ST, Env, Array, Ptr})     
      466              ;
      467                  Result = exception(Exn),
      468                  ( if univ_to_type(Exn, EvalError) then
      469                      io.format("Runtime error: %s\n",
      470                          [s(types.format_error(ST1, EvalError))
           ], !IO),
      468 -                    ST = ST1, Env = Env0, Stack = Stack0      
      471 +                    ST = ST1, Env = Env0, Array = Array0, Ptr 
          += Ptr0                                                        
      472                  else
      473                      rethrow(Result)
      474                  )
     ...
      476          ;
      477              ParseResult = error(ParseError),
      478              report_parse_error(ParseError, !IO),
      476 -            ST = ST1, Env = Env0, Stack = Stack0              
      479 +            ST = ST1, Env = Env0, Array = Array0, Ptr = Ptr0  
      480          )
      481      ;
      482          LexResult = error(LexError),
      483          report_lex_error(LexError, !IO),
      481 -        ST = ST0, Env = Env0, Stack = Stack0                  
      484 +        ST = ST0, Env = Env0, Array = Array0, Ptr = Ptr0      
      485      ).
      486  
      487  %-------------------------------------------------------------
           ----------%

● Update(src/froth.m)
  ⎿  Added 6 lines, removed 3 lines                                      
      510  %-------------------------------------------------------------
           ----------%
      511  
      512  :- pred eval_terms_wrapper(operator_table::in, string::in, str
           ing_table::in,
      513 -    list(term)::in, env::in, stack::in, {string_table, env, st
          -ack}::out,                                                    
      513 +    list(term)::in, env::in, array(value)::array_di, int::in, 
      514 +    {string_table, env, array(value), int}::out,              
      515      io::di, io::uo) is det.
      516  
      516 -eval_terms_wrapper(OpTable, BaseDir, ST0, Terms, Env0, Stack0,
          - {ST, Env, Stack}, !IO) :-                                    
      517 -    eval.eval_terms(OpTable, BaseDir, Terms, Env0, Env, Stack0
          -, Stack, ST0, ST, !IO).                                       
      517 +eval_terms_wrapper(OpTable, BaseDir, ST0, Terms, Env0, Array0,
          + Ptr0,                                                        
      518 +        {ST, Env, Array, Ptr}, !IO) :-                        
      519 +    eval.eval_terms(OpTable, BaseDir, Terms, Env0, Env, Array0
          +, Array,                                                      
      520 +        Ptr0, Ptr, ST0, ST, !IO).                             
      521  
      522  %-------------------------------------------------------------
           ----------%
      523  % Error reporting

● Now let's try to build and test:

● Bash(mmc --make froth 2>&1)
  ⎿  Error: Exit code 1
     Making Mercury/int3s/froth.int3
     Making Mercury/int3s/types.int3
     Making Mercury/int3s/eval.int3
     Making Mercury/int3s/lexer.int3
     Making Mercury/int3s/operators.int3
     Making Mercury/int3s/parser.int3
     Making Mercury/ints/types.int
     Making Mercury/ints/parser.int
     Making Mercury/ints/operators.int
     … +53 lines (ctrl+o to see all)

● I need to add the import of int to eval.m:

● Update(src/eval.m)
  ⎿  Added 1 line                                                        
      39  :- import_module datastack.
      40  :- import_module dir.
      41  :- import_module exception.
      42 +:- import_module int.                                          
      43  :- import_module lexer.
      44  :- import_module map.
      45  :- import_module operators.

● Bash(mmc --make froth 2>&1)
  ⎿  Error: Exit code 1
     Making Mercury/int3s/eval.int3
     Making Mercury/ints/eval.int
     Making Mercury/cs/eval.c
     Making Mercury/cs/froth.c
     froth.m:328: In clause for `execute_code(in, in, in, out, in, out, array_di,
     froth.m:328:   array_uo, in, out, in, out, di, uo)':
     froth.m:328:   in argument 6 of call to predicate
     froth.m:328:   `froth.eval_terms_wrapper'/10:
     froth.m:328:   unique-mode error: the called procedure would clobber its

     … +15 lines (ctrl+o to see all)

● I see the issue - unique mode errors. When we pass the array to eval_terms_wrapper with array_di mode, it's considered consumed even if an exception is thrown. Let me fix this by reinitializing the stack on error:

● Update(src/froth.m)
  ⎿  Added 2 lines, removed 1 line                                       
      335                  ( if univ_to_type(Exn, EvalError) then
      336                      io.format("Runtime error: %s\n",
      337                          [s(types.format_error(ST1, EvalError))
           ], !IO),
      338 -                    ST = ST1, Env = Env0, Array = Array0, Ptr 
          -= Ptr0,                                                       
      338 +                    ST = ST1, Env = Env0,                     
      339 +                    datastack.init(Array, Ptr),               
      340                      Success = no
      341                  else
      342                      rethrow(EvalResult)

● Update(src/froth.m)
  ⎿  Added 2 lines, removed 1 line                                       
      384                      ( if univ_to_type(Exn, EvalError) then
      385                          io.format("Runtime error: %s\n",
      386                              [s(types.format_error(ST1, EvalErr
           or))], !IO),
      387 -                        ST = ST1, Env = Env0, Array = Array0, 
          -Ptr = Ptr0,                                                   
      387 +                        ST = ST1, Env = Env0,                 
      388 +                        datastack.init(Array, Ptr),           
      389                          Success = no
      390                      else
      391                          rethrow(EvalResult)

● Update(src/froth.m)
  ⎿  Added 2 lines, removed 1 line                                       
      470                  ( if univ_to_type(Exn, EvalError) then
      471                      io.format("Runtime error: %s\n",
      472                          [s(types.format_error(ST1, EvalError))
           ], !IO),
      473 -                    ST = ST1, Env = Env0, Array = Array0, Ptr 
          -= Ptr0                                                        
      473 +                    ST = ST1, Env = Env0,                     
      474 +                    datastack.init(Array, Ptr)                
      475                  else
      476                      rethrow(Result)
      477                  )

● Bash(mmc --make froth 2>&1)
  ⎿  Making Mercury/int3s/froth.int3
     Making Mercury/ints/froth.int
     Making Mercury/cs/froth.c
     … +12 lines (ctrl+o to expand)

● The build succeeded. Now let's run the tests:

● Bash(cd /home/mark/Documents/projects/froth && ./run_tests.sh 2>&1)
  ⎿  PASS: add                     
     PASS: analysis
     PASS: apply_op
     … +53 lines (ctrl+o to expand)

● All 53 tests pass. Let me also verify the datastack tests still work:

● Bash(cd /home/mark/Documents/projects/froth/src && mmc --make      timeout: 1m 
      stack_test 2>&1 && ./stack_test)                               0s

  ⎿  Making Mercury/ints/stack_test.int
     Making Mercury/cs/stack_test.c
     Making Mercury/os/stack_test.o
     … +26 lines (ctrl+o to expand)

● All done. I've successfully updated the Froth evaluator to use the array-based datastack module. Here's a summary of the changes:

  types.m: Removed the list-based stack type and push/pop predicates.

  operators.m: Changed all 40+ operator predicates from stack::in, stack::out to array(value)::array_di, array(value)::array_uo, int::in, int::out, using datastack.push/datastack.pop.

  eval.m:
  - Updated all evaluation predicates to thread array and pointer separately
  - Added extract_range helper for generators (extracts values from stack range as array)
  - eval_generator now saves/restores just the stack pointer rather than copying the entire list

  froth.m: Updated all wrapper functions and REPL to use datastack.init and thread array/pointer. Fixed unique mode issues by reinitializing the stack on errors (since array_di consumes the array).

  All 53 Froth tests pass, along with the datastack unit tests. The array-based stack should provide better performance for stack-intensive operations by avoiding list allocations.

> commit this 

● Bash(cd /home/mark/Documents/projects/froth && git status)
  ⎿  On branch master                                   
     Changes to be committed:
       (use "git restore --staged <file>..." to unstage)
     … +10 lines (ctrl+o to expand)

● Bash(cd /home/mark/Documents/projects/froth && git diff --stat)
  ⎿  (No content)

● Bash(cd /home/mark/Documents/projects/froth && git log --oneline -5)
  ⎿  bcabeca add transcript 22                                  
     d085842 Add def-fn for definition-time closure optimization
     deb1278 add transcript 21
     … +2 lines (ctrl+o to expand)

● Bash(git diff --cached --stat)
  ⎿   src/datastack.m  | 161 ++++++++++++++
      src/eval.m       | 149 ++++++++-----
      src/froth.m      | 127 ++++++-----
     … +5 lines (ctrl+o to expand)

● Bash(git commit -m "Replace list-based stack with array-based datastack…)
  ⎿  [master 2230ee0] Replace list-based stack with array-based datastack
      6 files changed, 851 insertions(+), 430 deletions(-)
      create mode 100644 src/datastack.m
      create mode 100644 src/stack_test.m

● Bash(git log --oneline -3)
  ⎿  2230ee0 Replace list-based stack with array-based datastack
     bcabeca add transcript 22
     d085842 Add def-fn for definition-time closure optimization

● Done. Created commit 2230ee0 with the array-based datastack implementation.

> /context 
  ⎿  
      Context Usage
     ⛁ ⛀ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛀   claude-opus-4-5-20251101 · 191k/200k tokens (95%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ 
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ System prompt: 3.1k tokens (1.5%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ System tools: 14.8k tokens (7.4%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ Memory files: 74 tokens (0.0%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛁ Messages: 127.9k tokens (63.9%)
     ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁ ⛁   ⛶ Free space: 9k (4.6%)
     ⛁ ⛁ ⛁ ⛁ ⛶ ⛶ ⛶ ⛝ ⛝ ⛝   ⛝ Autocompact buffer: 45.0k tokens (22.5%)
     ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ 
     ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ ⛝ 
     
     Memory files · /memory
     └ CLAUDE.md: 19 tokens
     └ MERCURY.md: 55 tokens
     
     Skills and slash commands · /skills
     
     



