; Test codegen

; Helper to dump bytecode from start to end
{ /self /end /start
  start end < {
    start peek print " " print
    start 1 + end self self!
  } { } ?!
} /dump-impl
{ /end /start start end dump-impl dump-impl! } /dump-bytecode

; Test 1: Simple integers
'{ 1 2 3 } /func
0 tree-empty! func $ codegen!
/func-addr /code-map /next-addr
"func-addr=" print func-addr print " next-addr=" print next-addr println!

; Show bytecode (should be: 0 1 0 2 0 3 2)
; push-int=0, return=2
"bytecode: " print
0 next-addr dump-bytecode!
nl!

; Test 2: With string
'{ 42 "hello" } /func2
next-addr tree-empty! func2 $ codegen!
/func-addr2 /code-map2 /next-addr2
"func-addr2=" print func-addr2 print " next-addr2=" print next-addr2 println!

"bytecode2: " print
next-addr next-addr2 dump-bytecode!
nl!

; Test 3: With operator
'{ 1 2 + } /func3
next-addr2 tree-empty! func3 $ codegen!
/func-addr3 /code-map3 /next-addr3
"func-addr3=" print func-addr3 print " next-addr3=" print next-addr3 println!

; Should be: 0 1 0 2 1 2 2
; push-int=0, op=1, +=2, return=2
"bytecode3: " print
next-addr2 next-addr3 dump-bytecode!
nl!

; Test 4: Quoted terms (test execution, not bytecode, to avoid intern ID dependency)
"quoted terms: " print
next-addr3 tree-empty! '{ 'x '/y '! '42 '"hi" } $ codegen!
/func-addr4 /code-map4 /next-addr4
[] func-addr4 close ! /r5 /r4 /r3 /r2 /r1
r1 write " " print
r2 write " " print
r3 write " " print
r4 write " " print
r5 write nl!

; Test 5: Context variables (free variables)
; Function with two free variables: x and y
'{ x y + } /func5
func5 boundness! /func5-node /func5-term
next-addr4 tree-empty! func5-term func5-node codegen!
/func-addr5 /code-map5 /next-addr5
"func-addr5=" print func-addr5 print " next-addr5=" print next-addr5 println!

; Bytecode should be: push-context 0, push-context 1, op +, return
; push-context=4, op=1, +=2, return=2
"bytecode5: " print
next-addr4 next-addr5 dump-bytecode!
nl!

; Execute with context [10 20] - should return 30
"context test: " print
[10 20] func-addr5 close ! println!

; Test 6: Bound variable - simple binder with usage
; { /x x } should emit: enter-frame 1, pop-local 0, push-local 0, leave-frame 1, return
; Instruction codes: enter-frame=8, pop-local=7, push-local=6, leave-frame=9, return=2
'{ /x x } /func6
func6 boundness! liveness! slots! /func6-node /func6-term
next-addr5 tree-empty! func6-term func6-node codegen!
/func6-addr /code-map6 /next-addr6
"bytecode6: " print
next-addr5 next-addr6 dump-bytecode!
nl!

; Execute with context [] and arg 42 - should return 42
"bound test: " print
42 [] func6-addr close ! println!

; Test 7: Dead binder
; { /x 99 } should emit: pop-unused, push-int 99, return
; Instruction codes: pop-unused=5, push-int=0, return=2
'{ /x 99 } /func7
func7 boundness! liveness! slots! /func7-node /func7-term
next-addr6 tree-empty! func7-term func7-node codegen!
/func7-addr /code-map7 /next-addr7
"bytecode7: " print
next-addr6 next-addr7 dump-bytecode!
nl!

; Execute with arg 42 (discarded) - should return 99
"dead binder test: " print
42 [] func7-addr close ! println!

; Test 8: Multiple binders with addition
; { /x /y x y + } should emit: enter-frame 2, pop-local 0, pop-local 1, push-local 0, push-local 1, op +, leave-frame 2, return
'{ /x /y x y + } /func8
func8 boundness! liveness! slots! /func8-node /func8-term
next-addr7 tree-empty! func8-term func8-node codegen!
/func8-addr /code-map8 /next-addr8
"bytecode8: " print
next-addr7 next-addr8 dump-bytecode!
nl!

; Execute with args 10 and 3 - should return 13 (10 + 3)
"multi-binder test: " print
10 3 [] func8-addr close ! println!

; Test 9: Nested function with no captures
; { { 42 } } should emit: nested func first, then outer builds empty context and closes
'{ { 42 } } /func9
func9 boundness! liveness! slots! /func9-node /func9-term
next-addr8 tree-empty! func9-term func9-node codegen!
/func9-addr /code-map9 /next-addr9
"bytecode9 (nested func area): " print
next-addr8 func9-addr dump-bytecode!  ; nested function code
nl!
"bytecode9 (outer func area): " print
func9-addr next-addr9 dump-bytecode!  ; outer function code
nl!

; Execute: should return a closure that returns 42
"nested no-capture test: " print
[] func9-addr close ! !  ; call outer, then call the nested closure it returns
println!

; Test 10: Nested function capturing bound variable
; { /x { x } } - inner captures x from outer's frame
'{ /x { x } } /func10
func10 boundness! liveness! slots! /func10-node /func10-term
next-addr9 tree-empty! func10-term func10-node codegen!
/func10-addr /code-map10 /next-addr10
"bytecode10 (nested area): " print
next-addr9 func10-addr dump-bytecode!
nl!
"bytecode10 (outer area): " print
func10-addr next-addr10 dump-bytecode!
nl!

; Execute: pass 99 to outer, get closure, call it - should return 99
"nested capture-bound test: " print
99 [] func10-addr close ! !  ; outer returns closure, call it
println!

; Test 11: Nested function capturing free variable from outer
; Outer has free var y, nested captures it
'{ { y } } /func11-inner
'{ y { y } } /func11
func11 boundness! liveness! slots! /func11-node /func11-term
next-addr10 tree-empty! func11-term func11-node codegen!
/func11-addr /code-map11 /next-addr11
"bytecode11 (nested area): " print
next-addr10 func11-addr dump-bytecode!
nl!

; Execute with context [77] - outer pushes y, then returns closure that also uses y
"nested capture-free test: " print
[77] func11-addr close ! !  ; outer returns closure, call it
println!

; Test 12: Nested function capturing multiple vars (one bound, one free)
; { /x { x y + } } where y is free in outer
'{ /x { x y + } } /func12
func12 boundness! liveness! slots! /func12-node /func12-term
next-addr11 tree-empty! func12-term func12-node codegen!
/func12-addr /code-map12 /next-addr12

; Execute with arg 10 and context [5] (y=5) - nested should compute x+y = 10+5 = 15
"nested multi-capture test: " print
10 [5] func12-addr close ! !
println!

"done" println!
