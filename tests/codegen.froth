; Test codegen via compile-func
; compile-func runs boundness -> liveness -> slots -> codegen

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 2000 < { } { "ERROR: froth-bytecode-top >= 2000, test addresses may conflict" println! } ?!

; Helper to dump bytecode from start to end
{ /self /end /start
  start end < {
    start peek print " " print
    start 1 + end self self!
  } { } ?!
} /dump-impl
{ /end /start start end dump-impl dump-impl! } /dump-bytecode

; Test 1: Simple integers
tree-empty! 2000 '{ 1 2 3 } compile-func! /node /next-addr /code-map
node 'func-addr @ /func-addr
"func-addr=" print func-addr print " next-addr=" print next-addr println!

; Show bytecode (should be: 0 1 0 2 0 3 2)
; push-int=0, return=2
"bytecode: " print
func-addr next-addr dump-bytecode!
nl!

; Test 2: With string
code-map next-addr '{ 42 "hello" } compile-func! /node2 /next-addr2 /code-map2
node2 'func-addr @ /func-addr2
"func-addr2=" print func-addr2 print " next-addr2=" print next-addr2 println!

"bytecode2: " print
func-addr2 next-addr2 dump-bytecode!
nl!

; Test 3: With operator
code-map2 next-addr2 '{ 1 2 + } compile-func! /node3 /next-addr3 /code-map3
node3 'func-addr @ /func-addr3
"func-addr3=" print func-addr3 print " next-addr3=" print next-addr3 println!

; Should be: 0 1 0 2 1 2 2
; push-int=0, op=1, +=2, return=2
"bytecode3: " print
func-addr3 next-addr3 dump-bytecode!
nl!

; Test 4: Quoted terms (test execution, not bytecode, to avoid intern ID dependency)
"quoted terms: " print
code-map3 next-addr3 '{ 'x '/y '! '42 '"hi" } compile-func! /node4 /next-addr4 /code-map4
node4 'func-addr @ /func-addr4
[] func-addr4 close ! /r5 /r4 /r3 /r2 /r1
r1 write " " print
r2 write " " print
r3 write " " print
r4 write " " print
r5 write nl!

; Test 5: Context variables (free variables)
; Function with two free variables: x and y
code-map4 next-addr4 '{ x y + } compile-func! /node5 /next-addr5 /code-map5
node5 'func-addr @ /func-addr5
"func-addr5=" print func-addr5 print " next-addr5=" print next-addr5 println!

; Bytecode should be: push-context 0, push-context 1, op +, return
; push-context=4, op=1, +=2, return=2
"bytecode5: " print
func-addr5 next-addr5 dump-bytecode!
nl!

; Execute with context [10 20] - should return 30
"context test: " print
[10 20] func-addr5 close ! println!

; Test 6: Bound variable - simple binder with usage
; { /x x } should emit: enter-frame 1, pop-local 0, push-local 0, leave-frame 1, return
; Instruction codes: enter-frame=8, pop-local=7, push-local=6, leave-frame=9, return=2
code-map5 next-addr5 '{ /x x } compile-func! /node6 /next-addr6 /code-map6
node6 'func-addr @ /func6-addr
"bytecode6: " print
func6-addr next-addr6 dump-bytecode!
nl!

; Execute with context [] and arg 42 - should return 42
"bound test: " print
42 [] func6-addr close ! println!

; Test 7: Dead binder
; { /x 99 } should emit: pop-unused, push-int 99, return
; Instruction codes: pop-unused=5, push-int=0, return=2
code-map6 next-addr6 '{ /x 99 } compile-func! /node7 /next-addr7 /code-map7
node7 'func-addr @ /func7-addr
"bytecode7: " print
func7-addr next-addr7 dump-bytecode!
nl!

; Execute with arg 42 (discarded) - should return 99
"dead binder test: " print
42 [] func7-addr close ! println!

; Test 8: Multiple binders with addition
; { /x /y x y + } should emit: enter-frame 2, pop-local 0, pop-local 1, push-local 0, push-local 1, op +, leave-frame 2, return
code-map7 next-addr7 '{ /x /y x y + } compile-func! /node8 /next-addr8 /code-map8
node8 'func-addr @ /func8-addr
"bytecode8: " print
func8-addr next-addr8 dump-bytecode!
nl!

; Execute with args 10 and 3 - should return 13 (10 + 3)
"multi-binder test: " print
10 3 [] func8-addr close ! println!

; Test 9: Nested function with no captures
; { { 42 } } should emit: nested func first, then outer builds empty context and closes
code-map8 next-addr8 '{ { 42 } } compile-func! /node9 /next-addr9 /code-map9
node9 'func-addr @ /func9-addr
; Find nested func addr from body
node9 'body @ 0 @ 'func-addr @ /nested9-addr
"bytecode9 (nested func area): " print
nested9-addr func9-addr dump-bytecode!  ; nested function code
nl!
"bytecode9 (outer func area): " print
func9-addr next-addr9 dump-bytecode!  ; outer function code
nl!

; Execute: should return a closure that returns 42
"nested no-capture test: " print
[] func9-addr close ! !  ; call outer, then call the nested closure it returns
println!

; Test 10: Nested function capturing bound variable
; { /x { x } } - inner captures x from outer's frame
code-map9 next-addr9 '{ /x { x } } compile-func! /node10 /next-addr10 /code-map10
node10 'func-addr @ /func10-addr
node10 'body @ 1 @ 'func-addr @ /nested10-addr
"bytecode10 (nested area): " print
nested10-addr func10-addr dump-bytecode!
nl!
"bytecode10 (outer area): " print
func10-addr next-addr10 dump-bytecode!
nl!

; Execute: pass 99 to outer, get closure, call it - should return 99
"nested capture-bound test: " print
99 [] func10-addr close ! !  ; outer returns closure, call it
println!

; Test 11: Nested function capturing free variable from outer
; Outer has free var y, nested captures it
code-map10 next-addr10 '{ y { y } } compile-func! /node11 /next-addr11 /code-map11
node11 'func-addr @ /func11-addr
node11 'body @ 1 @ 'func-addr @ /nested11-addr
"bytecode11 (nested area): " print
nested11-addr func11-addr dump-bytecode!
nl!

; Execute with context [77] - outer pushes y, then returns closure that also uses y
"nested capture-free test: " print
[77] func11-addr close ! !  ; outer returns closure, call it
println!

; Test 12: Nested function capturing multiple vars (one bound, one free)
; { /x { x y + } } where y is free in outer
code-map11 next-addr11 '{ /x { x y + } } compile-func! /node12 /next-addr12 /code-map12
node12 'func-addr @ /func12-addr

; Execute with arg 10 and context [5] (y=5) - nested should compute x+y = 10+5 = 15
"nested multi-capture test: " print
10 [5] func12-addr close ! !
println!

; Test 13: Simple generator
code-map12 next-addr12 '{ [ 1 2 3 ] } compile-func! /node13 /next-addr13 /code-map13
node13 'func-addr @ /func13-addr

"generator test: " print
[] func13-addr close ! writeln!

; Test 14: Generator with outer bound variable
code-map13 next-addr13 '{ /x [ x x 1 + x 2 + ] } compile-func! /node14 /next-addr14 /code-map14
node14 'func-addr @ /func14-addr

"generator bound var test: " print
10 [] func14-addr close ! writeln!

; Test 15: Generator with free variable
code-map14 next-addr14 '{ [ y y 1 + ] } compile-func! /node15 /next-addr15 /code-map15
node15 'func-addr @ /func15-addr

"generator free var test: " print
[7] func15-addr close ! writeln!

; Test 16: Nested function inside generator
code-map15 next-addr15 '{ [ { 42 } ] } compile-func! /node16 /next-addr16 /code-map16
node16 'func-addr @ /func16-addr

"generator with nested func test: " print
[] func16-addr close ! 0 @ ! println!

; Test 17: Quoted function, generator, nested quote (via constant pool)
code-map16 next-addr16 '{ '{ 1 } '[ 2 ] ''x } compile-func! /node17 /next-addr17 /code-map17
node17 'func-addr @ /func17-addr

"quoted complex terms test: " print
[] func17-addr close ! /r3 /r2 /r1
r1 write " " print r2 write " " print r3 writeln!

; Test 18: Tail call
; Function { f! } should emit: push-context 0 (f), tail-call (17)
; No return instruction since we end with tail-call
code-map17 next-addr17 '{ f! } compile-func! /node18 /next-addr18 /code-map18
node18 'func-addr @ /func18-addr

"tail call bytecode: " print
func18-addr next-addr18 dump-bytecode!
nl!

; Verify: push-context=5, slot=0, tail-call=18
func18-addr peek 5 = { "push-context ok" } { "ERROR: expected push-context" } ?! println!
func18-addr 1 + peek 0 = { "slot 0 ok" } { "ERROR: expected slot 0" } ?! println!
func18-addr 2 + peek 18 = { "tail-call ok" } { "ERROR: expected tail-call" } ?! println!
next-addr18 func18-addr - 3 = { "length ok" } { "ERROR: expected length 3" } ?! println!

; Test 19: Non-tail call (middle of function)
; { f! 1 } should emit:
;   push-context 0 (f)
;   enter-frame 1
;   save-return-ptr
;   pop-local 0
;   call
;   push-local 0
;   restore-return-ptr
;   leave-frame 1
;   push-int 1
;   return
code-map18 next-addr18 '{ f! 1 } compile-func! /node19 /next-addr19 /code-map19
node19 'func-addr @ /func19-addr

"non-tail call bytecode: " print
func19-addr next-addr19 dump-bytecode!
nl!

; Verify key instructions are present
; push-context=5, call=13, save-return-ptr=14, restore-return-ptr=15
func19-addr peek 5 = { "push-context ok" } { "ERROR: expected push-context" } ?! println!
; call is at offset 7 (after push-context 0, enter-frame 1, save-return-ptr, pop-local 0)
func19-addr 7 + peek 13 = { "call ok" } { "ERROR: expected call" } ?! println!

; Test 20: Tail call execution test
; Use the existing bytecode from earlier tests instead of codegen
; Test 5 already has a simple function that returns 30 when given context [10 20]

; Create a function that just returns 42 using literal bytecode
instruction-table 'push-int @ /ocPushInt
instruction-table 'return @ /ocReturn
instruction-table 'push-context @ /ocPushContext
instruction-table 'tail-call @ /ocTailCall

; Emit inner function: push-int 42, return
[ocPushInt 42 ocReturn] next-addr19 emit-all-at! /after-inner
next-addr19 /inner-addr

; Emit outer function: push-context 0, tail-call (get closure from context and tail-call it)
[ocPushContext 0 ocTailCall] after-inner emit-all-at! /after-outer
after-inner /outer-addr

"inner-addr=" print inner-addr print " outer-addr=" print outer-addr println!

; Test inner directly
"inner direct call: " print
[] inner-addr close ! println!

; Now test via binding (close creates bytecodeval, bind it, then call)
[] inner-addr close /inner-bv
"inner-bv call: " print
inner-bv! println!

; Create bytecodeval for outer (captures inner as context slot 0)
[inner-bv] outer-addr close /outer-bv

; Execute outer - should tail-call inner and return 42
"tail call execution test: " print
outer-bv! println!

; Test 21: Non-tail call execution
; Compile a simple function that returns 10
code-map19 after-outer '{ 10 } compile-func! /ret10-node /after-ret10 /ret10-code-map
ret10-node 'func-addr @ /ret10-addr
[] ret10-addr close /ret10-bv

; Compile { f! 1 + } where f is in context slot 0
ret10-code-map after-ret10 '{ f! 1 + } compile-func! /func21-node /after-func21 /func21-code-map
func21-node 'func-addr @ /func21-addr

; Create bytecodeval with context containing ret10-bv
[ret10-bv] func21-addr close /func21-bv

"non-tail call execution: " print
func21-bv! println!
; Expected: 11 (f returns 10, then 10 + 1 = 11)

; Test 22: Multiple non-tail calls
; Compile { 5 }
func21-code-map after-func21 '{ 5 } compile-func! /ret5-node /after-ret5 /ret5-code-map
ret5-node 'func-addr @ /ret5-addr
[] ret5-addr close /ret5-bv

; Compile { f! g! + } where f and g are in context
ret5-code-map after-ret5 '{ f! g! + } compile-func! /func22-node /after-func22 /func22-code-map
func22-node 'func-addr @ /func22-addr

; Create bytecodeval with context [ret10-bv, ret5-bv]
[ret10-bv ret5-bv] func22-addr close /func22-bv

"multiple non-tail calls: " print
func22-bv! println!
; Expected: 15 (f returns 10, g returns 5, 10 + 5 = 15)

; Test 23: Non-tail call with bound variable
; Compile { /x f! x + } where f returns 100
func22-code-map after-func22 '{ 100 } compile-func! /ret100-node /after-ret100 /ret100-code-map
ret100-node 'func-addr @ /ret100-addr
[] ret100-addr close /ret100-bv

ret100-code-map after-ret100 '{ /x f! x + } compile-func! /func23-node /after-func23 /func23-code-map
func23-node 'func-addr @ /func23-addr

[ret100-bv] func23-addr close /func23-bv

"non-tail with bound var: " print
7 func23-bv! println!
; Expected: 107 (f returns 100, x=7, 100 + 7 = 107)

"done" println!
