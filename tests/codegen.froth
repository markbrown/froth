; Test codegen

; Helper to dump bytecode from start to end
{ /self /end /start
  start end < {
    start peek print " " print
    start 1 + end self self!
  } { } ?!
} /dump-impl
{ /end /start start end dump-impl dump-impl! } /dump-bytecode

; Test 1: Simple integers
'{ 1 2 3 } /func
0 tree-empty! func $ codegen!
/func-addr /code-map /next-addr
"func-addr=" print func-addr print " next-addr=" print next-addr println!

; Show bytecode (should be: 0 1 0 2 0 3 2)
; push-int=0, return=2
"bytecode: " print
0 next-addr dump-bytecode!
nl!

; Test 2: With string
'{ 42 "hello" } /func2
next-addr tree-empty! func2 $ codegen!
/func-addr2 /code-map2 /next-addr2
"func-addr2=" print func-addr2 print " next-addr2=" print next-addr2 println!

"bytecode2: " print
next-addr next-addr2 dump-bytecode!
nl!

; Test 3: With operator
'{ 1 2 + } /func3
next-addr2 tree-empty! func3 $ codegen!
/func-addr3 /code-map3 /next-addr3
"func-addr3=" print func-addr3 print " next-addr3=" print next-addr3 println!

; Should be: 0 1 0 2 1 2 2
; push-int=0, op=1, +=2, return=2
"bytecode3: " print
next-addr2 next-addr3 dump-bytecode!
nl!

"done" println!
