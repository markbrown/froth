; Test slot allocation

; Helper to test slots - shows body and max-slots
{ /map
  map 'body @ write " " print map 'max-slots @ println!
} /test-slots

; Basic cases
'{/x x} boundness! liveness! slots! test-slots!
; slot 0 for x

'{/x} boundness! liveness! slots! test-slots!
; dead binder, no slot

'{/x /y x y} boundness! liveness! slots! test-slots!
; two slots

'{/x /y y x} boundness! liveness! slots! test-slots!
; same two slots, different order

; Slot reuse
'{/x x /y y} boundness! liveness! slots! test-slots!
; slot 0 reused for y

'{/x x /y y /z z} boundness! liveness! slots! test-slots!
; slot 0 reused for all

'{/x /y x y /z z} boundness! liveness! slots! test-slots!
; slot 1 freed after y, reused for z

; Generator (same frame, slots thread through)
'{/x [/y y] x} boundness! liveness! slots! test-slots!
; generator uses slot 1

'{/x [/y y] /z z x} boundness! liveness! slots! test-slots!
; slot 1 reused for z after generator

'{/x x [/y y]} boundness! liveness! slots! test-slots!
; slot 0 reused inside generator

; Closure (own frame)
'{/x {/y y} x} boundness! liveness! slots! test-slots!
; closure has own frame with 1 slot

'{/x {/y /z y z}} boundness! liveness! slots! test-slots!
; dead binder, closure has 2 slots

; Mixed
'{/x /y [/z z x] y} boundness! liveness! slots! test-slots!
; generator sees x (slot 0), allocates z (slot 2)

; Operators and literals (no slots)
'{1 2 +} boundness! liveness! slots! test-slots!

'{/x 1 x +} boundness! liveness! slots! test-slots!

; Free variables (no slots)
'{x} boundness! liveness! slots! test-slots!

'{/y x y} boundness! liveness! slots! test-slots!

; Register save slots for non-tail calls
; Helper to show apply node flags
; Note: 'in returns 0 if key exists, 1 if not - so then-branch runs when key exists
{ /map
  "max-slots=" print map 'max-slots @ print " " print
  ; Find apply nodes and show their flags
  map 'body @ { /node
    node 'save-context in {
      "save-ctx=" print node 'save-context @ print " " print
      "ctx-slot=" print node 'ctx-save-slot @ print " " print
    } { } ?!
    node 'save-return in {
      "save-rp=" print node 'save-return @ print " " print
      "rp-slot=" print node 'rp-save-slot @ print " " print
    } { } ?!
    node 'restore-context in {
      "restore-ctx=" print node 'restore-context @ print " " print
    } { } ?!
    node 'restore-return in {
      "restore-rp=" print node 'restore-return @ print " " print
    } { } ?!
  } foldl!
  nl!
} /test-apply-slots

; Single non-tail call with context restore
'{x f! 1} boundness! liveness! slots! test-apply-slots!
; save-ctx=0 (first), save-rp=0 (first), restore-ctx=0, restore-rp=0

; Two non-tail calls - second should NOT save again
'{x f! y g! 1} boundness! liveness! slots! test-apply-slots!
; First call: save-ctx=0, save-rp=0, restore-ctx=0
; Second call: NO save-ctx, restore-ctx=0, restore-rp=0

; Call without context restore (no free var between calls)
'{f! g! 1} boundness! liveness! slots! test-apply-slots!
; First: save-rp=0, no ctx restore
; Second: restore-rp=0, no ctx restore

; Tail call (no saves needed)
'{f!} boundness! liveness! slots! test-apply-slots!
; No saves or restores
