; Test slot allocation via compile-func
; compile-func runs boundness -> liveness -> slots, so output includes all analysis

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 1000 < { } { "ERROR: froth-bytecode-top >= 1000, test addresses may conflict" println! } ?!

; Helper to compile and show result
{ /func
  tree-empty! 1000 func compile-func! /node drop! drop!
  node 'body @ write " " print node 'max-slots @ println!
} /test-slots

; Basic cases
'{/x x} test-slots!
; slot 0 for x

'{/x} test-slots!
; dead binder, no slot

'{/x /y x y} test-slots!
; two slots

'{/x /y y x} test-slots!
; same two slots, different order

; Slot reuse
'{/x x /y y} test-slots!
; slot 0 reused for y

'{/x x /y y /z z} test-slots!
; slot 0 reused for all

'{/x /y x y /z z} test-slots!
; slot 1 freed after y, reused for z

; Generator (same frame, slots thread through)
'{/x [/y y] x} test-slots!
; generator uses slot 1

'{/x [/y y] /z z x} test-slots!
; slot 1 reused for z after generator

'{/x x [/y y]} test-slots!
; slot 0 reused inside generator

; Closure (own frame)
'{/x {/y y} x} test-slots!
; closure has own frame with 1 slot

'{/x {/y /z y z}} test-slots!
; dead binder, closure has 2 slots

; Mixed
'{/x /y [/z z x] y} test-slots!
; generator sees x (slot 0), allocates z (slot 2)

; Operators and literals (no slots)
'{1 2 +} test-slots!

'{/x 1 x +} test-slots!

; Free variables (no slots)
'{x} test-slots!

'{/y x y} test-slots!

; Register save slots for non-tail calls
; Helper to show apply node flags
; Note: 'in returns 0 if key exists, 1 if not - so then-branch runs when key exists
{ /func
  tree-empty! 1000 func compile-func! /node drop! drop!
  "max-slots=" print node 'max-slots @ print " " print
  ; Find apply nodes and show their flags
  node 'body @ { /n
    n 'save-context in {
      "save-ctx=" print n 'save-context @ print " " print
      "ctx-slot=" print n 'ctx-save-slot @ print " " print
    } { } ?!
    n 'save-return in {
      "save-rp=" print n 'save-return @ print " " print
      "rp-slot=" print n 'rp-save-slot @ print " " print
    } { } ?!
    n 'restore-context in {
      "restore-ctx=" print n 'restore-context @ print " " print
    } { } ?!
    n 'restore-return in {
      "restore-rp=" print n 'restore-return @ print " " print
    } { } ?!
  } foldl!
  nl!
} /test-apply-slots

; Single non-tail call with context restore
'{x f! 1} test-apply-slots!
; save-ctx=0 (first), save-rp=0 (first), restore-ctx=0, restore-rp=0

; Two non-tail calls - second should NOT save again
'{x f! y g! 1} test-apply-slots!
; First call: save-ctx=0, save-rp=0, restore-ctx=0
; Second call: NO save-ctx, restore-ctx=0, restore-rp=0

; Call without context restore (no free var between calls)
'{f! g! 1} test-apply-slots!
; First: save-rp=0, no ctx restore
; Second: restore-rp=0, no ctx restore

; Tail call (no saves needed)
'{f!} test-apply-slots!
; No saves or restores
