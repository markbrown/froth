; Test slot allocation

; Helper to test slots - shows children and max-slots
{ /map /func
  map 'children @ write " " print map 'max-slots @ println!
} /test-slots

; Basic cases
'{/x x} boundness! liveness! slots! test-slots!
; slot 0 for x

'{/x} boundness! liveness! slots! test-slots!
; dead binder, no slot

'{/x /y x y} boundness! liveness! slots! test-slots!
; two slots

'{/x /y y x} boundness! liveness! slots! test-slots!
; same two slots, different order

; Slot reuse
'{/x x /y y} boundness! liveness! slots! test-slots!
; slot 0 reused for y

'{/x x /y y /z z} boundness! liveness! slots! test-slots!
; slot 0 reused for all

'{/x /y x y /z z} boundness! liveness! slots! test-slots!
; slot 1 freed after y, reused for z

; Generator (same frame, slots thread through)
'{/x [/y y] x} boundness! liveness! slots! test-slots!
; generator uses slot 1

'{/x [/y y] /z z x} boundness! liveness! slots! test-slots!
; slot 1 reused for z after generator

'{/x x [/y y]} boundness! liveness! slots! test-slots!
; slot 0 reused inside generator

; Closure (own frame)
'{/x {/y y} x} boundness! liveness! slots! test-slots!
; closure has own frame with 1 slot

'{/x {/y /z y z}} boundness! liveness! slots! test-slots!
; dead binder, closure has 2 slots

; Mixed
'{/x /y [/z z x] y} boundness! liveness! slots! test-slots!
; generator sees x (slot 0), allocates z (slot 2)

; Operators and literals (no slots)
'{1 2 +} boundness! liveness! slots! test-slots!

'{/x 1 x +} boundness! liveness! slots! test-slots!

; Free variables (no slots)
'{x} boundness! liveness! slots! test-slots!

'{/y x y} boundness! liveness! slots! test-slots!
