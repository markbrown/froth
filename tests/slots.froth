; Test slot allocation

; Helper to test slots
{ /f
  f boundness! /bnd /bs /fs
  f fs bs bnd liveness! /live
  f bnd live slots! /max /sl
  sl write " " print max println!
} /test-slots

; Basic cases
'{/x x} test-slots!
; [0 0] 1 - one slot for x

'{/x} test-slots!
; [.] 0 - dead binder, no slot

'{/x /y x y} test-slots!
; [0 1 0 1] 2 - two slots

'{/x /y y x} test-slots!
; [0 1 1 0] 2 - same two slots, different order

; Slot reuse
'{/x x /y y} test-slots!
; [0 0 0 0] 1 - slot 0 reused for y

'{/x x /y y /z z} test-slots!
; [0 0 0 0 0 0] 1 - slot 0 reused for all

'{/x /y x y /z z} test-slots!
; [0 1 0 1 1 1] 2 - slot 1 freed after y, reused for z

; Generator (same frame, slots thread through)
'{/x [/y y] x} test-slots!
; [0 [1 1] 0] 2 - generator uses slot 1

'{/x [/y y] /z z x} test-slots!
; [0 [1 1] 1 1 0] 2 - slot 1 reused for z after generator

'{/x x [/y y]} test-slots!
; [0 0 [0 0]] 1 - slot 0 reused inside generator

; Closure (own frame)
'{/x {/y y} x} test-slots!
; [0 [[0 0] 1] 0] 1 - closure has own frame with 1 slot

'{/x {/y /z y z}} test-slots!
; [. [[0 1 0 1] 2]] 0 - dead binder, closure has 2 slots

; Mixed
'{/x /y [/z z x] y} test-slots!
; [0 1 [2 2 0] 1] 3 - generator sees x (slot 0), allocates z (slot 2)

; Operators and literals (no slots)
'{1 2 +} test-slots!
; [. . .] 0

'{/x 1 x +} test-slots!
; [0 . 0 .] 1

; Free variables (no slots)
'{x} test-slots!
; [.] 0

'{/y x y} test-slots!
; [0 . 0] 1
