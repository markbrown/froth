; Test slot allocation via compile-func
; Tests specific slot fields rather than full node structure

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 24000 < { } { "ERROR: froth-bytecode-top >= 24000, test addresses may conflict" println! } ?!

; Helper to show slots for binders and bound identifiers
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  "max=" print node 'max-slots @ print " slots: " print
  node 'body @ { /n
    n 'term @ isBinder {
      n 'is-used @ {  ; show if used (is-used=0)
        n 'term @ write "=" print n 'slot @ print " " print
      } { } ?!
    } { } ?!
    n 'term @ isIdent {
      n 'is-operator @ { } {  ; skip operators (is-operator=0), process variables (is-operator=1)
        n 'is-bound @ {  ; if bound (is-bound=0)
          n 'term @ write "=" print n 'slot @ print " " print
        } { } ?!
      } ?!
    } { } ?!
  } foldl!
  nl!
} /test-slots

; Helper to show apply node flags
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  "max=" print node 'max-slots @ print " " print
  node 'body @ { /n
    n 'term @ isApply {
      n 'save-context in { "save-ctx=" print n 'save-context @ print " ctx-slot=" print n 'ctx-save-slot @ print " " print } { } ?!
      n 'save-return in { "save-rp=" print n 'save-return @ print " rp-slot=" print n 'rp-save-slot @ print " " print } { } ?!
      n 'restore-context in { "restore-ctx=" print n 'restore-context @ print " " print } { } ?!
      n 'restore-return in { "restore-rp=" print n 'restore-return @ print " " print } { } ?!
      "| " print
    } { } ?!
  } foldl!
  nl!
} /test-apply

; === Basic slot allocation ===
"--- Basic slots ---" println!

'{/x x} test-slots!
; slot 0 for x

'{/x} test-slots!
; dead binder, no slot (max=0)

'{/x /y x y} test-slots!
; two slots

'{/x /y y x} test-slots!
; same two slots

; === Slot reuse ===
"--- Slot reuse ---" println!

'{/x x /y y} test-slots!
; slot 0 reused for y

'{/x x /y y /z z} test-slots!
; slot 0 reused for all

'{/x /y x y /z z} test-slots!
; slot 1 freed after y, reused for z

; === Generator (shares frame) ===
"--- Generators ---" println!

'{/x [/y y] x} test-slots!
; generator uses slot 1

'{/x [/y y] /z z x} test-slots!
; slot 1 reused for z after generator

'{/x x [/y y]} test-slots!
; slot 0 reused inside generator

; === Closure (own frame) ===
"--- Nested closures ---" println!

'{/x {/y y} x} test-slots!
; closure has own frame with 1 slot

'{/x {/y /z y z}} test-slots!
; dead x in outer, closure has 2 slots

; === Operators and literals ===
"--- Operators/literals ---" println!

'{1 2 +} test-slots!
; no slots

'{/x 1 x +} test-slots!
; one slot

; === Free variables ===
"--- Free vars ---" println!

'{x} test-slots!
; no frame slots (free var uses context)

'{/y x y} test-slots!
; one slot for y, x uses context

; === Register save slots ===
"--- Register saves ---" println!

'{x f! 1} test-apply!
; save-ctx=0 (first), save-rp=0 (first), restore-ctx=0, restore-rp=0

'{x f! y g! 1} test-apply!
; First call: save-ctx=0, save-rp=0, restore-ctx=0
; Second call: ctx-slot inherited, restore-ctx=0, restore-rp=0

'{f! g! 1} test-apply!
; No context save (no free var between calls)

'{f!} test-apply!
; Tail call - no saves or restores

'{f! 1 +} test-apply!
; Non-tail, needs saves

"done" println!
