; Test bytecode VM execution
; Track bytecode address explicitly with /here pattern

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-state 'addr @ 24000 < { } { "ERROR: froth-state 'addr @ >= 24000, test addresses may conflict" println! } ?!

; Instruction shortcuts
instruction-table 'push-int @ /ocPushInt
instruction-table 'op @ /ocOp
instruction-table 'return @ /ocReturn
instruction-table 'push-context @ /ocPushContext
instruction-table 'pop-unused @ /ocPopUnused
instruction-table 'push-local @ /ocPushLocal
instruction-table 'pop-local @ /ocPopLocal
instruction-table 'enter-frame @ /ocEnterFrame
instruction-table 'leave-frame @ /ocLeaveFrame
instruction-table 'start-array @ /ocStartArray
instruction-table 'end-array @ /ocEndArray
instruction-table 'call @ /ocCall
instruction-table 'save-return-ptr @ /ocSaveReturnPtr
instruction-table 'restore-return-ptr @ /ocRestoreReturnPtr
instruction-table 'save-context-ptr @ /ocSaveContextPtr
instruction-table 'restore-context-ptr @ /ocRestoreContextPtr

; Operator shortcuts
operator-table '+ @ /opAdd
operator-table '- @ /opSub
operator-table '* @ /opMul

24000 /here

; Test 1: 1 + 2 = 3
here /addr
[ ocPushInt 1 ocPushInt 2 ocOp opAdd ocReturn ] here emit-all-at! /here
[] addr close ! println!

; Test 2: 10 - 3 = 7
here /addr
[ ocPushInt 10 ocPushInt 3 ocOp opSub ocReturn ] here emit-all-at! /here
[] addr close ! println!

; Test 3: 6 * 7 = 42
here /addr
[ ocPushInt 6 ocPushInt 7 ocOp opMul ocReturn ] here emit-all-at! /here
[] addr close ! println!

; Test 4: (2 + 3) * 4 = 20
here /addr
[ ocPushInt 2 ocPushInt 3 ocOp opAdd ocPushInt 4 ocOp opMul ocReturn ] here emit-all-at! /here
[] addr close ! println!

; Test 5: Just return (identity on stack)
here /addr
[ ocReturn ] here emit-all-at! /here
42 [] addr close ! println!

; Test 6: pushContext - closure with captured value
here /addr
[ ocPushContext 0 ocReturn ] here emit-all-at! /here
[ 99 ] addr close ! println!

; Test 7: popUnused - discard top of stack
here /addr
[ ocPushInt 1 ocPushInt 2 ocPopUnused ocReturn ] here emit-all-at! /here
[] addr close ! println!

; Test 8: local variables with frame
; { x -> x x * } compiles to: enter 1, pop-local 0, push-local 0, push-local 0, mul, leave 1, return
here /addr
[ ocEnterFrame 1 ocPopLocal 0 ocPushLocal 0 ocPushLocal 0 ocOp opMul ocLeaveFrame 1 ocReturn ] here emit-all-at! /here
7 [] addr close ! println!

; Test 9: array generator [ 1 2 3 ]
here /addr
[ ocStartArray ocPushInt 1 ocPushInt 2 ocPushInt 3 ocEndArray ocReturn ] here emit-all-at! /here
[] addr close ! # println!

; Test 10: nested generators [ [ 1 ] [ 2 3 ] ]
here /addr
[ ocStartArray
    ocStartArray ocPushInt 1 ocEndArray
    ocStartArray ocPushInt 2 ocPushInt 3 ocEndArray
  ocEndArray ocReturn ] here emit-all-at! /here
[] addr close ! # println!

; Test 11: bytecode-to-bytecode call
; Callee: adds 10 to value on stack
here /callee-addr
[ ocPushInt 10 ocOp opAdd ocReturn ] here emit-all-at! /here

; Caller: pushes 5, calls callee from context[0]
; Uses frame to save RP and Context so they don't interfere with arguments
here /caller-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 5
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] here emit-all-at! /here

[] callee-addr close /callee
[ callee ] caller-addr close ! println!

; Test 12: nested bytecode calls (A calls B calls C)
; C: adds 1 to value on stack
here /c-addr
[ ocPushInt 1 ocOp opAdd ocReturn ] here emit-all-at! /here

; B: adds 10, then calls C from context[0]
here /b-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 10 ocOp opAdd
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] here emit-all-at! /here

; A: pushes 100, calls B from context[0]
here /a-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 100
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] here emit-all-at! /here

[] c-addr close /funcC
[ funcC ] b-addr close /funcB
[ funcB ] a-addr close ! println!
