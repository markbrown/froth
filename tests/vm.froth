; Test bytecode VM execution

; Test 1: 1 + 2 = 3
here /addr
[ ocPushInt 1 ocPushInt 2 ocOp opAdd ocReturn ] emit-all!
[] addr close ! println!

; Test 2: 10 - 3 = 7
here /addr
[ ocPushInt 10 ocPushInt 3 ocOp opSub ocReturn ] emit-all!
[] addr close ! println!

; Test 3: 6 * 7 = 42
here /addr
[ ocPushInt 6 ocPushInt 7 ocOp opMul ocReturn ] emit-all!
[] addr close ! println!

; Test 4: (2 + 3) * 4 = 20
here /addr
[ ocPushInt 2 ocPushInt 3 ocOp opAdd ocPushInt 4 ocOp opMul ocReturn ] emit-all!
[] addr close ! println!

; Test 5: Just return (identity on stack)
here /addr
[ ocReturn ] emit-all!
42 [] addr close ! println!

; Test 6: pushContext - closure with captured value
here /addr
[ ocPushContext 0 ocReturn ] emit-all!
[ 99 ] addr close ! println!

; Test 7: popUnused - discard top of stack
here /addr
[ ocPushInt 1 ocPushInt 2 ocPopUnused ocReturn ] emit-all!
[] addr close ! println!

; Test 8: local variables with frame
; { x -> x x * } compiles to: enter 1, pop-local 0, push-local 0, push-local 0, mul, leave 1, return
here /addr
[ ocEnterFrame 1 ocPopLocal 0 ocPushLocal 0 ocPushLocal 0 ocOp opMul ocLeaveFrame 1 ocReturn ] emit-all!
7 [] addr close ! println!

; Test 9: array generator [ 1 2 3 ]
here /addr
[ ocStartArray ocPushInt 1 ocPushInt 2 ocPushInt 3 ocEndArray ocReturn ] emit-all!
[] addr close ! # println!

; Test 10: nested generators [ [ 1 ] [ 2 3 ] ]
here /addr
[ ocStartArray
    ocStartArray ocPushInt 1 ocEndArray
    ocStartArray ocPushInt 2 ocPushInt 3 ocEndArray
  ocEndArray ocReturn ] emit-all!
[] addr close ! # println!

; Test 11: bytecode-to-bytecode call
; Callee: adds 10 to value on stack
here /callee-addr
[ ocPushInt 10 ocOp opAdd ocReturn ] emit-all!

; Caller: pushes 5, calls callee from context[0]
; Uses frame to save RP and Context so they don't interfere with arguments
here /caller-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 5
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

[] callee-addr close /callee
[ callee ] caller-addr close ! println!

; Test 12: nested bytecode calls (A calls B calls C)
; C: adds 1 to value on stack
here /c-addr
[ ocPushInt 1 ocOp opAdd ocReturn ] emit-all!

; B: adds 10, then calls C from context[0]
here /b-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 10 ocOp opAdd
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

; A: pushes 100, calls B from context[0]
here /a-addr
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 100
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

[] c-addr close /funcC
[ funcC ] b-addr close /funcB
[ funcB ] a-addr close ! println!
