; Test bytecode VM execution

; Test 1: 1 + 2 = 3
; Address 0, size 7
[ ocPushInt 1 ocPushInt 2 ocOp opAdd ocReturn ] emit-all!
[] 0 close ! println!

; Test 2: 10 - 3 = 7
; Address 7, size 7
[ ocPushInt 10 ocPushInt 3 ocOp opSub ocReturn ] emit-all!
[] 7 close ! println!

; Test 3: 6 * 7 = 42
; Address 14, size 7
[ ocPushInt 6 ocPushInt 7 ocOp opMul ocReturn ] emit-all!
[] 14 close ! println!

; Test 4: (2 + 3) * 4 = 20
; Address 21, size 11
[ ocPushInt 2 ocPushInt 3 ocOp opAdd ocPushInt 4 ocOp opMul ocReturn ] emit-all!
[] 21 close ! println!

; Test 5: Just return (identity on stack)
; Address 32, size 1
[ ocReturn ] emit-all!
42 [] 32 close ! println!

; Test 6: pushContext - closure with captured value
; Address 33, size 3
[ ocPushContext 0 ocReturn ] emit-all!
[ 99 ] 33 close ! println!

; Test 7: popUnused - discard top of stack
; Address 36, size 6
[ ocPushInt 1 ocPushInt 2 ocPopUnused ocReturn ] emit-all!
[] 36 close ! println!

; Test 8: local variables with frame
; Address 42, size 13
; { x -> x x * } compiles to: enter 1, pop-local 0, push-local 0, push-local 0, mul, leave 1, return
[ ocEnterFrame 1 ocPopLocal 0 ocPushLocal 0 ocPushLocal 0 ocOp opMul ocLeaveFrame 1 ocReturn ] emit-all!
7 [] 42 close ! println!

; Test 9: array generator [ 1 2 3 ]
; Address 55, size 9
[ ocStartArray ocPushInt 1 ocPushInt 2 ocPushInt 3 ocEndArray ocReturn ] emit-all!
[] 55 close ! # println!

; Test 10: nested generators [ [ 1 ] [ 2 3 ] ]
; Address 64, size 13
[ ocStartArray
    ocStartArray ocPushInt 1 ocEndArray
    ocStartArray ocPushInt 2 ocPushInt 3 ocEndArray
  ocEndArray ocReturn ] emit-all!
[] 64 close ! # println!

; Test 11: bytecode-to-bytecode call
; Callee at address 77, size 5: adds 10 to value on stack
[ ocPushInt 10 ocOp opAdd ocReturn ] emit-all!

; Caller at address 82, size 22: pushes 5, calls callee from context[0]
; Uses frame to save RP and Context so they don't interfere with arguments
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 5
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

[] 77 close /callee
[ callee ] 82 close ! println!

; Test 12: nested bytecode calls (A calls B calls C)
; C at address 104, size 5: adds 1 to value on stack
[ ocPushInt 1 ocOp opAdd ocReturn ] emit-all!

; B at address 109, size 24: adds 10, then calls C from context[0]
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 10 ocOp opAdd
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

; A at address 133, size 22: pushes 100, calls B from context[0]
[ ocEnterFrame 2
  ocSaveReturnPtr ocPopLocal 0
  ocSaveContextPtr ocPopLocal 1
  ocPushInt 100
  ocPushContext 0 ocCall
  ocPushLocal 1 ocRestoreContextPtr
  ocPushLocal 0 ocRestoreReturnPtr
  ocLeaveFrame 2 ocReturn ] emit-all!

[] 104 close /funcC
[ funcC ] 109 close /funcB
[ funcB ] 133 close ! println!
