; Test bytecode VM execution

; Test 1: 1 + 2 = 3
; Address 0, size 7
1 emit-push-int!
2 emit-push-int!
opAdd emit-op!
emit-return!
[] 0 close ! println!

; Test 2: 10 - 3 = 7
; Address 7, size 7
10 emit-push-int!
3 emit-push-int!
opSub emit-op!
emit-return!
[] 7 close ! println!

; Test 3: 6 * 7 = 42
; Address 14, size 7
6 emit-push-int!
7 emit-push-int!
opMul emit-op!
emit-return!
[] 14 close ! println!

; Test 4: (2 + 3) * 4 = 20
; Address 21, size 11
2 emit-push-int!
3 emit-push-int!
opAdd emit-op!
4 emit-push-int!
opMul emit-op!
emit-return!
[] 21 close ! println!

; Test 5: Just return (identity on stack)
; Address 32, size 1
emit-return!
42 [] 32 close ! println!

; Test 6: pushContext - closure with captured value
; Address 33, size 3 (push-context:2 + return:1)
0 emit-push-context!  ; push context slot 0
emit-return!
[ 99 ] 33 close ! println!  ; context has 99 in slot 0

; Test 7: popUnused - discard top of stack
; Address 36, size 6 (push:2 + push:2 + pop-unused:1 + return:1)
1 emit-push-int!
2 emit-push-int!
emit-pop-unused!     ; discard the 2
emit-return!         ; leaves 1 on stack
[] 36 close ! println!

; Test 8: local variables with frame
; Address 42, size 13
; { x -> x x * } compiles to: enter 1, pop-local 0, push-local 0, push-local 0, mul, leave 1, return
1 emit-enter-frame!
0 emit-pop-local!
0 emit-push-local!
0 emit-push-local!
opMul emit-op!
1 emit-leave-frame!
emit-return!
7 [] 42 close ! println!  ; 7 * 7 = 49

; Test 9: array generator [ 1 2 3 ]
; Address 55, size 9
emit-start-array!
1 emit-push-int!
2 emit-push-int!
3 emit-push-int!
emit-end-array!
emit-return!
[] 55 close ! # println!  ; array length = 3

; Test 10: nested generators [ [ 1 ] [ 2 3 ] ]
; Address 64, size 13
emit-start-array!
  emit-start-array!
  1 emit-push-int!
  emit-end-array!
  emit-start-array!
  2 emit-push-int!
  3 emit-push-int!
  emit-end-array!
emit-end-array!
emit-return!
[] 64 close ! # println!  ; outer array length = 2
