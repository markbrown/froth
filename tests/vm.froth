; Test bytecode VM execution

; Test 1: 1 + 2 = 3
; Address 0, size 7
1 emit-push-int!
2 emit-push-int!
opAdd emit-op!
emit-return!
[] 0 close ! println!

; Test 2: 10 - 3 = 7
; Address 7, size 7
10 emit-push-int!
3 emit-push-int!
opSub emit-op!
emit-return!
[] 7 close ! println!

; Test 3: 6 * 7 = 42
; Address 14, size 7
6 emit-push-int!
7 emit-push-int!
opMul emit-op!
emit-return!
[] 14 close ! println!

; Test 4: (2 + 3) * 4 = 20
; Address 21, size 11
2 emit-push-int!
3 emit-push-int!
opAdd emit-op!
4 emit-push-int!
opMul emit-op!
emit-return!
[] 21 close ! println!

; Test 5: Just return (identity on stack)
; Address 32, size 1
emit-return!
42 [] 32 close ! println!

; Test 6: pushContext - closure with captured value
; Address 33, size 3 (push-context:2 + return:1)
0 emit-push-context!  ; push context slot 0
emit-return!
[ 99 ] 33 close ! println!  ; context has 99 in slot 0

; Test 7: popUnused - discard top of stack
; Address 36, size 6 (push:2 + push:2 + pop-unused:1 + return:1)
1 emit-push-int!
2 emit-push-int!
emit-pop-unused!     ; discard the 2
emit-return!         ; leaves 1 on stack
[] 36 close ! println!

; Test 8: local variables with frame
; Address 42, size 13
; { x -> x x * } compiles to: enter 1, pop-local 0, push-local 0, push-local 0, mul, leave 1, return
1 emit-enter-frame!
0 emit-pop-local!
0 emit-push-local!
0 emit-push-local!
opMul emit-op!
1 emit-leave-frame!
emit-return!
7 [] 42 close ! println!  ; 7 * 7 = 49

; Test 9: array generator [ 1 2 3 ]
; Address 55, size 9
emit-start-array!
1 emit-push-int!
2 emit-push-int!
3 emit-push-int!
emit-end-array!
emit-return!
[] 55 close ! # println!  ; array length = 3

; Test 10: nested generators [ [ 1 ] [ 2 3 ] ]
; Address 64, size 13
emit-start-array!
  emit-start-array!
  1 emit-push-int!
  emit-end-array!
  emit-start-array!
  2 emit-push-int!
  3 emit-push-int!
  emit-end-array!
emit-end-array!
emit-return!
[] 64 close ! # println!  ; outer array length = 2

; Test 11: bytecode-to-bytecode call
; Callee at address 77, size 5: adds 10 to value on stack
10 emit-push-int!
opAdd emit-op!
emit-return!

; Caller at address 82, size 22: pushes 5, calls callee from context[0]
; Uses frame to save RP and Context so they don't interfere with arguments
2 emit-enter-frame!          ; frame slots: 0=RP, 1=Context
emit-save-return-ptr!        ; push RP to stack
0 emit-pop-local!            ; save RP to slot 0
emit-save-context-ptr!       ; push Context to stack
1 emit-pop-local!            ; save Context to slot 1
5 emit-push-int!             ; argument for callee
0 emit-push-context!         ; get callee from context[0]
emit-call!                   ; call callee, returns with 15 on stack
1 emit-push-local!           ; push saved Context
emit-restore-context-ptr!    ; restore Context
0 emit-push-local!           ; push saved RP
emit-restore-return-ptr!     ; restore RP
2 emit-leave-frame!          ; deallocate frame
emit-return!

; Create callee closure, put in caller's context, call caller
[] 77 close /callee
[ callee ] 82 close ! println!  ; should print 15 (5 + 10)

; Test 12: nested bytecode calls (A calls B calls C)
; C at address 104, size 5: adds 1 to value on stack
1 emit-push-int!
opAdd emit-op!
emit-return!

; B at address 109, size 24: adds 10, then calls C from context[0]
2 emit-enter-frame!
emit-save-return-ptr!
0 emit-pop-local!
emit-save-context-ptr!
1 emit-pop-local!
10 emit-push-int!            ; add 10 first
opAdd emit-op!
0 emit-push-context!         ; get C from context[0]
emit-call!                   ; call C (adds 1)
1 emit-push-local!
emit-restore-context-ptr!
0 emit-push-local!
emit-restore-return-ptr!
2 emit-leave-frame!
emit-return!

; A at address 133, size 22: pushes 100, calls B from context[0]
2 emit-enter-frame!
emit-save-return-ptr!
0 emit-pop-local!
emit-save-context-ptr!
1 emit-pop-local!
100 emit-push-int!           ; start with 100
0 emit-push-context!         ; get B from context[0]
emit-call!                   ; call B (adds 10, then calls C which adds 1)
1 emit-push-local!
emit-restore-context-ptr!
0 emit-push-local!
emit-restore-return-ptr!
2 emit-leave-frame!
emit-return!

; Create closures and call A
[] 104 close /funcC
[ funcC ] 109 close /funcB
[ funcB ] 133 close ! println!  ; should print 111 (100 + 10 + 1)
