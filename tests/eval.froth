; Test meta-interpreter

; Helper to run and print result (with empty op-table)

{ /closure /stack
  stack $ closure eval!
  /status
  status {
    fst println!
  } {
    println!  ; println! error message
  } ?!
} /run

; Helper to run with custom op-table
{ /closure /op-table /stack
  stack op-table closure eval!
  /status
  status {
    fst println!
  } {
    println!  ; println! error message
  } ?!
} /run-with-ops

; Integer literal
. { 42 } run!

; Addition
. { 3 4 + } run!

; Subtraction
. { 10 3 - } run!

; Multiplication
. { 5 6 * } run!

; Variable binding
. { 10 /x x } run!

; Expression
. { 5 3 * 2 + } run!

; Nested function
. { { 1 2 + } ! } run!

; Initial stack
. 10 , { 5 + } run!

; Equality
. { 5 5 = } run!
. { 5 6 = } run!

; Closure capturing variable
. { 10 /x { x 1 + } ! } run!

; Quoted term
. { 'foo isIdent } run!

; Generator
. { [ 1 2 3 ] } run!

; Env - check that bound variable is in simulated env
. { 42 /x env 'x in } run!

; Stack - check simulated stack contents
. 1 , 2 , { 3 stack } run!

; Custom operator - define 'double' that doubles a number
$ {2 *} 'double : /ops
. ops { 5 double } run-with-ops!

; Custom isOperator check
. ops { 'double isOperator } run-with-ops!

; Apply quoted built-in operator
. { 3 4 '+ ! } run!

; Apply quoted custom operator
. ops { 5 'double ! } run-with-ops!
