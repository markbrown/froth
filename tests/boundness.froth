; Test boundness analysis via compile-func
; Tests specific boundness fields rather than full node structure

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 24000 < { } { "ERROR: froth-bytecode-top >= 24000, test addresses may conflict" println! } ?!

; Helper to show boundness info for identifiers in body
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isIdent {
      n 'term @ write " " print
      "bound=" print n 'is-bound @ print " " print
      "op=" print n 'is-operator @ print
      n 'is-bound @ { } { " slot=" print n 'slot @ print } ?!  ; slot only for free vars
      " | " print
    } { } ?!
  } foldl!
  nl!
} /test-idents

; Helper to show func-level boundness info
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  "free=" print node 'free-vars-map @ writeln!
} /test-func

; Helper to show nested closure info
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isFunc {
      "nested: free=" print n 'free-vars-map @ writeln!
    } { } ?!
  } foldl!
} /test-nested

; === Identifier classification ===
"--- Identifier classification ---" println!

'{x} test-idents!
; x is free (bound=1), variable (op=1)

'{x y} test-idents!
; both free

'{/x x} test-idents!
; x is bound (bound=0)

'{x /x x} test-idents!
; outer x free, inner x bound

'{1 2 +} test-idents!
; + is operator (op=0)

'{/+ x + y} test-idents!
; + is bound (shadowed operator)

; === Function-level info ===
"--- Function-level ---" println!

'{x} test-func!
; free={x:0}, bound=[]

'{/x x} test-func!
; free={}, bound=[x]

'{x y} test-func!
; free={x:0, y:1}, bound=[]

'{x /x x} test-func!
; free={x:0}, bound=[x]

'{} test-func!
; empty

; === Nested closures ===
"--- Nested closures ---" println!

'{x {x}} test-nested!
; inner captures x

'{/x {x} x} test-nested!
; inner captures x from outer's bound set

'{{x}} test-nested!
; inner captures x from outer's free

'{/x {/y x y}} test-nested!
; inner captures x, binds y

'{x {/x x}} test-nested!
; inner shadows x, no capture

; === Generators (share scope) ===
"--- Generators ---" println!
{ /func
  tree-empty! 24000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isGen {
      "gen bound=" print n 'bound-set @ keys print " " print
    } { } ?!
  } foldl!
  nl!
} /test-gen

'{/x [x]} test-gen!
; generator uses outer's x

'{/x [/y y] x} test-gen!
; generator binds y locally

'{x [/x x] x} test-gen!
; generator shadows x

"done" println!
