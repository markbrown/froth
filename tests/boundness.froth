; Test boundness analysis via compile-func
; compile-func returns (code-map addr func-node) where node has 'term, 'body, 'free-vars-map, 'bound-set

; Helper to compile and show result
{ /func
  tree-empty! 0 func compile-func! /node drop! drop!
  "free=" print node 'free-vars-map @ write
  " bound=" print node 'bound-set @ write
  " body=" print node 'body @ writeln!
} /test

; Test 1: {x /x x}
'{x /x x} test!

; Test 2: {/x [x] x}
'{/x [x] x} test!

; Test 3: {/x {x} x}
'{/x {x} x} test!

; Test 4: {x /x [/y x y] x y}
'{x /x [/y x y] x y} test!

; Test 5: {x /x {/y x y} x y}
'{x /x {/y x y} x y} test!

; Additional edge cases

; Empty function
'{} test!

; Single binder
'{/x} test!

; Deeply nested
'{/x {/y {x y}}} test!

; Multiple uses of same variable
'{/x x x x} test!

; Shadowing within generator
'{/x [/x x] x} test!

; Free before bound, closure after
'{x /x {x} x} test!

; Generator with free var
'{/x x {x} x} test!

; Generator shadows outer
'{x [/x x] x} test!

; Operators are not free variables (looked up in op-table)
'{x 10 *} test!

; Shadowed operator IS a bound variable
'{/+ x + y} test!

; Generator with different free var - y inside generator should use outer slot 1
'{x [y]} test!
