; Test save slot allocation in slots pass

; Helper to safely get a key, returning nil if not present
{ /key /map
  map key in 0 = { map key @ } { "nil" } ?!
} /get-or-nil

; Helper to show slot info for an apply node
{ /node
  "  ctx-save-slot: " print node 'ctx-save-slot get-or-nil! println!
  "  rp-save-slot: " print node 'rp-save-slot get-or-nil! println!
} /show-apply

; Helper to show closure info
{ /node
  "  max-slots: " print node 'max-slots @ println!
} /show-closure

; Example 1: {/f x f!} - tail call, no saves needed
; Terms: 0=/f 1=x 2=f 3=!
"Example 1: {/f x f!}" println!
'{/f x f!} boundness! liveness! slots! /node1 /func1
node1 show-closure!
"  apply node (idx 3):" println!
node1 'body @ 3 @ show-apply!

; Example 2: {/f x f! y} - non-tail call, needs both saves
; Terms: 0=/f 1=x 2=f 3=! 4=y
"Example 2: {/f x f! y}" println!
'{/f x f! y} boundness! liveness! slots! /node2 /func2
node2 show-closure!
"  apply node (idx 3):" println!
node2 'body @ 3 @ show-apply!

; Example 3: {/f x f! g!} - non-tail call then tail call
; Terms: 0=/f 1=x 2=f 3=! 4=g 5=!
"Example 3: {/f x f! g!}" println!
'{/f x f! g!} boundness! liveness! slots! /node3 /func3
node3 show-closure!
"  first apply node (idx 3):" println!
node3 'body @ 3 @ show-apply!
"  second apply node (idx 5):" println!
node3 'body @ 5 @ show-apply!

; Example 4: {/f g! f!} - RP restore only
; Terms: 0=/f 1=g 2=! 3=f 4=!
"Example 4: {/f g! f!}" println!
'{/f g! f!} boundness! liveness! slots! /node4 /func4
node4 show-closure!
"  first apply node (idx 2):" println!
node4 'body @ 2 @ show-apply!
"  second apply node (idx 4):" println!
node4 'body @ 4 @ show-apply!

; Example 5: {/x x x * f! 1 +} - slot reuse
; Terms: 0=/x 1=x 2=x 3=* 4=f 5=! 6=1 7=+
"Example 5: {/x x x * f! 1 +}" println!
'{/x x x * f! 1 +} boundness! liveness! slots! /node5 /func5
node5 show-closure!
"  apply node (idx 5):" println!
node5 'body @ 5 @ show-apply!
