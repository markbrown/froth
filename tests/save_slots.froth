; Test save slot allocation via compile-func
; compile-func runs boundness -> liveness -> slots, so output includes all analysis

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 2000 < { } { "ERROR: froth-bytecode-top >= 2000, test addresses may conflict" println! } ?!

; Helper to safely get a key, returning nil if not present
{ /key /map
  map key in 0 = { map key @ } { "nil" } ?!
} /get-or-nil

; Helper to show slot info for an apply node
{ /node
  "  ctx-save-slot: " print node 'ctx-save-slot get-or-nil! println!
  "  rp-save-slot: " print node 'rp-save-slot get-or-nil! println!
} /show-apply

; Helper to show closure info
{ /node
  "  max-slots: " print node 'max-slots @ println!
} /show-closure

; Example 1: {/f x f!} - tail call, no saves needed
; Terms: 0=/f 1=x 2=f 3=!
"Example 1: {/f x f!}" println!
tree-empty! 2000 '{/f x f!} compile-func! /node1 drop! drop!
node1 show-closure!
"  apply node (idx 3):" println!
node1 'body @ 3 @ show-apply!

; Example 2: {/f x f! y} - non-tail call, needs both saves
; Terms: 0=/f 1=x 2=f 3=! 4=y
"Example 2: {/f x f! y}" println!
tree-empty! 2000 '{/f x f! y} compile-func! /node2 drop! drop!
node2 show-closure!
"  apply node (idx 3):" println!
node2 'body @ 3 @ show-apply!

; Example 3: {/f x f! g!} - non-tail call then tail call
; Terms: 0=/f 1=x 2=f 3=! 4=g 5=!
"Example 3: {/f x f! g!}" println!
tree-empty! 2000 '{/f x f! g!} compile-func! /node3 drop! drop!
node3 show-closure!
"  first apply node (idx 3):" println!
node3 'body @ 3 @ show-apply!
"  second apply node (idx 5):" println!
node3 'body @ 5 @ show-apply!

; Example 4: {/f g! f!} - RP restore only
; Terms: 0=/f 1=g 2=! 3=f 4=!
"Example 4: {/f g! f!}" println!
tree-empty! 2000 '{/f g! f!} compile-func! /node4 drop! drop!
node4 show-closure!
"  first apply node (idx 2):" println!
node4 'body @ 2 @ show-apply!
"  second apply node (idx 4):" println!
node4 'body @ 4 @ show-apply!

; Example 5: {/x x x * f! 1 +} - slot reuse
; Terms: 0=/x 1=x 2=x 3=* 4=f 5=! 6=1 7=+
"Example 5: {/x x x * f! 1 +}" println!
tree-empty! 2000 '{/x x x * f! 1 +} compile-func! /node5 drop! drop!
node5 show-closure!
"  apply node (idx 5):" println!
node5 'body @ 5 @ show-apply!
