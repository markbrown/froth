; Test compile-named-closure

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-state 'addr @ 24000 < { } { "ERROR: froth-state 'addr @ >= 24000, test addresses may conflict" println! } ?!

; Test 1: Simple closure
{ 1 2 + } /f
cache-empty! tree-empty! 24000 f 'f compile-named-closure! /bv /addr /code-map /cache
"simple: " print bv! println!

; Test 2: Closure with captured closure (recursive compilation)
{ 10 } /g
{ g! 1 + } /f2
cache code-map addr f2 'f2 compile-named-closure! /bv2 /addr /code-map /cache
"captured: " print bv2! println!

; Test 3: Deep recursion (h -> g -> f)
{ 1 } /h
{ h! 10 + } /g2
{ g2! 100 + } /f3
cache code-map addr f3 'f3 compile-named-closure! /bv3 /addr /code-map /cache
"deep: " print bv3! println!

; Test 4: Cache reuse - compile same closure twice
{ 42 } /same
cache code-map addr same 'same compile-named-closure! /bv4a /addr4a /code-map /cache
cache code-map addr4a same 'same compile-named-closure! /bv4b /addr4b /code-map /cache
"cache addr unchanged: " print addr4a addr4b = { "yes" } { "no" } ?! println!
"cache result: " print bv4b! println!

; Test 5: Closure with non-closure captured value
42 /x
{ x 1 + } /f5
cache code-map addr4b f5 'f5 compile-named-closure! /bv5 /addr /code-map /cache
"non-closure capture: " print bv5! println!

; Test 6: Closure with multiple captures
{ 1 } /a
{ 2 } /b
{ a! b! + } /f6
cache code-map addr f6 'f6 compile-named-closure! /bv6 /addr /code-map /cache
"multi-capture: " print bv6! println!

; Test 7: Nested function in body
{ { 5 } ! } /f7
cache code-map addr f7 'f7 compile-named-closure! /bv7 /addr /code-map /cache
"nested func: " print bv7! println!

; Test 8: Generator in body
{ [ 1 2 3 ] } /f8
cache code-map addr f8 'f8 compile-named-closure! /bv8 /addr /code-map /cache
"generator: " print bv8! writeln!

; Test 9: compile function (lookup, compile, update env-map)
{ 100 } /h
$ h 'h : /env-map
cache code-map addr env-map 'h compile! /env-map /addr /code-map /cache
"compile: " print env-map 'h @ ! println!

; Test 10: Shadowed operator in nested function
; Regression test for bug where compiler didn't recognize shadowed operators
; The + in the inner function should refer to the {*} closure, not the + operator
{ {*} /+ {1 1 +!}! } /f10
cache code-map addr f10 'f10 compile-named-closure! /bv10 /addr /code-map /cache
"shadowed op: " print bv10! println!

; Test 11: Deeply nested shadowed operator
; f11 returns a closure that applies the shadowed + (which is multiplication)
{ {*} /+ { { +! } } } /f11
cache code-map addr f11 'f11 compile-named-closure! /bv11 /addr /code-map /cache
"deep shadowed: " print 3 4 bv11!!! println!

"done" println!
