; Test ref and deref operators (deep-ref behavior)

; Primitives return -1
"primitives: " print
42 ref print " " print          ; -1
. ref print " " print           ; -1
"hello" ref println!            ; -1

; Closurevals return -1 (must compile to bytecodeval first)
"closureval: " print
{ 1 2 + } ref println!          ; -1

; Arrays can be stored and retrieved
"array: " print
[ 1 2 3 ] ref /arr-ref
arr-ref print " " print         ; pool index (>= 0)
arr-ref deref println!          ; [ 1 2 3 ]

; Maps can be stored and retrieved
"map: " print
$ 42 'answer : ref /map-ref
map-ref print " " print         ; pool index
map-ref deref 'answer @ println! ; 42

; Cons cells can be stored and retrieved
"cons: " print
. 2, 1, ref /cons-ref
cons-ref print " " print        ; pool index
cons-ref deref fst println!     ; 1

; Deduplication: same structured value returns same index
"dedup: " print
[ 1 2 ] ref /a
[ 1 2 ] ref /b
a b = println!                  ; 0 (same index)

; Deep ref: substructures are pooled
"deep: " print
. 2, /tail
[tail tail 1,] ref /arr-ref2
tail ref /tail-ref
tail-ref 0 >= println!          ; 0 (tail was pooled by deep-ref)

; Sharing preserved: same substructure gets same index
"sharing: " print
tail ref /t1
tail ref /t2
t1 t2 = println!                ; 0 (same index)
