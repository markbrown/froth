; Test liveness analysis via compile-func
; Tests specific liveness fields rather than full node structure

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 2000 < { } { "ERROR: froth-bytecode-top >= 2000, test addresses may conflict" println! } ?!

; Helper to show liveness info for a single identifier node
; Prints: term is-live is-bound
{ /node
  node 'term @ write " " print
  "live=" print node 'is-live @ print " " print
  "bound=" print node 'is-bound @ print
} /show-ident

; Helper to show binder info
; Prints: term is-used
{ /node
  node 'term @ write " " print
  "used=" print node 'is-used @ print
} /show-binder

; Test identifier liveness
{ /func
  tree-empty! 2000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isIdent { n show-ident! " | " print } { } ?!
  } foldl!
  nl!
} /test-idents

; Test binder usage
{ /func
  tree-empty! 2000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isBinder { n show-binder! " | " print } { } ?!
  } foldl!
  nl!
} /test-binders

; Test func-node level flags
{ /func
  tree-empty! 2000 func compile-func! /node drop! drop!
  "needs-frame=" print node 'needs-frame @ print " " print
  "needs-ctx-save=" print node 'needs-ctx-save @ println!
} /test-func-flags

; Test dead-set for nested closures
{ /func
  tree-empty! 2000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isFunc {
      "dead-set=" print n 'dead-set @ keys writeln!
    } { } ?!
  } foldl!
} /test-dead-set

; === Identifier liveness tests ===
"--- Identifier liveness ---" println!

'{x} test-idents!
; x is free, last ref

'{x x} test-idents!
; first x still live (is-live=0), second x last ref (is-live=1)

'{x /x x} test-idents!
; outer x free and last, inner x bound and last

'{/x x x} test-idents!
; first x bound, still live; second x bound, last ref

; === Binder usage tests ===
"--- Binder usage ---" println!

'{/x x} test-binders!
; binder is used (is-used=0)

'{/x} test-binders!
; binder is dead (is-used=1)

'{/x /y x} test-binders!
; x is used, y is dead

; === Function-level flags ===
"--- Function flags ---" println!

'{1 2 +} test-func-flags!
; no frame needed (no binders)

'{/x x} test-func-flags!
; frame needed

'{f! 1} test-func-flags!
; frame needed for non-tail call, ctx-save needed

'{f!} test-func-flags!
; no frame (tail call only)

; === Dead-set tests ===
"--- Dead-set ---" println!

'{x {x}} test-dead-set!
; x's last use is capture, in dead-set

'{x {x} x} test-dead-set!
; x is still live after closure, dead-set empty

'{{x}} test-dead-set!
; x captured, in dead-set

'{x {/x x}} test-dead-set!
; outer x not captured (shadowed), dead-set empty

; === Tail call detection ===
"--- Tail calls ---" println!
{ /func
  tree-empty! 2000 func compile-func! /node drop! drop!
  node 'body @ { /n
    n 'term @ isApply {
      "apply: is-tail=" print n 'is-tail-call @ print
      n 'restore-context in { " restore-ctx=" print n 'restore-context @ print } { } ?!
      n 'restore-return in { " restore-rp=" print n 'restore-return @ print } { } ?!
      nl!
    } { } ?!
  } foldl!
} /test-calls

'{f!} test-calls!
; tail call

'{f! 1} test-calls!
; non-tail call

'{f! g!} test-calls!
; f is non-tail, g is tail

'{x f! 1} test-calls!
; non-tail with context restore

"done" println!
