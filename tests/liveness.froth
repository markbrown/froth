; Test liveness analysis via compile-func
; compile-func runs boundness -> liveness -> slots, so output includes all analysis

; Safety check: ensure compiled library code doesn't overlap with test addresses
froth-bytecode-top 1000 < { } { "ERROR: froth-bytecode-top >= 1000, test addresses may conflict" println! } ?!

; Helper to compile and show result
{ /func
  tree-empty! 1000 func compile-func! /node drop! drop!
  "body=" print node 'body @ writeln!
} /test-liveness

; Basic cases
'{x} test-liveness!
; Free var x, last ref

'{x x} test-liveness!
; First x still live, second x last ref

'{/x x} test-liveness!
; Binder used, x is last ref

'{x /x x} test-liveness!
; Outer x last ref (free), binder used, inner x last ref

'{/x x x} test-liveness!
; Binder used, first x still live, second x last ref

'{/x} test-liveness!
; Binder unused (dead)

'{/x /y x} test-liveness!
; /x used, /y unused, x is last ref

; Nested closures - should have dead-set
'{x {x} x} test-liveness!
; x still live after closure, dead-set empty

'{x {x}} test-liveness!
; x's last use is this capture, in dead-set

'{x {/x x}} test-liveness!
; outer x not captured (shadowed), inner binder used

'{{x}} test-liveness!
; x's last use is capture

; Nested generators (share scope)
'{x [x] x} test-liveness!
; generator shares scope, x still live

'{x [x]} test-liveness!
; generator's x is last ref

'{x [/x x] x} test-liveness!
; generator binder is local and used

; Empty cases
'{{}} test-liveness!
; empty nested closure with empty dead-set

'{[]} test-liveness!
; empty generator

; Multiple variables
'{x y} test-liveness!
; both are last refs

'{x y x} test-liveness!
; first x still live

'{x y x y} test-liveness!
; first x and y still live

; Operators (not tracked in liveness)
'{1 2 +} test-liveness!
; literals and operators
