; Test liveness analysis

; Helper to run liveness and print result
{ /f f boundness! /bnd /bs /fs f fs bs bnd liveness! write nl! } /test-liveness

; Basic cases
'{x} test-liveness!
; [1] - single free var is last-ref

'{x x} test-liveness!
; [0 1] - first x still live, second x last-ref

'{/x x} test-liveness!
; [0 1] - binder used (0), x is last-ref

'{x /x x} test-liveness!
; [1 0 1] - both x's are last-ref (different vars), binder used

'{/x x x} test-liveness!
; [0 0 1] - binder used, first x still live, second x last-ref

'{/x} test-liveness!
; [1] - binder unused (dead)

'{/x /y x} test-liveness!
; [0 1 1] - /x used, /y unused, x is last-ref

; Nested closures - format is [[inner-liveness] dead-set]
'{x {x} x} test-liveness!
; [0 [[1] $] 1] - x still live after closure, dead-set empty

'{x {x}} test-liveness!
; [0 [[1] $.'x:]] - x's last use is this capture, in dead-set

'{x {/x x}} test-liveness!
; [1 [[0 1] $]] - outer x not captured (shadowed), dead-set empty

'{{x}} test-liveness!
; [[[1] $.'x:]] - x's last use is capture

; Nested generators (share scope)
'{x [x] x} test-liveness!
; [0 [0] 1] - generator shares scope, x still live

'{x [x]} test-liveness!
; [0 [1]] - generator's x is last-ref

'{x [/x x] x} test-liveness!
; [0 [0 1] 1] - generator binder is local and used

; Empty cases
'{{}} test-liveness!
; [[[] $]] - empty nested closure with empty dead-set

'{[]} test-liveness!
; [[]] - empty generator

; Multiple variables
'{x y} test-liveness!
; [1 1] - both are last-refs

'{x y x} test-liveness!
; [0 1 1] - first x still live

'{x y x y} test-liveness!
; [0 0 1 1] - first x and y still live

; Operators (not tracked in liveness)
'{1 2 +} test-liveness!
; [. . .] - literals and operators
